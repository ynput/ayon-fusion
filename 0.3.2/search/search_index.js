var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Fusion addon","text":"<p>Fusion integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_fusion<ul> <li>addon</li> <li>api<ul> <li>action</li> <li>lib</li> <li>menu</li> <li>pipeline</li> <li>plugin</li> <li>pulse</li> </ul> </li> <li>deploy<ul> <li>MenuScripts<ul> <li>install_pyside2</li> <li>launch_menu</li> </ul> </li> </ul> </li> <li>hooks<ul> <li>pre_fusion_launch_menu_hook</li> <li>pre_fusion_profile_hook</li> <li>pre_fusion_setup</li> <li>pre_pyside_install</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_image_saver</li> <li>create_saver</li> <li>create_workfile</li> </ul> </li> <li>inventory<ul> <li>select_containers</li> <li>set_tool_color</li> </ul> </li> <li>load<ul> <li>actions</li> <li>load_alembic</li> <li>load_fbx</li> <li>load_sequence</li> <li>load_usd</li> <li>load_workfile</li> </ul> </li> <li>publish<ul> <li>collect_comp</li> <li>collect_comp_frame_range</li> <li>collect_inputs</li> <li>collect_instances</li> <li>collect_render</li> <li>collect_workfile</li> <li>extract_render_local</li> <li>increment_current_file</li> <li>save_scene</li> <li>validate_background_depth</li> <li>validate_comp_saved</li> <li>validate_create_folder_checked</li> <li>validate_expected_frames_existence</li> <li>validate_filename_has_extension</li> <li>validate_image_frame</li> <li>validate_instance_frame_range</li> <li>validate_instance_in_context</li> <li>validate_saver_has_input</li> <li>validate_saver_passthrough</li> <li>validate_saver_resolution</li> <li>validate_unique_subsets</li> </ul> </li> </ul> </li> <li>scripts<ul> <li>duplicate_with_inputs</li> </ul> </li> <li>vendor<ul> <li>attr<ul> <li>_cmp</li> <li>_compat</li> <li>_config</li> <li>_funcs</li> <li>_make</li> <li>_next_gen</li> <li>_version_info</li> <li>converters</li> <li>exceptions</li> <li>filters</li> <li>setters</li> <li>validators</li> </ul> </li> <li>urllib3<ul> <li>_collections</li> <li>_version</li> <li>connection</li> <li>connectionpool</li> <li>contrib<ul> <li>_appengine_environ</li> <li>_securetransport<ul> <li>bindings</li> <li>low_level</li> </ul> </li> <li>appengine</li> <li>ntlmpool</li> <li>pyopenssl</li> <li>securetransport</li> <li>socks</li> </ul> </li> <li>exceptions</li> <li>fields</li> <li>filepost</li> <li>packages<ul> <li>backports<ul> <li>makefile</li> </ul> </li> <li>six</li> <li>ssl_match_hostname<ul> <li>_implementation</li> </ul> </li> </ul> </li> <li>poolmanager</li> <li>request</li> <li>response</li> <li>util<ul> <li>connection</li> <li>proxy</li> <li>queue</li> <li>request</li> <li>response</li> <li>retry</li> <li>ssl_</li> <li>ssltransport</li> <li>timeout</li> <li>url</li> <li>wait</li> </ul> </li> </ul> </li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>imageio</li> <li>settings</li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_fusion/index.html","title":"ayon_fusion","text":""},{"location":"autoapi/client/ayon_fusion/index.html#client.ayon_fusion.get_fusion_version","title":"<code>get_fusion_version(app_name)</code>","text":"<p>The function is triggered by the prelaunch hooks to get the fusion version.</p> <p><code>app_name</code> is obtained by prelaunch hooks from the <code>launch_context.env.get(\"AYON_APP_NAME\")</code>.</p> <p>To get a correct Fusion version, a version number should be present in the <code>applications/fusion/variants</code> key of the Blackmagic Fusion Application Settings.</p> Source code in <code>client/ayon_fusion/addon.py</code> <pre><code>def get_fusion_version(app_name):\n    \"\"\"\n    The function is triggered by the prelaunch hooks to get the fusion version.\n\n    `app_name` is obtained by prelaunch hooks from the\n    `launch_context.env.get(\"AYON_APP_NAME\")`.\n\n    To get a correct Fusion version, a version number should be present\n    in the `applications/fusion/variants` key\n    of the Blackmagic Fusion Application Settings.\n    \"\"\"\n\n    log = Logger.get_logger(__name__)\n\n    if not app_name:\n        return\n\n    app_version_candidates = re.findall(r\"\\d+\", app_name)\n    if not app_version_candidates:\n        return\n    for app_version in app_version_candidates:\n        if int(app_version) in FUSION_VERSIONS_DICT:\n            return int(app_version)\n        else:\n            log.info(\n                \"Unsupported Fusion version: {app_version}\".format(\n                    app_version=app_version\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_fusion/addon.html#client.ayon_fusion.addon.get_fusion_version","title":"<code>get_fusion_version(app_name)</code>","text":"<p>The function is triggered by the prelaunch hooks to get the fusion version.</p> <p><code>app_name</code> is obtained by prelaunch hooks from the <code>launch_context.env.get(\"AYON_APP_NAME\")</code>.</p> <p>To get a correct Fusion version, a version number should be present in the <code>applications/fusion/variants</code> key of the Blackmagic Fusion Application Settings.</p> Source code in <code>client/ayon_fusion/addon.py</code> <pre><code>def get_fusion_version(app_name):\n    \"\"\"\n    The function is triggered by the prelaunch hooks to get the fusion version.\n\n    `app_name` is obtained by prelaunch hooks from the\n    `launch_context.env.get(\"AYON_APP_NAME\")`.\n\n    To get a correct Fusion version, a version number should be present\n    in the `applications/fusion/variants` key\n    of the Blackmagic Fusion Application Settings.\n    \"\"\"\n\n    log = Logger.get_logger(__name__)\n\n    if not app_name:\n        return\n\n    app_version_candidates = re.findall(r\"\\d+\", app_name)\n    if not app_version_candidates:\n        return\n    for app_version in app_version_candidates:\n        if int(app_version) in FUSION_VERSIONS_DICT:\n            return int(app_version)\n        else:\n            log.info(\n                \"Unsupported Fusion version: {app_version}\".format(\n                    app_version=app_version\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/version.html","title":"version","text":"<p>Package declaring AYON addon 'fusion' version.</p>"},{"location":"autoapi/client/ayon_fusion/api/index.html","title":"api","text":""},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.FusionHost","title":"<code>FusionHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>class FusionHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"fusion\"\n\n    def install(self):\n        \"\"\"Install fusion-specific functionality of AYON.\n\n        This is where you install menus and register families, data\n        and loaders into fusion.\n\n        It is called automatically when installing via\n        `ayon_core.pipeline.install_host(ayon_fusion.api)`\n\n        See the Maya equivalent for inspiration on how to implement this.\n\n        \"\"\"\n        # Remove all handlers associated with the root logger object, because\n        # that one always logs as \"warnings\" incorrectly.\n        for handler in logging.root.handlers[:]:\n            logging.root.removeHandler(handler)\n\n        # Attach default logging handler that prints to active comp\n        logger = logging.getLogger()\n        formatter = logging.Formatter(fmt=\"%(message)s\\n\")\n        handler = FusionLogHandler()\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        logger.setLevel(logging.DEBUG)\n\n        pyblish.api.register_host(\"fusion\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        log.info(\"Registering Fusion plug-ins..\")\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n\n        # Register events\n        register_event_callback(\"open\", on_after_open)\n        register_event_callback(\"workfile.save.before\", before_workfile_save)\n        register_event_callback(\"save\", on_save)\n        register_event_callback(\"new\", on_new)\n        register_event_callback(\"taskChanged\", on_task_changed)\n\n    # region workfile io api\n    def has_unsaved_changes(self):\n        comp = get_current_comp()\n        return comp.GetAttrs()[\"COMPB_Modified\"]\n\n    def get_workfile_extensions(self):\n        return [\".comp\"]\n\n    def save_workfile(self, dst_path=None):\n        comp = get_current_comp()\n        comp.Save(dst_path)\n\n    def open_workfile(self, filepath):\n        # Hack to get fusion, see\n        #   ayon_fusion.api.pipeline.get_current_comp()\n        fusion = getattr(sys.modules[\"__main__\"], \"fusion\", None)\n\n        return fusion.LoadComp(filepath)\n\n    def get_current_workfile(self):\n        comp = get_current_comp()\n        current_filepath = comp.GetAttrs()[\"COMPS_FileName\"]\n        if not current_filepath:\n            return None\n\n        return current_filepath\n\n    def work_root(self, session):\n        work_dir = session[\"AYON_WORKDIR\"]\n        scene_dir = session.get(\"AVALON_SCENEDIR\")\n        if scene_dir:\n            return os.path.join(work_dir, scene_dir)\n        else:\n            return work_dir\n    # endregion\n\n    @contextlib.contextmanager\n    def maintained_selection(self):\n        from .lib import maintained_selection\n        return maintained_selection()\n\n    def get_containers(self):\n        return ls()\n\n    def update_context_data(self, data, changes):\n        comp = get_current_comp()\n        comp.SetData(\"openpype\", data)\n\n    def get_context_data(self):\n        comp = get_current_comp()\n        return comp.GetData(\"openpype\") or {}\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.FusionHost.install","title":"<code>install()</code>","text":"<p>Install fusion-specific functionality of AYON.</p> <p>This is where you install menus and register families, data and loaders into fusion.</p> <p>It is called automatically when installing via <code>ayon_core.pipeline.install_host(ayon_fusion.api)</code></p> <p>See the Maya equivalent for inspiration on how to implement this.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install fusion-specific functionality of AYON.\n\n    This is where you install menus and register families, data\n    and loaders into fusion.\n\n    It is called automatically when installing via\n    `ayon_core.pipeline.install_host(ayon_fusion.api)`\n\n    See the Maya equivalent for inspiration on how to implement this.\n\n    \"\"\"\n    # Remove all handlers associated with the root logger object, because\n    # that one always logs as \"warnings\" incorrectly.\n    for handler in logging.root.handlers[:]:\n        logging.root.removeHandler(handler)\n\n    # Attach default logging handler that prints to active comp\n    logger = logging.getLogger()\n    formatter = logging.Formatter(fmt=\"%(message)s\\n\")\n    handler = FusionLogHandler()\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    logger.setLevel(logging.DEBUG)\n\n    pyblish.api.register_host(\"fusion\")\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    log.info(\"Registering Fusion plug-ins..\")\n\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n    register_inventory_action_path(INVENTORY_PATH)\n\n    # Register events\n    register_event_callback(\"open\", on_after_open)\n    register_event_callback(\"workfile.save.before\", before_workfile_save)\n    register_event_callback(\"save\", on_save)\n    register_event_callback(\"new\", on_new)\n    register_event_callback(\"taskChanged\", on_task_changed)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.comp_lock_and_undo_chunk","title":"<code>comp_lock_and_undo_chunk(comp, undo_queue_name='Script CMD', keep_undo=True)</code>","text":"<p>Lock comp and open an undo chunk during the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef comp_lock_and_undo_chunk(\n    comp,\n    undo_queue_name=\"Script CMD\",\n    keep_undo=True,\n):\n    \"\"\"Lock comp and open an undo chunk during the context\"\"\"\n    try:\n        comp.Lock()\n        comp.StartUndo(undo_queue_name)\n        yield\n    finally:\n        comp.Unlock()\n        comp.EndUndo(keep_undo)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.get_bmd_library","title":"<code>get_bmd_library()</code>","text":"<p>Get bmd library</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_bmd_library():\n    \"\"\"Get bmd library\"\"\"\n    bmd = getattr(sys.modules[\"__main__\"], \"bmd\", None)\n    return bmd\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.get_current_comp","title":"<code>get_current_comp()</code>","text":"<p>Get current comp in this session</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_current_comp():\n    \"\"\"Get current comp in this session\"\"\"\n    fusion = get_fusion_module()\n    if fusion is not None:\n        comp = fusion.CurrentComp\n        return comp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.imprint_container","title":"<code>imprint_container(tool, name, namespace, context, loader=None)</code>","text":"<p>Imprint a Loader with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>object</code> <p>The node in Fusion to imprint as container, usually a Loader.</p> required <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def imprint_container(tool,\n                      name,\n                      namespace,\n                      context,\n                      loader=None):\n    \"\"\"Imprint a Loader with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        tool (object): The node in Fusion to imprint as container, usually a\n            Loader.\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    data = [\n        (\"schema\", \"openpype:container-2.0\"),\n        (\"id\", AVALON_CONTAINER_ID),\n        (\"name\", str(name)),\n        (\"namespace\", str(namespace)),\n        (\"loader\", str(loader)),\n        (\"representation\", context[\"representation\"][\"id\"]),\n        (\"project_name\", context[\"project\"][\"name\"]),\n    ]\n\n    for key, value in data:\n        tool.SetData(\"avalon.{}\".format(key), value)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.ls","title":"<code>ls()</code>","text":"<p>List containers from active Fusion scene</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Fusion; once loaded they are called 'containers'</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List containers from active Fusion scene\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in Fusion; once loaded\n    they are called 'containers'\n\n    Yields:\n        dict: container\n\n    \"\"\"\n\n    comp = get_current_comp()\n    tools = comp.GetToolList(False).values()\n\n    for tool in tools:\n        container = parse_container(tool)\n        if container:\n            yield container\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.maintained_selection","title":"<code>maintained_selection(comp=None)</code>","text":"<p>Reset comp selection from before the context after the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection(comp=None):\n    \"\"\"Reset comp selection from before the context after the context\"\"\"\n    if comp is None:\n        comp = get_current_comp()\n\n    previous_selection = comp.GetToolList(True).values()\n    try:\n        yield\n    finally:\n        flow = comp.CurrentFrame.FlowView\n        flow.Select()  # No args equals clearing selection\n        if previous_selection:\n            for tool in previous_selection:\n                flow.Select(tool, True)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.parse_container","title":"<code>parse_container(tool)</code>","text":"<p>Returns imprinted container data of a tool</p> <p>This reads the imprinted data from <code>imprint_container</code>.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def parse_container(tool):\n    \"\"\"Returns imprinted container data of a tool\n\n    This reads the imprinted data from `imprint_container`.\n\n    \"\"\"\n\n    data = tool.GetData('avalon')\n    if not isinstance(data, dict):\n        return\n\n    # If not all required data return the empty container\n    required = ['schema', 'id', 'name',\n                'namespace', 'loader', 'representation']\n    if not all(key in data for key in required):\n        return\n\n    container = {key: data[key] for key in required}\n\n    # Add optional keys, like `project_name`\n    optional = [\"project_name\"]\n    for key in optional:\n        if key in data:\n            container[key] = data[key]\n\n    # Store the tool's name\n    container[\"objectName\"] = tool.Name\n\n    # Store reference to the tool object\n    container[\"_tool\"] = tool\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.set_current_context_framerange","title":"<code>set_current_context_framerange(task_entity=None)</code>","text":"<p>Set Comp's frame range based on current task.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def set_current_context_framerange(task_entity=None):\n    \"\"\"Set Comp's frame range based on current task.\"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(\n            fields={\"attrib.frameStart\",\n                    \"attrib.frameEnd\",\n                    \"attrib.handleStart\",\n                    \"attrib.handleEnd\"})\n\n    task_attributes = task_entity[\"attrib\"]\n    start = task_attributes[\"frameStart\"]\n    end = task_attributes[\"frameEnd\"]\n    handle_start = task_attributes[\"handleStart\"]\n    handle_end = task_attributes[\"handleEnd\"]\n    update_frame_range(start, end, set_render_range=True,\n                       handle_start=handle_start,\n                       handle_end=handle_end)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.update_frame_range","title":"<code>update_frame_range(start, end, comp=None, set_render_range=True, handle_start=0, handle_end=0)</code>","text":"<p>Set Fusion comp's start and end frame range</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(float, int)</code> <p>start frame</p> required <code>end</code> <code>(float, int)</code> <p>end frame</p> required <code>comp</code> <code>(object, Optional)</code> <p>comp object from fusion</p> <code>None</code> <code>set_render_range</code> <code>(bool, Optional)</code> <p>When True this will also set the composition's render start and end frame.</p> <code>True</code> <code>handle_start</code> <code>(float, int, Optional)</code> <p>frame handles before start frame</p> <code>0</code> <code>handle_end</code> <code>(float, int, Optional)</code> <p>frame handles after end frame</p> <code>0</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def update_frame_range(start, end, comp=None, set_render_range=True,\n                       handle_start=0, handle_end=0):\n    \"\"\"Set Fusion comp's start and end frame range\n\n    Args:\n        start (float, int): start frame\n        end (float, int): end frame\n        comp (object, Optional): comp object from fusion\n        set_render_range (bool, Optional): When True this will also set the\n            composition's render start and end frame.\n        handle_start (float, int, Optional): frame handles before start frame\n        handle_end (float, int, Optional): frame handles after end frame\n\n    Returns:\n        None\n\n    \"\"\"\n\n    if not comp:\n        comp = get_current_comp()\n\n    # Convert any potential none type to zero\n    handle_start = handle_start or 0\n    handle_end = handle_end or 0\n\n    attrs = {\n        \"COMPN_GlobalStart\": start - handle_start,\n        \"COMPN_GlobalEnd\": end + handle_end\n    }\n\n    # set frame range\n    if set_render_range:\n        attrs.update({\n            \"COMPN_RenderStart\": start,\n            \"COMPN_RenderEnd\": end\n        })\n\n    with comp_lock_and_undo_chunk(comp):\n        comp.SetAttrs(attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/action.html","title":"action","text":""},{"location":"autoapi/client/ayon_fusion/api/action.html#client.ayon_fusion.api.action.SelectInvalidAction","title":"<code>SelectInvalidAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid nodes in Fusion when plug-in failed.</p> <p>To retrieve the invalid nodes this assumes a static <code>get_invalid()</code> method is available on the plugin.</p> Source code in <code>client/ayon_fusion/api/action.py</code> <pre><code>class SelectInvalidAction(pyblish.api.Action):\n    \"\"\"Select invalid nodes in Fusion when plug-in failed.\n\n    To retrieve the invalid nodes this assumes a static `get_invalid()`\n    method is available on the plugin.\n\n    \"\"\"\n\n    label = \"Select invalid\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"search\"  # Icon from Awesome Icon\n\n    def process(self, context, plugin):\n        errored_instances = get_errored_instances_from_context(\n            context,\n            plugin=plugin,\n        )\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes..\")\n        invalid = list()\n        for instance in errored_instances:\n            invalid_nodes = plugin.get_invalid(instance)\n            if invalid_nodes:\n                if isinstance(invalid_nodes, (list, tuple)):\n                    invalid.extend(invalid_nodes)\n                else:\n                    self.log.warning(\n                        \"Plug-in returned to be invalid, \"\n                        \"but has no selectable nodes.\"\n                    )\n\n        if not invalid:\n            # Assume relevant comp is current comp and clear selection\n            self.log.info(\"No invalid tools found.\")\n            comp = get_current_comp()\n            flow = comp.CurrentFrame.FlowView\n            flow.Select()  # No args equals clearing selection\n            return\n\n        # Assume a single comp\n        first_tool = invalid[0]\n        comp = first_tool.Comp()\n        flow = comp.CurrentFrame.FlowView\n        flow.Select()  # No args equals clearing selection\n        names = set()\n        for tool in invalid:\n            flow.Select(tool, True)\n            comp.SetActiveTool(tool)\n            names.add(tool.Name)\n        self.log.info(\n            \"Selecting invalid tools: %s\" % \", \".join(sorted(names))\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/action.html#client.ayon_fusion.api.action.SelectToolAction","title":"<code>SelectToolAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid output tool in Fusion when plug-in failed.</p> Source code in <code>client/ayon_fusion/api/action.py</code> <pre><code>class SelectToolAction(pyblish.api.Action):\n    \"\"\"Select invalid output tool in Fusion when plug-in failed.\n\n    \"\"\"\n\n    label = \"Select saver\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"search\"  # Icon from Awesome Icon\n\n    def process(self, context, plugin):\n        errored_instances = get_errored_instances_from_context(\n            context,\n            plugin=plugin,\n        )\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes..\")\n        tools = []\n        for instance in errored_instances:\n\n            tool = instance.data.get(\"tool\")\n            if tool is not None:\n                tools.append(tool)\n            else:\n                self.log.warning(\n                    \"Plug-in returned to be invalid, \"\n                    f\"but has no saver for instance {instance.name}.\"\n                )\n\n        if not tools:\n            # Assume relevant comp is current comp and clear selection\n            self.log.info(\"No invalid tools found.\")\n            comp = get_current_comp()\n            flow = comp.CurrentFrame.FlowView\n            flow.Select()  # No args equals clearing selection\n            return\n\n        # Assume a single comp\n        first_tool = tools[0]\n        comp = first_tool.Comp()\n        flow = comp.CurrentFrame.FlowView\n        flow.Select()  # No args equals clearing selection\n        names = set()\n        for tool in tools:\n            flow.Select(tool, True)\n            comp.SetActiveTool(tool)\n            names.add(tool.Name)\n        self.log.info(\n            \"Selecting invalid tools: %s\" % \", \".join(sorted(names))\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.comp_lock_and_undo_chunk","title":"<code>comp_lock_and_undo_chunk(comp, undo_queue_name='Script CMD', keep_undo=True)</code>","text":"<p>Lock comp and open an undo chunk during the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef comp_lock_and_undo_chunk(\n    comp,\n    undo_queue_name=\"Script CMD\",\n    keep_undo=True,\n):\n    \"\"\"Lock comp and open an undo chunk during the context\"\"\"\n    try:\n        comp.Lock()\n        comp.StartUndo(undo_queue_name)\n        yield\n    finally:\n        comp.Unlock()\n        comp.EndUndo(keep_undo)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_bmd_library","title":"<code>get_bmd_library()</code>","text":"<p>Get bmd library</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_bmd_library():\n    \"\"\"Get bmd library\"\"\"\n    bmd = getattr(sys.modules[\"__main__\"], \"bmd\", None)\n    return bmd\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_current_comp","title":"<code>get_current_comp()</code>","text":"<p>Get current comp in this session</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_current_comp():\n    \"\"\"Get current comp in this session\"\"\"\n    fusion = get_fusion_module()\n    if fusion is not None:\n        comp = fusion.CurrentComp\n        return comp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_frame_path","title":"<code>get_frame_path(path)</code>","text":"<p>Get filename for the Fusion Saver with padded number as '#'</p> <p>get_frame_path(\"C:/test.exr\") ('C:/test', 4, '.exr')</p> <p>get_frame_path(\"filename.00.tif\") ('filename.', 2, '.tif')</p> <p>get_frame_path(\"foobar35.tif\") ('foobar', 2, '.tif')</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to render to.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>head, padding, tail (extension)</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_frame_path(path):\n    \"\"\"Get filename for the Fusion Saver with padded number as '#'\n\n    &gt;&gt;&gt; get_frame_path(\"C:/test.exr\")\n    ('C:/test', 4, '.exr')\n\n    &gt;&gt;&gt; get_frame_path(\"filename.00.tif\")\n    ('filename.', 2, '.tif')\n\n    &gt;&gt;&gt; get_frame_path(\"foobar35.tif\")\n    ('foobar', 2, '.tif')\n\n    Args:\n        path (str): The path to render to.\n\n    Returns:\n        tuple: head, padding, tail (extension)\n\n    \"\"\"\n    filename, ext = os.path.splitext(path)\n\n    # Find a final number group\n    match = re.match('.*?([0-9]+)$', filename)\n    if match:\n        padding = len(match.group(1))\n        # remove number from end since fusion\n        # will swap it with the frame number\n        filename = filename[:-padding]\n    else:\n        padding = 4  # default Fusion padding\n\n    return filename, padding, ext\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_fusion_module","title":"<code>get_fusion_module()</code>","text":"<p>Get current Fusion instance</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_fusion_module():\n    \"\"\"Get current Fusion instance\"\"\"\n    fusion = getattr(sys.modules[\"__main__\"], \"fusion\", None)\n    return fusion\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_tool_resolution","title":"<code>get_tool_resolution(tool, frame)</code>","text":"<p>Return the 2D input resolution to a Fusion tool</p> <p>If the current tool hasn't been rendered its input resolution hasn't been saved. To combat this, add an expression in the comments field to read the resolution</p> <p>Args     tool (Fusion Tool): The tool to query input resolution     frame (int): The frame to query the resolution on.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>width, height as 2-tuple of integers</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unable to retrieve comp resolution.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_tool_resolution(tool, frame):\n    \"\"\"Return the 2D input resolution to a Fusion tool\n\n    If the current tool hasn't been rendered its input resolution\n    hasn't been saved. To combat this, add an expression in\n    the comments field to read the resolution\n\n    Args\n        tool (Fusion Tool): The tool to query input resolution\n        frame (int): The frame to query the resolution on.\n\n    Returns:\n        tuple: width, height as 2-tuple of integers\n\n    Raises:\n        ValueError: Unable to retrieve comp resolution.\n\n    \"\"\"\n    comp = tool.Composition\n    attribute = tool[\"Comments\"]\n\n    # False undo removes the undo-stack from the undo list\n    with comp_lock_and_undo_chunk(comp, \"Read resolution\", False):\n\n        # Get width\n        with temp_expression(attribute, frame, \"self.Input.OriginalWidth\"):\n            value = attribute[frame]\n            if value is None:\n                raise ValueError(\"Failed to read input width\")\n            width = int(value)\n\n        # Get height\n        with temp_expression(attribute, frame, \"self.Input.OriginalHeight\"):\n            value = attribute[frame]\n            if value is None:\n                raise ValueError(\"Failed to read input height\")\n            height = int(value)\n\n        return width, height\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.maintained_comp_range","title":"<code>maintained_comp_range(comp=None, global_start=True, global_end=True, render_start=True, render_end=True)</code>","text":"<p>Reset comp frame ranges from before the context after the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_comp_range(comp=None,\n                          global_start=True,\n                          global_end=True,\n                          render_start=True,\n                          render_end=True):\n    \"\"\"Reset comp frame ranges from before the context after the context\"\"\"\n    if comp is None:\n        comp = get_current_comp()\n\n    comp_attrs = comp.GetAttrs()\n    preserve_attrs = {}\n    if global_start:\n        preserve_attrs[\"COMPN_GlobalStart\"] = comp_attrs[\"COMPN_GlobalStart\"]\n    if global_end:\n        preserve_attrs[\"COMPN_GlobalEnd\"] = comp_attrs[\"COMPN_GlobalEnd\"]\n    if render_start:\n        preserve_attrs[\"COMPN_RenderStart\"] = comp_attrs[\"COMPN_RenderStart\"]\n    if render_end:\n        preserve_attrs[\"COMPN_RenderEnd\"] = comp_attrs[\"COMPN_RenderEnd\"]\n\n    try:\n        yield\n    finally:\n        comp.SetAttrs(preserve_attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.maintained_selection","title":"<code>maintained_selection(comp=None)</code>","text":"<p>Reset comp selection from before the context after the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection(comp=None):\n    \"\"\"Reset comp selection from before the context after the context\"\"\"\n    if comp is None:\n        comp = get_current_comp()\n\n    previous_selection = comp.GetToolList(True).values()\n    try:\n        yield\n    finally:\n        flow = comp.CurrentFrame.FlowView\n        flow.Select()  # No args equals clearing selection\n        if previous_selection:\n            for tool in previous_selection:\n                flow.Select(tool, True)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.prompt_reset_context","title":"<code>prompt_reset_context()</code>","text":"<p>Prompt the user what context settings to reset. This prompt is used on saving to a different task to allow the scene to get matched to the new context.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def prompt_reset_context():\n    \"\"\"Prompt the user what context settings to reset.\n    This prompt is used on saving to a different task to allow the scene to\n    get matched to the new context.\n    \"\"\"\n    # TODO: Cleanup this prototyped mess of imports and odd dialog\n    from ayon_core.tools.attribute_defs.dialog import (\n        AttributeDefinitionsDialog\n    )\n    from qtpy import QtCore\n\n    definitions = [\n        UILabelDef(\n            label=(\n                \"You are saving your workfile into a different folder or task.\"\n                \"\\n\\n\"\n                \"Would you like to update some settings to the new context?\\n\"\n            )\n        ),\n        BoolDef(\n            \"fps\", \n            label=\"FPS\", \n            tooltip=\"Reset Comp FPS\",\n            default=True\n        ),\n        BoolDef(\n            \"frame_range\", \n            label=\"Frame Range\",\n            tooltip=\"Reset Comp start and end frame ranges\",\n            default=True\n        ),\n        BoolDef(\n            \"resolution\", \n            label=\"Comp Resolution\", \n            tooltip=\"Reset Comp resolution\",\n            default=True\n        ),\n        BoolDef(\n            \"instances\", \n            label=\"Publish instances\", \n            tooltip=\"Update all publish instance's folder and task to match \"\n                    \"the new folder and task\", \n            default=True\n        ),\n    ]\n\n    dialog = AttributeDefinitionsDialog(definitions)\n    dialog.setWindowFlags(\n        dialog.windowFlags() | QtCore.Qt.WindowStaysOnTopHint\n    )\n    dialog.setWindowTitle(\"Saving to different context.\")\n    dialog.setStyleSheet(load_stylesheet())\n    if not dialog.exec_():\n        return None\n\n    options = dialog.get_values()\n    task_entity = get_current_task_entity()\n    if options[\"frame_range\"]:\n        set_current_context_framerange(task_entity)\n\n    if options[\"fps\"]:\n        set_current_context_fps(task_entity)\n\n    if options[\"resolution\"]:\n        set_current_context_resolution(task_entity)\n\n    if options[\"instances\"]:\n        update_content_on_context_change()\n\n    dialog.deleteLater()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.set_current_context_fps","title":"<code>set_current_context_fps(task_entity=None)</code>","text":"<p>Set Comp's frame rate (FPS) to based on current task</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def set_current_context_fps(task_entity=None):\n    \"\"\"Set Comp's frame rate (FPS) to based on current task\"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(fields={\"attrib.fps\"})\n\n    fps = float(task_entity[\"attrib\"].get(\"fps\", 24.0))\n    comp = get_current_comp()\n    comp.SetPrefs({\n        \"Comp.FrameFormat.Rate\": fps,\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.set_current_context_framerange","title":"<code>set_current_context_framerange(task_entity=None)</code>","text":"<p>Set Comp's frame range based on current task.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def set_current_context_framerange(task_entity=None):\n    \"\"\"Set Comp's frame range based on current task.\"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(\n            fields={\"attrib.frameStart\",\n                    \"attrib.frameEnd\",\n                    \"attrib.handleStart\",\n                    \"attrib.handleEnd\"})\n\n    task_attributes = task_entity[\"attrib\"]\n    start = task_attributes[\"frameStart\"]\n    end = task_attributes[\"frameEnd\"]\n    handle_start = task_attributes[\"handleStart\"]\n    handle_end = task_attributes[\"handleEnd\"]\n    update_frame_range(start, end, set_render_range=True,\n                       handle_start=handle_start,\n                       handle_end=handle_end)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.set_current_context_resolution","title":"<code>set_current_context_resolution(task_entity=None)</code>","text":"<p>Set Comp's resolution width x height default based on current task</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def set_current_context_resolution(task_entity=None):\n    \"\"\"Set Comp's resolution width x height default based on current task\"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(\n            fields={\"attrib.resolutionWidth\", \"attrib.resolutionHeight\"})\n\n    task_attributes = task_entity[\"attrib\"]\n    width = task_attributes[\"resolutionWidth\"]\n    height = task_attributes[\"resolutionHeight\"]\n    comp = get_current_comp()\n\n    print(\"Setting comp frame format resolution to {}x{}\".format(width,\n                                                                 height))\n    comp.SetPrefs({\n        \"Comp.FrameFormat.Width\": width,\n        \"Comp.FrameFormat.Height\": height,\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.temp_expression","title":"<code>temp_expression(attribute, frame, expression)</code>","text":"<p>Temporarily set an expression on an attribute during context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef temp_expression(attribute, frame, expression):\n    \"\"\"Temporarily set an expression on an attribute during context\"\"\"\n    # Save old comment\n    old_comment = \"\"\n    has_expression = False\n\n    if attribute[frame] not in [\"\", None]:\n        if attribute.GetExpression() is not None:\n            has_expression = True\n            old_comment = attribute.GetExpression()\n            attribute.SetExpression(None)\n        else:\n            old_comment = attribute[frame]\n            attribute[frame] = \"\"\n\n    try:\n        attribute.SetExpression(expression)\n        yield\n    finally:\n        # Reset old comment\n        attribute.SetExpression(None)\n        if has_expression:\n            attribute.SetExpression(old_comment)\n        else:\n            attribute[frame] = old_comment\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.update_content_on_context_change","title":"<code>update_content_on_context_change()</code>","text":"<p>Update all Creator instances to current asset</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def update_content_on_context_change():\n    \"\"\"Update all Creator instances to current asset\"\"\"\n    host = registered_host()\n    context = host.get_current_context()\n\n    folder_path = context[\"folder_path\"]\n    task = context[\"task_name\"]\n\n    create_context = CreateContext(host, reset=True)\n\n    for instance in create_context.instances:\n        instance_folder_path = instance.get(\"folderPath\")\n        if instance_folder_path and instance_folder_path != folder_path:\n            instance[\"folderPath\"] = folder_path\n        instance_task = instance.get(\"task\")\n        if instance_task and instance_task != task:\n            instance[\"task\"] = task\n\n    create_context.save_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.update_frame_range","title":"<code>update_frame_range(start, end, comp=None, set_render_range=True, handle_start=0, handle_end=0)</code>","text":"<p>Set Fusion comp's start and end frame range</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(float, int)</code> <p>start frame</p> required <code>end</code> <code>(float, int)</code> <p>end frame</p> required <code>comp</code> <code>(object, Optional)</code> <p>comp object from fusion</p> <code>None</code> <code>set_render_range</code> <code>(bool, Optional)</code> <p>When True this will also set the composition's render start and end frame.</p> <code>True</code> <code>handle_start</code> <code>(float, int, Optional)</code> <p>frame handles before start frame</p> <code>0</code> <code>handle_end</code> <code>(float, int, Optional)</code> <p>frame handles after end frame</p> <code>0</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def update_frame_range(start, end, comp=None, set_render_range=True,\n                       handle_start=0, handle_end=0):\n    \"\"\"Set Fusion comp's start and end frame range\n\n    Args:\n        start (float, int): start frame\n        end (float, int): end frame\n        comp (object, Optional): comp object from fusion\n        set_render_range (bool, Optional): When True this will also set the\n            composition's render start and end frame.\n        handle_start (float, int, Optional): frame handles before start frame\n        handle_end (float, int, Optional): frame handles after end frame\n\n    Returns:\n        None\n\n    \"\"\"\n\n    if not comp:\n        comp = get_current_comp()\n\n    # Convert any potential none type to zero\n    handle_start = handle_start or 0\n    handle_end = handle_end or 0\n\n    attrs = {\n        \"COMPN_GlobalStart\": start - handle_start,\n        \"COMPN_GlobalEnd\": end + handle_end\n    }\n\n    # set frame range\n    if set_render_range:\n        attrs.update({\n            \"COMPN_RenderStart\": start,\n            \"COMPN_RenderEnd\": end\n        })\n\n    with comp_lock_and_undo_chunk(comp):\n        comp.SetAttrs(attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.validate_comp_prefs","title":"<code>validate_comp_prefs(comp=None, force_repair=False)</code>","text":"<p>Validate current comp defaults with task settings.</p> <p>Validates fps, resolutionWidth, resolutionHeight, aspectRatio.</p> <p>This does not validate frameStart, frameEnd, handleStart and handleEnd.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def validate_comp_prefs(comp=None, force_repair=False):\n    \"\"\"Validate current comp defaults with task settings.\n\n    Validates fps, resolutionWidth, resolutionHeight, aspectRatio.\n\n    This does *not* validate frameStart, frameEnd, handleStart and handleEnd.\n    \"\"\"\n\n    if comp is None:\n        comp = get_current_comp()\n\n    log = Logger.get_logger(\"validate_comp_prefs\")\n\n    fields = {\n        \"name\",\n        \"attrib.fps\",\n        \"attrib.resolutionWidth\",\n        \"attrib.resolutionHeight\",\n        \"attrib.pixelAspect\",\n    }\n    task_entity = get_current_task_entity(fields=fields)\n    folder_path = get_current_folder_path()\n    context_path = \"{} &gt; {}\".format(folder_path, task_entity[\"name\"])\n\n    task_attributes = task_entity[\"attrib\"]\n\n    comp_frame_format_prefs = comp.GetPrefs(\"Comp.FrameFormat\")\n\n    # Pixel aspect ratio in Fusion is set as AspectX and AspectY so we convert\n    # the data to something that is more sensible to Fusion\n    task_attributes[\"pixelAspectX\"] = task_attributes.pop(\"pixelAspect\")\n    task_attributes[\"pixelAspectY\"] = 1.0\n\n    validations = [\n        (\"fps\", \"Rate\", \"FPS\"),\n        (\"resolutionWidth\", \"Width\", \"Resolution Width\"),\n        (\"resolutionHeight\", \"Height\", \"Resolution Height\"),\n        (\"pixelAspectX\", \"AspectX\", \"Pixel Aspect Ratio X\"),\n        (\"pixelAspectY\", \"AspectY\", \"Pixel Aspect Ratio Y\")\n    ]\n\n    invalid = []\n    for key, comp_key, label in validations:\n        task_value = task_attributes[key]\n        comp_value = comp_frame_format_prefs.get(comp_key)\n        if task_value != comp_value:\n            invalid_msg = \"{} {} should be {}\".format(label,\n                                                      comp_value,\n                                                      task_value)\n            invalid.append(invalid_msg)\n\n            if not force_repair:\n                # Do not log warning if we force repair anyway\n                log.warning(\n                    \"Comp {pref} {value} does not match \"\n                    \"{context_path} {pref} {task_value}\".format(\n                        pref=label,\n                        value=comp_value,\n                        context_path=context_path,\n                        task_value=task_value)\n                )\n\n    if invalid:\n\n        def _on_repair():\n            attributes = dict()\n            for key, comp_key, _label in validations:\n                value = task_attributes[key]\n                comp_key_full = \"Comp.FrameFormat.{}\".format(comp_key)\n                attributes[comp_key_full] = value\n            comp.SetPrefs(attributes)\n\n        if force_repair:\n            log.info(\"Applying default Comp preferences..\")\n            _on_repair()\n            return\n\n        from . import menu\n        from ayon_core.tools.utils import SimplePopup\n        dialog = SimplePopup(parent=menu.menu)\n        dialog.setWindowTitle(\"Fusion comp has invalid configuration\")\n\n        msg = \"Comp preferences mismatches '{}'\".format(context_path)\n        msg += \"\\n\" + \"\\n\".join(invalid)\n        dialog.set_message(msg)\n        dialog.set_button_text(\"Repair\")\n        dialog.on_clicked.connect(_on_repair)\n        dialog.show()\n        dialog.raise_()\n        dialog.activateWindow()\n        dialog.setStyleSheet(load_stylesheet())\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/menu.html","title":"menu","text":""},{"location":"autoapi/client/ayon_fusion/api/pipeline.html","title":"pipeline","text":"<p>Basic avalon integration</p>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.FusionEventHandler","title":"<code>FusionEventHandler</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Emits AYON events based on Fusion events captured in a QThread.</p> This will emit the following AYON events based on Fusion actions <p>save: Comp_Save, Comp_SaveAs open: Comp_Opened new: Comp_New</p> <p>To use this you can attach it to you Qt UI so it runs in the background. E.g.     &gt;&gt;&gt; handler = FusionEventHandler(parent=window)     &gt;&gt;&gt; handler.start()</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>class FusionEventHandler(QtCore.QObject):\n    \"\"\"Emits AYON events based on Fusion events captured in a QThread.\n\n    This will emit the following AYON events based on Fusion actions:\n        save: Comp_Save, Comp_SaveAs\n        open: Comp_Opened\n        new: Comp_New\n\n    To use this you can attach it to you Qt UI so it runs in the background.\n    E.g.\n        &gt;&gt;&gt; handler = FusionEventHandler(parent=window)\n        &gt;&gt;&gt; handler.start()\n\n    \"\"\"\n    ACTION_IDS = [\n        \"Comp_Save\",\n        \"Comp_SaveAs\",\n        \"Comp_New\",\n        \"Comp_Opened\"\n    ]\n\n    def __init__(self, parent=None):\n        super(FusionEventHandler, self).__init__(parent=parent)\n\n        # Set up Fusion event callbacks\n        fusion = getattr(sys.modules[\"__main__\"], \"fusion\", None)\n        ui = fusion.UIManager\n\n        # Add notifications for the ones we want to listen to\n        notifiers = []\n        for action_id in self.ACTION_IDS:\n            notifier = ui.AddNotify(action_id, None)\n            notifiers.append(notifier)\n\n        # TODO: Not entirely sure whether these must be kept to avoid\n        #       garbage collection\n        self._notifiers = notifiers\n\n        self._event_thread = FusionEventThread(parent=self)\n        self._event_thread.on_event.connect(self._on_event)\n\n    def start(self):\n        self._event_thread.start()\n\n    def stop(self):\n        self._event_thread.stop()\n\n    def _on_event(self, event):\n        \"\"\"Handle Fusion events to emit AYON events\"\"\"\n        if not event:\n            return\n\n        what = event[\"what\"]\n\n        # Comp Save\n        if what in {\"Comp_Save\", \"Comp_SaveAs\"}:\n            if not event[\"Rets\"].get(\"success\"):\n                # If the Save action is cancelled it will still emit an\n                # event but with \"success\": False so we ignore those cases\n                return\n            # Comp was saved\n            emit_event(\"save\", data=event)\n            return\n\n        # Comp New\n        elif what in {\"Comp_New\"}:\n            emit_event(\"new\", data=event)\n\n        # Comp Opened\n        elif what in {\"Comp_Opened\"}:\n            emit_event(\"open\", data=event)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.FusionEventThread","title":"<code>FusionEventThread</code>","text":"<p>               Bases: <code>QThread</code></p> <p>QThread which will periodically ping Fusion app for any events. The fusion.UIManager must be set up to be notified of events before they'll be reported by this thread, for example:     fusion.UIManager.AddNotify(\"Comp_Save\", None)</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>class FusionEventThread(QtCore.QThread):\n    \"\"\"QThread which will periodically ping Fusion app for any events.\n    The fusion.UIManager must be set up to be notified of events before they'll\n    be reported by this thread, for example:\n        fusion.UIManager.AddNotify(\"Comp_Save\", None)\n\n    \"\"\"\n\n    on_event = QtCore.Signal(dict)\n\n    def run(self):\n\n        app = getattr(sys.modules[\"__main__\"], \"app\", None)\n        if app is None:\n            # No Fusion app found\n            return\n\n        # As optimization store the GetEvent method directly because every\n        # getattr of UIManager.GetEvent tries to resolve the Remote Function\n        # through the PyRemoteObject\n        get_event = app.UIManager.GetEvent\n        delay = int(os.environ.get(\"AYON_FUSION_CALLBACK_INTERVAL\", 1000))\n        while True:\n            if self.isInterruptionRequested():\n                return\n\n            # Process all events that have been queued up until now\n            while True:\n                event = get_event(False)\n                if not event:\n                    break\n                self.on_event.emit(event)\n\n            # Wait some time before processing events again\n            # to not keep blocking the UI\n            self.msleep(delay)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.FusionHost","title":"<code>FusionHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>class FusionHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"fusion\"\n\n    def install(self):\n        \"\"\"Install fusion-specific functionality of AYON.\n\n        This is where you install menus and register families, data\n        and loaders into fusion.\n\n        It is called automatically when installing via\n        `ayon_core.pipeline.install_host(ayon_fusion.api)`\n\n        See the Maya equivalent for inspiration on how to implement this.\n\n        \"\"\"\n        # Remove all handlers associated with the root logger object, because\n        # that one always logs as \"warnings\" incorrectly.\n        for handler in logging.root.handlers[:]:\n            logging.root.removeHandler(handler)\n\n        # Attach default logging handler that prints to active comp\n        logger = logging.getLogger()\n        formatter = logging.Formatter(fmt=\"%(message)s\\n\")\n        handler = FusionLogHandler()\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        logger.setLevel(logging.DEBUG)\n\n        pyblish.api.register_host(\"fusion\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        log.info(\"Registering Fusion plug-ins..\")\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n\n        # Register events\n        register_event_callback(\"open\", on_after_open)\n        register_event_callback(\"workfile.save.before\", before_workfile_save)\n        register_event_callback(\"save\", on_save)\n        register_event_callback(\"new\", on_new)\n        register_event_callback(\"taskChanged\", on_task_changed)\n\n    # region workfile io api\n    def has_unsaved_changes(self):\n        comp = get_current_comp()\n        return comp.GetAttrs()[\"COMPB_Modified\"]\n\n    def get_workfile_extensions(self):\n        return [\".comp\"]\n\n    def save_workfile(self, dst_path=None):\n        comp = get_current_comp()\n        comp.Save(dst_path)\n\n    def open_workfile(self, filepath):\n        # Hack to get fusion, see\n        #   ayon_fusion.api.pipeline.get_current_comp()\n        fusion = getattr(sys.modules[\"__main__\"], \"fusion\", None)\n\n        return fusion.LoadComp(filepath)\n\n    def get_current_workfile(self):\n        comp = get_current_comp()\n        current_filepath = comp.GetAttrs()[\"COMPS_FileName\"]\n        if not current_filepath:\n            return None\n\n        return current_filepath\n\n    def work_root(self, session):\n        work_dir = session[\"AYON_WORKDIR\"]\n        scene_dir = session.get(\"AVALON_SCENEDIR\")\n        if scene_dir:\n            return os.path.join(work_dir, scene_dir)\n        else:\n            return work_dir\n    # endregion\n\n    @contextlib.contextmanager\n    def maintained_selection(self):\n        from .lib import maintained_selection\n        return maintained_selection()\n\n    def get_containers(self):\n        return ls()\n\n    def update_context_data(self, data, changes):\n        comp = get_current_comp()\n        comp.SetData(\"openpype\", data)\n\n    def get_context_data(self):\n        comp = get_current_comp()\n        return comp.GetData(\"openpype\") or {}\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.FusionHost.install","title":"<code>install()</code>","text":"<p>Install fusion-specific functionality of AYON.</p> <p>This is where you install menus and register families, data and loaders into fusion.</p> <p>It is called automatically when installing via <code>ayon_core.pipeline.install_host(ayon_fusion.api)</code></p> <p>See the Maya equivalent for inspiration on how to implement this.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install fusion-specific functionality of AYON.\n\n    This is where you install menus and register families, data\n    and loaders into fusion.\n\n    It is called automatically when installing via\n    `ayon_core.pipeline.install_host(ayon_fusion.api)`\n\n    See the Maya equivalent for inspiration on how to implement this.\n\n    \"\"\"\n    # Remove all handlers associated with the root logger object, because\n    # that one always logs as \"warnings\" incorrectly.\n    for handler in logging.root.handlers[:]:\n        logging.root.removeHandler(handler)\n\n    # Attach default logging handler that prints to active comp\n    logger = logging.getLogger()\n    formatter = logging.Formatter(fmt=\"%(message)s\\n\")\n    handler = FusionLogHandler()\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    logger.setLevel(logging.DEBUG)\n\n    pyblish.api.register_host(\"fusion\")\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    log.info(\"Registering Fusion plug-ins..\")\n\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n    register_inventory_action_path(INVENTORY_PATH)\n\n    # Register events\n    register_event_callback(\"open\", on_after_open)\n    register_event_callback(\"workfile.save.before\", before_workfile_save)\n    register_event_callback(\"save\", on_save)\n    register_event_callback(\"new\", on_new)\n    register_event_callback(\"taskChanged\", on_task_changed)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.imprint_container","title":"<code>imprint_container(tool, name, namespace, context, loader=None)</code>","text":"<p>Imprint a Loader with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>object</code> <p>The node in Fusion to imprint as container, usually a Loader.</p> required <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def imprint_container(tool,\n                      name,\n                      namespace,\n                      context,\n                      loader=None):\n    \"\"\"Imprint a Loader with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        tool (object): The node in Fusion to imprint as container, usually a\n            Loader.\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    data = [\n        (\"schema\", \"openpype:container-2.0\"),\n        (\"id\", AVALON_CONTAINER_ID),\n        (\"name\", str(name)),\n        (\"namespace\", str(namespace)),\n        (\"loader\", str(loader)),\n        (\"representation\", context[\"representation\"][\"id\"]),\n        (\"project_name\", context[\"project\"][\"name\"]),\n    ]\n\n    for key, value in data:\n        tool.SetData(\"avalon.{}\".format(key), value)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>List containers from active Fusion scene</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Fusion; once loaded they are called 'containers'</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List containers from active Fusion scene\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in Fusion; once loaded\n    they are called 'containers'\n\n    Yields:\n        dict: container\n\n    \"\"\"\n\n    comp = get_current_comp()\n    tools = comp.GetToolList(False).values()\n\n    for tool in tools:\n        container = parse_container(tool)\n        if container:\n            yield container\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.parse_container","title":"<code>parse_container(tool)</code>","text":"<p>Returns imprinted container data of a tool</p> <p>This reads the imprinted data from <code>imprint_container</code>.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def parse_container(tool):\n    \"\"\"Returns imprinted container data of a tool\n\n    This reads the imprinted data from `imprint_container`.\n\n    \"\"\"\n\n    data = tool.GetData('avalon')\n    if not isinstance(data, dict):\n        return\n\n    # If not all required data return the empty container\n    required = ['schema', 'id', 'name',\n                'namespace', 'loader', 'representation']\n    if not all(key in data for key in required):\n        return\n\n    container = {key: data[key] for key in required}\n\n    # Add optional keys, like `project_name`\n    optional = [\"project_name\"]\n    for key in optional:\n        if key in data:\n            container[key] = data[key]\n\n    # Store the tool's name\n    container[\"objectName\"] = tool.Name\n\n    # Store reference to the tool object\n    container[\"_tool\"] = tool\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_fusion/api/plugin.html#client.ayon_fusion.api.plugin.GenericCreateSaver","title":"<code>GenericCreateSaver</code>","text":"<p>               Bases: <code>Creator</code></p> Source code in <code>client/ayon_fusion/api/plugin.py</code> <pre><code>class GenericCreateSaver(Creator):\n    default_variants = [\"Main\", \"Mask\"]\n    description = \"Fusion Saver to generate image sequence\"\n    icon = \"fa5.eye\"\n\n    instance_attributes = [\n        \"reviewable\"\n    ]\n\n    settings_category = \"fusion\"\n\n    image_format = \"exr\"\n\n    # TODO: This should be renamed together with Nuke so it is aligned\n    temp_rendering_path_template = (\n        \"{workdir}/renders/fusion/{product[name]}/\"\n        \"{product[name]}.{frame}.{ext}\"\n    )\n\n    def create(self, product_name, instance_data, pre_create_data):\n        self.pass_pre_attributes_to_instance(instance_data, pre_create_data)\n\n        instance = CreatedInstance(\n            product_type=self.product_type,\n            product_name=product_name,\n            data=instance_data,\n            creator=self,\n        )\n        data = instance.data_to_store()\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp):\n            args = (-32768, -32768)  # Magical position numbers\n            saver = comp.AddTool(\"Saver\", *args)\n\n            self._update_tool_with_data(saver, data=data)\n\n        # Register the CreatedInstance\n        self._imprint(saver, data)\n\n        # Insert the transient data\n        instance.transient_data[\"tool\"] = saver\n\n        self._add_instance_to_context(instance)\n\n        return instance\n\n    def collect_instances(self):\n        comp = get_current_comp()\n        tools = comp.GetToolList(False, \"Saver\").values()\n        for tool in tools:\n            data = self.get_managed_tool_data(tool)\n            if not data:\n                continue\n\n            # Add instance\n            created_instance = CreatedInstance.from_existing(data, self)\n\n            # Collect transient data\n            created_instance.transient_data[\"tool\"] = tool\n\n            self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n            new_data = created_inst.data_to_store()\n            tool = created_inst.transient_data[\"tool\"]\n            self._update_tool_with_data(tool, new_data)\n            self._imprint(tool, new_data)\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            # Remove the tool from the scene\n\n            tool = instance.transient_data[\"tool\"]\n            if tool:\n                tool.Delete()\n\n            # Remove the collected CreatedInstance to remove from UI directly\n            self._remove_instance_from_context(instance)\n\n    def _imprint(self, tool, data):\n        # Save all data in a \"openpype.{key}\" = value data\n\n        # Instance id is the tool's name so we don't need to imprint as data\n        data.pop(\"instance_id\", None)\n\n        active = data.pop(\"active\", None)\n        if active is not None:\n            # Use active value to set the passthrough state\n            tool.SetAttrs({\"TOOLB_PassThrough\": not active})\n\n        for key, value in data.items():\n            tool.SetData(f\"openpype.{key}\", value)\n\n    def _update_tool_with_data(self, tool, data):\n        \"\"\"Update tool node name and output path based on product data\"\"\"\n        if \"productName\" not in data:\n            return\n\n        original_product_name = tool.GetData(\"openpype.productName\")\n        original_format = tool.GetData(\n            \"openpype.creator_attributes.image_format\"\n        )\n\n        product_name = data[\"productName\"]\n        if (\n            original_product_name != product_name\n            or tool.GetData(\"openpype.task\") != data[\"task\"]\n            or tool.GetData(\"openpype.folderPath\") != data[\"folderPath\"]\n            or original_format != data[\"creator_attributes\"][\"image_format\"]\n        ):\n            self._configure_saver_tool(data, tool, product_name)\n\n    def _configure_saver_tool(self, data, tool, product_name):\n        formatting_data = deepcopy(data)\n\n        # get frame padding from anatomy templates\n        frame_padding = self.project_anatomy.templates_obj.frame_padding\n\n        # get output format\n        ext = data[\"creator_attributes\"][\"image_format\"]\n\n        # Product name and type\n        product_type = formatting_data[\"productType\"]\n        f_product_name = formatting_data[\"productName\"]\n\n        # Get instance context entities\n        project_entity = self.create_context.get_current_project_entity()\n        folder_path: str = data[\"folderPath\"]\n        task_name: str = data[\"task\"]\n        folder_entity = None\n        task_entity = None\n        if folder_path:\n            folder_entity = self.create_context.get_folder_entity(folder_path)\n            if task_name:\n                task_entity = self.create_context.get_task_entity(\n                    folder_path, task_name)\n\n        # If the folder path and task do not match the current context then the\n        # workdir is not just the `AYON_WORKDIR`. Hence, we need to actually\n        # compute the resulting workdir\n        if (\n            folder_path == self.create_context.get_current_folder_path()\n            and task_name == self.create_context.get_current_task_name()\n        ):\n            workdir = os.path.normpath(os.getenv(\"AYON_WORKDIR\"))\n        else:\n            # Note: This may error when no task is set for the instance\n            #  however default render template would include task name anyway\n            #  disallowing the instance to have no task set at an earlier stage\n            #  already.\n            workdir = get_workdir(\n                project_entity=project_entity,\n                folder_entity=folder_entity,\n                task_entity=task_entity,\n                host_name=self.create_context.host_name,\n            )\n\n        formatting_data.update({\n            \"workdir\": workdir,\n            \"frame\": \"0\" * frame_padding,\n            \"ext\": ext,\n            \"product\": {\n                \"name\": f_product_name,\n                \"type\": product_type,\n            },\n            # Backwards compatibility\n            \"subset\": f_product_name,\n            \"family\": product_type,\n        })\n\n        # build file path to render\n        temp_rendering_path_template = (\n            self.temp_rendering_path_template\n            .replace(\"{task}\", \"{task[name]}\")\n        )\n\n        extra_data = get_template_data(\n            project_entity,\n            folder_entity,\n            task_entity,\n            host_name=self.create_context.host_name,\n            settings=self.create_context.get_current_project_settings(),\n        )\n        anatomy = self.create_context.project_anatomy\n        extra_data[\"root\"] = anatomy.roots\n        formatting_data.update(extra_data)\n\n        filepath = temp_rendering_path_template.format(**formatting_data)\n\n        comp = get_current_comp()\n        tool[\"Clip\"] = comp.ReverseMapPath(os.path.normpath(filepath))\n\n        # Rename tool\n        if tool.Name != product_name:\n            print(f\"Renaming {tool.Name} -&gt; {product_name}\")\n            tool.SetAttrs({\"TOOLS_Name\": product_name})\n\n    def get_managed_tool_data(self, tool):\n        \"\"\"Return data of the tool if it matches creator identifier\"\"\"\n        data = tool.GetData(\"openpype\")\n        if not isinstance(data, dict):\n            return\n\n        if (\n            data.get(\"creator_identifier\") != self.identifier\n            or data.get(\"id\") not in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }\n        ):\n            return\n\n        # Get active state from the actual tool state\n        attrs = tool.GetAttrs()\n        passthrough = attrs[\"TOOLB_PassThrough\"]\n        data[\"active\"] = not passthrough\n\n        # Override publisher's UUID generation because tool names are\n        # already unique in Fusion in a comp\n        data[\"instance_id\"] = tool.Name\n\n        return data\n\n    def get_instance_attr_defs(self):\n        \"\"\"Settings for publish page\"\"\"\n        return self.get_pre_create_attr_defs()\n\n    def pass_pre_attributes_to_instance(self, instance_data, pre_create_data):\n        creator_attrs = instance_data[\"creator_attributes\"] = {}\n        for pass_key in pre_create_data.keys():\n            creator_attrs[pass_key] = pre_create_data[pass_key]\n\n    def _get_render_target_enum(self):\n        rendering_targets = {\n            \"local\": \"Local machine rendering\",\n            \"frames\": \"Use existing frames\",\n        }\n        if \"farm_rendering\" in self.instance_attributes:\n            rendering_targets[\"farm\"] = \"Farm rendering\"\n\n        return EnumDef(\n            \"render_target\", items=rendering_targets, label=\"Render target\"\n        )\n\n    def _get_reviewable_bool(self):\n        return BoolDef(\n            \"review\",\n            default=(\"reviewable\" in self.instance_attributes),\n            label=\"Review\",\n        )\n\n    def _get_image_format_enum(self):\n        image_format_options = [\"exr\", \"tga\", \"tif\", \"png\", \"jpg\"]\n        return EnumDef(\n            \"image_format\",\n            items=image_format_options,\n            default=self.image_format,\n            label=\"Output Image Format\",\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/plugin.html#client.ayon_fusion.api.plugin.GenericCreateSaver.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>Settings for publish page</p> Source code in <code>client/ayon_fusion/api/plugin.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"Settings for publish page\"\"\"\n    return self.get_pre_create_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/plugin.html#client.ayon_fusion.api.plugin.GenericCreateSaver.get_managed_tool_data","title":"<code>get_managed_tool_data(tool)</code>","text":"<p>Return data of the tool if it matches creator identifier</p> Source code in <code>client/ayon_fusion/api/plugin.py</code> <pre><code>def get_managed_tool_data(self, tool):\n    \"\"\"Return data of the tool if it matches creator identifier\"\"\"\n    data = tool.GetData(\"openpype\")\n    if not isinstance(data, dict):\n        return\n\n    if (\n        data.get(\"creator_identifier\") != self.identifier\n        or data.get(\"id\") not in {\n            AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n        }\n    ):\n        return\n\n    # Get active state from the actual tool state\n    attrs = tool.GetAttrs()\n    passthrough = attrs[\"TOOLB_PassThrough\"]\n    data[\"active\"] = not passthrough\n\n    # Override publisher's UUID generation because tool names are\n    # already unique in Fusion in a comp\n    data[\"instance_id\"] = tool.Name\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pulse.html","title":"pulse","text":""},{"location":"autoapi/client/ayon_fusion/api/pulse.html#client.ayon_fusion.api.pulse.FusionPulse","title":"<code>FusionPulse</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A Timer that checks whether host app is still alive.</p> <p>This checks whether the Fusion process is still active at a certain interval. This is useful due to how Fusion runs its scripts. Each script runs in its own environment and process (a <code>fusionscript</code> process each). If Fusion would go down and we have a UI process running at the same time then it can happen that the <code>fusionscript.exe</code> will remain running in the background in limbo due to e.g. a Qt interface's QApplication that keeps running infinitely.</p> Warning <p>When the host is not detected this will automatically exit the current process.</p> Source code in <code>client/ayon_fusion/api/pulse.py</code> <pre><code>class FusionPulse(QtCore.QObject):\n    \"\"\"A Timer that checks whether host app is still alive.\n\n    This checks whether the Fusion process is still active at a certain\n    interval. This is useful due to how Fusion runs its scripts. Each script\n    runs in its own environment and process (a `fusionscript` process each).\n    If Fusion would go down and we have a UI process running at the same time\n    then it can happen that the `fusionscript.exe` will remain running in the\n    background in limbo due to e.g. a Qt interface's QApplication that keeps\n    running infinitely.\n\n    Warning:\n        When the host is not detected this will automatically exit\n        the current process.\n\n    \"\"\"\n\n    def __init__(self, parent=None):\n        super(FusionPulse, self).__init__(parent=parent)\n        self._thread = PulseThread(parent=self)\n        self._thread.no_response.connect(self.on_no_response)\n\n    def on_no_response(self):\n        print(\"Pulse detected no response from Fusion..\")\n        sys.exit(1)\n\n    def start(self):\n        self._thread.start()\n\n    def stop(self):\n        self._thread.requestInterruption()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/deploy/index.html","title":"deploy","text":""},{"location":"autoapi/client/ayon_fusion/deploy/MenuScripts/index.html","title":"MenuScripts","text":""},{"location":"autoapi/client/ayon_fusion/deploy/MenuScripts/install_pyside2.html","title":"install_pyside2","text":""},{"location":"autoapi/client/ayon_fusion/deploy/MenuScripts/launch_menu.html","title":"launch_menu","text":""},{"location":"autoapi/client/ayon_fusion/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_launch_menu_hook.html","title":"pre_fusion_launch_menu_hook","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_launch_menu_hook.html#client.ayon_fusion.hooks.pre_fusion_launch_menu_hook.FusionLaunchMenuHook","title":"<code>FusionLaunchMenuHook</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Launch AYON menu on start of Fusion</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_launch_menu_hook.py</code> <pre><code>class FusionLaunchMenuHook(PreLaunchHook):\n    \"\"\"Launch AYON menu on start of Fusion\"\"\"\n    app_groups = [\"fusion\"]\n    order = 9\n\n    def execute(self):\n        # Prelaunch hook is optional\n        settings = self.data[\"project_settings\"][\"fusion\"]\n        if not settings[\"hooks\"][\"FusionLaunchMenuHook\"][\"enabled\"]:\n            return\n\n        variant = self.application.name\n        if variant.isnumeric():\n            version = int(variant)\n            if version &lt; 18:\n                print(\"Skipping launch of OpenPype menu on Fusion start \"\n                      \"because Fusion version below 18.0 does not support \"\n                      \"/execute argument on launch. \"\n                      f\"Version detected: {version}\")\n                return\n        else:\n            print(f\"Application variant is not numeric: {variant}. \"\n                  \"Validation for Fusion version 18+ for /execute \"\n                  \"prelaunch argument skipped.\")\n\n        path = os.path.join(FUSION_ADDON_ROOT,\n                            \"deploy\",\n                            \"MenuScripts\",\n                            \"launch_menu.py\").replace(\"\\\\\", \"/\")\n        script = f\"fusion:RunScript('{path}')\"\n        self.launch_context.launch_args.extend([\"/execute\", script])\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_profile_hook.html","title":"pre_fusion_profile_hook","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_profile_hook.html#client.ayon_fusion.hooks.pre_fusion_profile_hook.FusionCopyPrefsPrelaunch","title":"<code>FusionCopyPrefsPrelaunch</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Prepares local Fusion profile directory, copies existing Fusion profile. This also sets FUSION MasterPrefs variable, which is used to apply Master.prefs file to override some Fusion profile settings to:     - enable the AYON menu     - force Python 3 over Python 2     - force English interface Master.prefs is defined in openpype/hosts/fusion/deploy/fusion_shared.prefs</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_profile_hook.py</code> <pre><code>class FusionCopyPrefsPrelaunch(PreLaunchHook):\n    \"\"\"\n    Prepares local Fusion profile directory, copies existing Fusion profile.\n    This also sets FUSION MasterPrefs variable, which is used\n    to apply Master.prefs file to override some Fusion profile settings to:\n        - enable the AYON menu\n        - force Python 3 over Python 2\n        - force English interface\n    Master.prefs is defined in openpype/hosts/fusion/deploy/fusion_shared.prefs\n    \"\"\"\n\n    app_groups = {\"fusion\"}\n    order = 2\n    launch_types = {LaunchTypes.local,\n                    LaunchTypes.farm_render,\n                    # This seems to be incorrectly configured for\n                    # ayon_applications addon, see `ayon_applications/#2`\n                    LaunchTypes.farm_publish}\n\n    def get_fusion_profile_name(self, profile_version) -&gt; str:\n        # Returns 'Default', unless FUSION16_PROFILE is set\n        return os.getenv(f\"FUSION{profile_version}_PROFILE\", \"Default\")\n\n    def get_fusion_profile_dir(self, profile_version) -&gt; Path:\n        # Get FUSION_PROFILE_DIR variable\n        fusion_profile = self.get_fusion_profile_name(profile_version)\n        fusion_var_prefs_dir = os.getenv(\n            f\"FUSION{profile_version}_PROFILE_DIR\"\n        )\n\n        # Check if FUSION_PROFILE_DIR exists\n        if fusion_var_prefs_dir and Path(fusion_var_prefs_dir).is_dir():\n            fu_prefs_dir = Path(fusion_var_prefs_dir, fusion_profile)\n            self.log.info(f\"{fusion_var_prefs_dir} is set to {fu_prefs_dir}\")\n            return fu_prefs_dir\n\n    def get_profile_source(self, profile_version) -&gt; Path:\n        \"\"\"Get Fusion preferences profile location.\n        See Per-User_Preferences_and_Paths on VFXpedia for reference.\n        \"\"\"\n        fusion_profile = self.get_fusion_profile_name(profile_version)\n        profile_source = self.get_fusion_profile_dir(profile_version)\n        if profile_source:\n            return profile_source\n        # otherwise get default location of the profile folder\n        fu_prefs_dir = f\"Blackmagic Design/Fusion/Profiles/{fusion_profile}\"\n        if platform.system() == \"Windows\":\n            profile_source = Path(os.getenv(\"AppData\"), fu_prefs_dir)\n        elif platform.system() == \"Darwin\":\n            profile_source = Path(\n                \"~/Library/Application Support/\", fu_prefs_dir\n            ).expanduser()\n        elif platform.system() == \"Linux\":\n            profile_source = Path(\"~/.fusion\", fu_prefs_dir).expanduser()\n        self.log.info(\n            f\"Locating source Fusion prefs directory: {profile_source}\"\n        )\n        return profile_source\n\n    def get_copy_fusion_prefs_settings(self):\n        # Get copy preferences options from the global application settings\n\n        copy_fusion_settings = self.data[\"project_settings\"][\"fusion\"].get(\n            \"copy_fusion_settings\", {}\n        )\n        if not copy_fusion_settings:\n            self.log.error(\"Copy prefs settings not found\")\n        copy_status = copy_fusion_settings.get(\"copy_status\", False)\n        force_sync = copy_fusion_settings.get(\"force_sync\", False)\n        copy_path = copy_fusion_settings.get(\"copy_path\") or None\n        if copy_path:\n            copy_path = Path(copy_path).expanduser()\n        return copy_status, copy_path, force_sync\n\n    def copy_fusion_profile(\n        self, copy_from: Path, copy_to: Path, force_sync: bool\n    ) -&gt; None:\n        \"\"\"On the first Fusion launch copy the contents of Fusion profile\n        directory to the working predefined location. If the Openpype profile\n        folder exists, skip copying, unless re-sync is checked.\n        If the prefs were not copied on the first launch,\n        clean Fusion profile will be created in fu_profile_dir.\n        \"\"\"\n        if copy_to.exists() and not force_sync:\n            self.log.info(\n                \"Destination Fusion preferences folder already exists: \"\n                f\"{copy_to} \"\n            )\n            return\n        self.log.info(\"Starting copying Fusion preferences\")\n        self.log.debug(f\"force_sync option is set to {force_sync}\")\n        try:\n            copy_to.mkdir(exist_ok=True, parents=True)\n        except PermissionError:\n            self.log.warning(f\"Creating the folder not permitted at {copy_to}\")\n            return\n        if not copy_from.exists():\n            self.log.warning(f\"Fusion preferences not found in {copy_from}\")\n            return\n        for file in copy_from.iterdir():\n            if file.suffix in (\n                \".prefs\",\n                \".def\",\n                \".blocklist\",\n                \".fu\",\n                \".toolbars\",\n            ):\n                # convert Path to str to be compatible with Python 3.6+\n                shutil.copy(str(file), str(copy_to))\n        self.log.info(\n            f\"Successfully copied preferences: {copy_from} to {copy_to}\"\n        )\n\n    def execute(self):\n        (\n            copy_status,\n            fu_profile_dir,\n            force_sync,\n        ) = self.get_copy_fusion_prefs_settings()\n\n        # Get launched application context and return correct app version\n        app_name = self.launch_context.env.get(\"AYON_APP_NAME\")\n        app_version = get_fusion_version(app_name)\n        if app_version is None:\n            version_names = \", \".join(str(x) for x in FUSION_VERSIONS_DICT)\n            raise ApplicationLaunchFailed(\n                \"Unable to detect valid Fusion version number from app \"\n                f\"name: {app_name}.\\nMake sure to include at least a digit \"\n                \"to indicate the Fusion version like '18'.\\n\"\n                f\"Detectable Fusion versions are: {version_names}\"\n            )\n\n        _, profile_version = FUSION_VERSIONS_DICT[app_version]\n        fu_profile = self.get_fusion_profile_name(profile_version)\n\n        # do a copy of Fusion profile if copy_status toggle is enabled\n        if copy_status and fu_profile_dir is not None:\n            profile_source = self.get_profile_source(profile_version)\n            dest_folder = Path(fu_profile_dir, fu_profile)\n            self.copy_fusion_profile(profile_source, dest_folder, force_sync)\n\n        # Add temporary profile directory variables to customize Fusion\n        # to define where it can read custom scripts and tools from\n        fu_profile_dir_variable = f\"FUSION{profile_version}_PROFILE_DIR\"\n        self.log.info(f\"Setting {fu_profile_dir_variable}: {fu_profile_dir}\")\n        self.launch_context.env[fu_profile_dir_variable] = str(fu_profile_dir)\n\n        # Add custom Fusion Master Prefs and the temporary\n        # profile directory variables to customize Fusion\n        # to define where it can read custom scripts and tools from\n        master_prefs_variable = f\"FUSION{profile_version}_MasterPrefs\"\n\n        master_prefs = Path(\n            FUSION_ADDON_ROOT, \"deploy\", \"ayon\", \"fusion_shared.prefs\")\n\n        self.log.info(f\"Setting {master_prefs_variable}: {master_prefs}\")\n        self.launch_context.env[master_prefs_variable] = str(master_prefs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_profile_hook.html#client.ayon_fusion.hooks.pre_fusion_profile_hook.FusionCopyPrefsPrelaunch.copy_fusion_profile","title":"<code>copy_fusion_profile(copy_from, copy_to, force_sync)</code>","text":"<p>On the first Fusion launch copy the contents of Fusion profile directory to the working predefined location. If the Openpype profile folder exists, skip copying, unless re-sync is checked. If the prefs were not copied on the first launch, clean Fusion profile will be created in fu_profile_dir.</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_profile_hook.py</code> <pre><code>def copy_fusion_profile(\n    self, copy_from: Path, copy_to: Path, force_sync: bool\n) -&gt; None:\n    \"\"\"On the first Fusion launch copy the contents of Fusion profile\n    directory to the working predefined location. If the Openpype profile\n    folder exists, skip copying, unless re-sync is checked.\n    If the prefs were not copied on the first launch,\n    clean Fusion profile will be created in fu_profile_dir.\n    \"\"\"\n    if copy_to.exists() and not force_sync:\n        self.log.info(\n            \"Destination Fusion preferences folder already exists: \"\n            f\"{copy_to} \"\n        )\n        return\n    self.log.info(\"Starting copying Fusion preferences\")\n    self.log.debug(f\"force_sync option is set to {force_sync}\")\n    try:\n        copy_to.mkdir(exist_ok=True, parents=True)\n    except PermissionError:\n        self.log.warning(f\"Creating the folder not permitted at {copy_to}\")\n        return\n    if not copy_from.exists():\n        self.log.warning(f\"Fusion preferences not found in {copy_from}\")\n        return\n    for file in copy_from.iterdir():\n        if file.suffix in (\n            \".prefs\",\n            \".def\",\n            \".blocklist\",\n            \".fu\",\n            \".toolbars\",\n        ):\n            # convert Path to str to be compatible with Python 3.6+\n            shutil.copy(str(file), str(copy_to))\n    self.log.info(\n        f\"Successfully copied preferences: {copy_from} to {copy_to}\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_profile_hook.html#client.ayon_fusion.hooks.pre_fusion_profile_hook.FusionCopyPrefsPrelaunch.get_profile_source","title":"<code>get_profile_source(profile_version)</code>","text":"<p>Get Fusion preferences profile location. See Per-User_Preferences_and_Paths on VFXpedia for reference.</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_profile_hook.py</code> <pre><code>def get_profile_source(self, profile_version) -&gt; Path:\n    \"\"\"Get Fusion preferences profile location.\n    See Per-User_Preferences_and_Paths on VFXpedia for reference.\n    \"\"\"\n    fusion_profile = self.get_fusion_profile_name(profile_version)\n    profile_source = self.get_fusion_profile_dir(profile_version)\n    if profile_source:\n        return profile_source\n    # otherwise get default location of the profile folder\n    fu_prefs_dir = f\"Blackmagic Design/Fusion/Profiles/{fusion_profile}\"\n    if platform.system() == \"Windows\":\n        profile_source = Path(os.getenv(\"AppData\"), fu_prefs_dir)\n    elif platform.system() == \"Darwin\":\n        profile_source = Path(\n            \"~/Library/Application Support/\", fu_prefs_dir\n        ).expanduser()\n    elif platform.system() == \"Linux\":\n        profile_source = Path(\"~/.fusion\", fu_prefs_dir).expanduser()\n    self.log.info(\n        f\"Locating source Fusion prefs directory: {profile_source}\"\n    )\n    return profile_source\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_setup.html","title":"pre_fusion_setup","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_setup.html#client.ayon_fusion.hooks.pre_fusion_setup.FusionPrelaunch","title":"<code>FusionPrelaunch</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Prepares AYON Fusion environment. Requires correct Python home variable to be defined in the environment settings for Fusion to point at a valid Python 3 build for Fusion. Python3 versions that are supported by Fusion: Fusion 9, 16, 17 : Python 3.6 Fusion 18        : Python 3.6 - 3.10</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_setup.py</code> <pre><code>class FusionPrelaunch(PreLaunchHook):\n    \"\"\"\n    Prepares AYON Fusion environment.\n    Requires correct Python home variable to be defined in the environment\n    settings for Fusion to point at a valid Python 3 build for Fusion.\n    Python3 versions that are supported by Fusion:\n    Fusion 9, 16, 17 : Python 3.6\n    Fusion 18        : Python 3.6 - 3.10\n    \"\"\"\n\n    app_groups = {\"fusion\"}\n    order = 1\n    launch_types = {LaunchTypes.local,\n                    LaunchTypes.farm_render,\n                    # This seems to be incorrectly configured for\n                    # ayon_applications addon, see `ayon_applications/#2`\n                    LaunchTypes.farm_publish}\n\n    def execute(self):\n        # making sure python 3 is installed at provided path\n        # Py 3.3-3.10 for Fusion 18+ or Py 3.6 for Fu 16-17\n        app_data = self.launch_context.env.get(\"AYON_APP_NAME\")\n        app_version = get_fusion_version(app_data)\n        if not app_version:\n            self.log.warning(\n                f\"Fusion version information not found for '{app_data}'.\\n\"\n                \"The key field in the 'applications/fusion/variants' should \"\n                \"consist of a number, corresponding to major Fusion version. \"\n                f\"Assuming fallback version: {FUSION_FALLBACK_VERSION}.\"\n            )\n            app_version = FUSION_FALLBACK_VERSION\n\n        py3_var, _ = FUSION_VERSIONS_DICT[app_version]\n        fusion_python3_home = self.launch_context.env.get(py3_var, \"\")\n\n        for path in fusion_python3_home.split(os.pathsep):\n            # Allow defining multiple paths, separated by os.pathsep,\n            # to allow \"fallback\" to other path.\n            # But make to set only a single path as final variable.\n            py3_dir = os.path.normpath(path)\n            if os.path.isdir(py3_dir):\n                break\n        else:\n            raise ApplicationLaunchFailed(\n                \"Python 3 is not installed at the provided path.\\n\"\n                \"Make sure the environment in fusion settings has \"\n                \"'FUSION_PYTHON3_HOME' set correctly and make sure \"\n                \"Python 3 is installed in the given path.\"\n                f\"\\n\\nPYTHON PATH: {fusion_python3_home}\"\n            )\n\n        self.log.info(f\"Setting {py3_var}: '{py3_dir}'...\")\n        self.launch_context.env[py3_var] = py3_dir\n\n        # Fusion 18+ requires FUSION_PYTHON3_HOME to also be on PATH\n        if app_version &gt;= 18:\n            self.launch_context.env[\"PATH\"] += os.pathsep + py3_dir\n\n        self.launch_context.env[py3_var] = py3_dir\n\n        # for hook installing PySide2\n        self.data[\"fusion_python3_home\"] = py3_dir\n\n        self.log.info(f\"Setting AYON_FUSION_ROOT: {FUSION_ADDON_ROOT}\")\n        self.launch_context.env[\"AYON_FUSION_ROOT\"] = FUSION_ADDON_ROOT\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_pyside_install.html","title":"pre_pyside_install","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_pyside_install.html#client.ayon_fusion.hooks.pre_pyside_install.InstallPySideToFusion","title":"<code>InstallPySideToFusion</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Automatically installs Qt binding to fusion's python packages.</p> <p>Check if fusion has installed PySide2 and will try to install if not.</p> <p>For pipeline implementation is required to have Qt binding installed in fusion's python packages.</p> Source code in <code>client/ayon_fusion/hooks/pre_pyside_install.py</code> <pre><code>class InstallPySideToFusion(PreLaunchHook):\n    \"\"\"Automatically installs Qt binding to fusion's python packages.\n\n    Check if fusion has installed PySide2 and will try to install if not.\n\n    For pipeline implementation is required to have Qt binding installed in\n    fusion's python packages.\n    \"\"\"\n\n    app_groups = {\"fusion\"}\n    order = 2\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Prelaunch hook is not crucial\n        try:\n            settings = self.data[\"project_settings\"][\"fusion\"]\n            if not settings[\"hooks\"][\"InstallPySideToFusion\"][\"enabled\"]:\n                return\n            self.inner_execute()\n        except Exception:\n            self.log.warning(\n                \"Processing of {} crashed.\".format(self.__class__.__name__),\n                exc_info=True\n            )\n\n    def inner_execute(self):\n        self.log.debug(\"Check for PySide2 installation.\")\n\n        fusion_python3_home = self.data.get(\"fusion_python3_home\")\n        if not fusion_python3_home:\n            self.log.warning(\"'fusion_python3_home' was not provided. \"\n                             \"Installation of PySide2 not possible\")\n            return\n\n        if platform.system().lower() == \"windows\":\n            exe_filenames = [\"python.exe\"]\n        else:\n            exe_filenames = [\"python3\", \"python\"]\n\n        for exe_filename in exe_filenames:\n            python_executable = os.path.join(fusion_python3_home, exe_filename)\n            if os.path.exists(python_executable):\n                break\n\n        if not os.path.exists(python_executable):\n            self.log.warning(\n                \"Couldn't find python executable for fusion. {}\".format(\n                    python_executable\n                )\n            )\n            return\n\n        # Check if PySide2 is installed and skip if yes\n        if self._is_pyside_installed(python_executable):\n            self.log.debug(\"Fusion has already installed PySide2.\")\n            return\n\n        self.log.debug(\"Installing PySide2.\")\n        # Install PySide2 in fusion's python\n        if self._windows_require_permissions(\n                os.path.dirname(python_executable)):\n            result = self._install_pyside_windows(python_executable)\n        else:\n            result = self._install_pyside(python_executable)\n\n        if result:\n            self.log.info(\"Successfully installed PySide2 module to fusion.\")\n        else:\n            self.log.warning(\"Failed to install PySide2 module to fusion.\")\n\n    def _install_pyside_windows(self, python_executable):\n        \"\"\"Install PySide2 python module to fusion's python.\n\n        Installation requires administration rights that's why it is required\n        to use \"pywin32\" module which can execute command's and ask for\n        administration rights.\n        \"\"\"\n        try:\n            import win32con\n            import win32process\n            import win32event\n            import pywintypes\n            from win32comext.shell.shell import ShellExecuteEx\n            from win32comext.shell import shellcon\n        except Exception:\n            self.log.warning(\"Couldn't import \\\"pywin32\\\" modules\")\n            return False\n\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install PySide2 and argument\n            #   \"--ignore-installed\" is to force install module to fusion's\n            #   site-packages and make sure it is binary compatible\n            parameters = \"-m pip install --ignore-installed PySide2\"\n\n            # Execute command and ask for administrator's rights\n            process_info = ShellExecuteEx(\n                nShow=win32con.SW_SHOWNORMAL,\n                fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,\n                lpVerb=\"runas\",\n                lpFile=python_executable,\n                lpParameters=parameters,\n                lpDirectory=os.path.dirname(python_executable)\n            )\n            process_handle = process_info[\"hProcess\"]\n            win32event.WaitForSingleObject(process_handle,\n                                           win32event.INFINITE)\n            returncode = win32process.GetExitCodeProcess(process_handle)\n            return returncode == 0\n        except pywintypes.error:\n            return False\n\n    def _install_pyside(self, python_executable):\n        \"\"\"Install PySide2 python module to fusion's python.\"\"\"\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install PySide2 and argument\n            #   \"--ignore-installed\" is to force install module to fusion's\n            #   site-packages and make sure it is binary compatible\n            env = dict(os.environ)\n            del env['PYTHONPATH']\n            args = [\n                python_executable,\n                \"-m\",\n                \"pip\",\n                \"install\",\n                \"--ignore-installed\",\n                \"PySide2\",\n            ]\n            process = subprocess.Popen(\n                args, stdout=subprocess.PIPE, universal_newlines=True,\n                env=env\n            )\n            process.communicate()\n            return process.returncode == 0\n        except PermissionError:\n            self.log.warning(\n                \"Permission denied with command:\"\n                \"\\\"{}\\\".\".format(\" \".join(args))\n            )\n        except OSError as error:\n            self.log.warning(f\"OS error has occurred: \\\"{error}\\\".\")\n        except subprocess.SubprocessError:\n            pass\n\n    def _is_pyside_installed(self, python_executable):\n        \"\"\"Check if PySide2 module is in fusion's pip list.\"\"\"\n        args = [python_executable, \"-c\", \"from qtpy import QtWidgets\"]\n        process = subprocess.Popen(args,\n                                   stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)\n        _, stderr = process.communicate()\n        stderr = stderr.decode()\n        if stderr:\n            return False\n        return True\n\n    def _windows_require_permissions(self, dirpath):\n        if platform.system().lower() != \"windows\":\n            return False\n\n        try:\n            # Attempt to create a temporary file in the folder\n            temp_file_path = os.path.join(dirpath, uuid.uuid4().hex)\n            with open(temp_file_path, \"w\"):\n                pass\n            os.remove(temp_file_path)  # Clean up temporary file\n            return False\n\n        except PermissionError:\n            return True\n\n        except BaseException as exc:\n            print((\"Failed to determine if root requires permissions.\"\n                   \"Unexpected error: {}\").format(exc))\n            return False\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_fusion/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_fusion/plugins/create/create_image_saver.html","title":"create_image_saver","text":""},{"location":"autoapi/client/ayon_fusion/plugins/create/create_image_saver.html#client.ayon_fusion.plugins.create.create_image_saver.CreateImageSaver","title":"<code>CreateImageSaver</code>","text":"<p>               Bases: <code>GenericCreateSaver</code></p> <p>Fusion Saver to generate single image.</p> <p>Created to explicitly separate single ('image') or     multi frame('render) outputs.</p> <p>This might be temporary creator until 'alias' functionality will be implemented to limit creation of additional product types with similar, but not the same workflows.</p> Source code in <code>client/ayon_fusion/plugins/create/create_image_saver.py</code> <pre><code>class CreateImageSaver(GenericCreateSaver):\n    \"\"\"Fusion Saver to generate single image.\n\n     Created to explicitly separate single ('image') or\n        multi frame('render) outputs.\n\n    This might be temporary creator until 'alias' functionality will be\n    implemented to limit creation of additional product types with similar, but\n    not the same workflows.\n    \"\"\"\n    identifier = \"io.openpype.creators.fusion.imagesaver\"\n    label = \"Image (saver)\"\n    name = \"image\"\n    product_type = \"image\"\n    description = \"Fusion Saver to generate a single image file\"\n\n    default_frame = 0\n\n    def get_detail_description(self):\n        return inspect.cleandoc(\n            \"\"\"Fusion Saver to generate a single image file.\n\n            This creator is expected for publishing of single frame `image` \n            product type.\n\n            Artist should provide frame number (integer) to specify which frame\n            should be published. It must be inside of global timeline frame \n            range.\n\n            Supports local and deadline rendering.\n\n            Supports selection from predefined set of output file extensions:\n            - exr\n            - tga\n            - png\n            - tif\n            - jpg\n\n            Created to explicitly separate single frame ('image') or\n            multi frame ('render') outputs.\n            \"\"\"\n        )\n\n    def get_pre_create_attr_defs(self):\n        \"\"\"Settings for create page\"\"\"\n        attr_defs = [\n            self._get_render_target_enum(),\n            self._get_reviewable_bool(),\n            self._get_frame_int(),\n            self._get_image_format_enum(),\n        ]\n        return attr_defs\n\n    def _get_frame_int(self):\n        return NumberDef(\n            \"frame\",\n            default=self.default_frame,\n            label=\"Frame\",\n            tooltip=\"Set frame to be rendered, must be inside of global \"\n                    \"timeline range\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_image_saver.html#client.ayon_fusion.plugins.create.create_image_saver.CreateImageSaver.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<p>Settings for create page</p> Source code in <code>client/ayon_fusion/plugins/create/create_image_saver.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    \"\"\"Settings for create page\"\"\"\n    attr_defs = [\n        self._get_render_target_enum(),\n        self._get_reviewable_bool(),\n        self._get_frame_int(),\n        self._get_image_format_enum(),\n    ]\n    return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_saver.html","title":"create_saver","text":""},{"location":"autoapi/client/ayon_fusion/plugins/create/create_saver.html#client.ayon_fusion.plugins.create.create_saver.CreateSaver","title":"<code>CreateSaver</code>","text":"<p>               Bases: <code>GenericCreateSaver</code></p> <p>Fusion Saver to generate image sequence of 'render' product type.</p> <p>Original Saver creator targeted for 'render' product type. It uses original not to descriptive name because of values in Settings.</p> Source code in <code>client/ayon_fusion/plugins/create/create_saver.py</code> <pre><code>class CreateSaver(GenericCreateSaver):\n    \"\"\"Fusion Saver to generate image sequence of 'render' product type.\n\n     Original Saver creator targeted for 'render' product type. It uses\n     original not to descriptive name because of values in Settings.\n    \"\"\"\n    identifier = \"io.openpype.creators.fusion.saver\"\n    label = \"Render (saver)\"\n    name = \"render\"\n    product_type = \"render\"\n    description = \"Fusion Saver to generate image sequence\"\n\n    default_frame_range_option = \"current_context\"\n\n    def get_detail_description(self):\n        return inspect.cleandoc(\n            \"\"\"Fusion Saver to generate image sequence.\n\n            This creator is expected for publishing of image sequences for \n            'render' product type. (But can publish even single frame \n            'render'.)\n\n            Select what should be source of render range:\n            - \"Current Folder context\" - values set on folder on AYON server\n            - \"From render in/out\" - from node itself\n            - \"From composition timeline\" - from timeline\n\n            Supports local and farm rendering.\n\n            Supports selection from predefined set of output file extensions:\n            - exr\n            - tga\n            - png\n            - tif\n            - jpg\n            \"\"\"\n        )\n\n    def register_callbacks(self):\n        self.create_context.add_value_changed_callback(self.on_values_changed)\n\n    def on_values_changed(self, event):\n        \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n\n        for instance_change in event[\"changes\"]:\n            # First check if there's a change we want to respond to\n            instance = instance_change[\"instance\"]\n            if instance is None:\n                # Change is on context\n                continue\n\n            if instance[\"creator_identifier\"] != self.identifier:\n                continue\n\n            value_changes = instance_change[\"changes\"]\n            if (\n                \"frame_range_source\"\n                not in value_changes.get(\"creator_attributes\", {})\n            ):\n                continue\n\n            # Update the attribute definitions\n            new_attrs = self.get_attr_defs_for_instance(instance)\n            instance.set_create_attr_defs(new_attrs)\n\n    def get_pre_create_attr_defs(self):\n        \"\"\"Settings for create page\"\"\"\n        attr_defs = [\n            self._get_render_target_enum(),\n            self._get_reviewable_bool(),\n            self._get_frame_range_enum(),\n            self._get_image_format_enum(),\n            *self._get_custom_frame_range_attribute_defs()\n        ]\n        return attr_defs\n\n    def get_attr_defs_for_instance(self, instance):\n        return [\n            self._get_render_target_enum(),\n            self._get_reviewable_bool(),\n            self._get_frame_range_enum(),\n            self._get_image_format_enum(),\n            *self._get_custom_frame_range_attribute_defs(instance)\n        ]\n\n    def _get_frame_range_enum(self):\n        frame_range_options = {\n            \"current_task\": \"Current context\",\n            \"render_range\": \"From render in/out\",\n            \"comp_range\": \"From composition timeline\",\n            \"custom_range\": \"Custom frame range\",\n        }\n\n        return EnumDef(\n            \"frame_range_source\",\n            items=frame_range_options,\n            label=\"Frame range source\",\n            default=self.default_frame_range_option\n        )\n\n    @staticmethod\n    def _get_custom_frame_range_attribute_defs(instance=None) -&gt; list:\n\n        # If an instance is provided and 'custom_range' is not the frame\n        # range source, then we will disable the custom frame range attributes\n        custom_enabled = True\n        if instance is not None:\n            frame_range_source = instance.get(\n                \"creator_attributes\", {}).get(\"frame_range_source\")\n            custom_enabled = frame_range_source == \"custom_range\"\n\n        # Define custom frame range defaults based on current comp\n        # timeline settings (if a comp is currently open)\n        comp = get_current_comp()\n        if comp is not None:\n            attrs = comp.GetAttrs()\n            frame_defaults = {\n                \"frameStart\": int(attrs[\"COMPN_GlobalStart\"]),\n                \"frameEnd\": int(attrs[\"COMPN_GlobalEnd\"]),\n                \"handleStart\": int(\n                    attrs[\"COMPN_RenderStart\"] - attrs[\"COMPN_GlobalStart\"]\n                ),\n                \"handleEnd\": int(\n                    attrs[\"COMPN_GlobalEnd\"] - attrs[\"COMPN_RenderEnd\"]\n                ),\n            }\n        else:\n            frame_defaults = {\n                \"frameStart\": 1001,\n                \"frameEnd\": 1100,\n                \"handleStart\": 0,\n                \"handleEnd\": 0\n            }\n\n        attr_defs = []\n        if custom_enabled:\n            # UILabelDef does not support `hidden` argument so we exclude it\n            # manually\n            attr_defs.append(\n                UILabelDef(\n                    label=\"&lt;br&gt;&lt;b&gt;Custom Frame Range&lt;/b&gt;\",\n                ),\n            )\n\n        attr_defs.extend([\n            NumberDef(\n                \"custom_frameStart\",\n                label=\"Frame Start\",\n                default=frame_defaults[\"frameStart\"],\n                minimum=0,\n                decimals=0,\n                tooltip=(\n                    \"Set the start frame for the export.\\n\"\n                    \"Only used if frame range source is 'Custom frame range'.\"\n                ),\n                visible=custom_enabled\n            ),\n            NumberDef(\n                \"custom_frameEnd\",\n                label=\"Frame End\",\n                default=frame_defaults[\"frameEnd\"],\n                minimum=0,\n                decimals=0,\n                tooltip=(\n                    \"Set the end frame for the export.\\n\"\n                    \"Only used if frame range source is 'Custom frame range'.\"\n                ),\n                visible=custom_enabled\n            ),\n            NumberDef(\n                \"custom_handleStart\",\n                label=\"Handle Start\",\n                default=frame_defaults[\"handleStart\"],\n                minimum=0,\n                decimals=0,\n                tooltip=(\n                    \"Set the start handles for the export, this will be \"\n                    \"added before the start frame.\\n\"\n                    \"Only used if frame range source is 'Custom frame range'.\"\n                ),\n                visible=custom_enabled\n            ),\n            NumberDef(\n                \"custom_handleEnd\",\n                label=\"Handle End\",\n                default=frame_defaults[\"handleEnd\"],\n                minimum=0,\n                decimals=0,\n                tooltip=(\n                    \"Set the end handles for the export, this will be added \"\n                    \"after the end frame.\\n\"\n                    \"Only used if frame range source is 'Custom frame range'.\"\n                ),\n                visible=custom_enabled\n            )\n        ])\n        return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_saver.html#client.ayon_fusion.plugins.create.create_saver.CreateSaver.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<p>Settings for create page</p> Source code in <code>client/ayon_fusion/plugins/create/create_saver.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    \"\"\"Settings for create page\"\"\"\n    attr_defs = [\n        self._get_render_target_enum(),\n        self._get_reviewable_bool(),\n        self._get_frame_range_enum(),\n        self._get_image_format_enum(),\n        *self._get_custom_frame_range_attribute_defs()\n    ]\n    return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_saver.html#client.ayon_fusion.plugins.create.create_saver.CreateSaver.on_values_changed","title":"<code>on_values_changed(event)</code>","text":"<p>Update instance attribute definitions on attribute changes.</p> Source code in <code>client/ayon_fusion/plugins/create/create_saver.py</code> <pre><code>def on_values_changed(self, event):\n    \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n\n    for instance_change in event[\"changes\"]:\n        # First check if there's a change we want to respond to\n        instance = instance_change[\"instance\"]\n        if instance is None:\n            # Change is on context\n            continue\n\n        if instance[\"creator_identifier\"] != self.identifier:\n            continue\n\n        value_changes = instance_change[\"changes\"]\n        if (\n            \"frame_range_source\"\n            not in value_changes.get(\"creator_attributes\", {})\n        ):\n            continue\n\n        # Update the attribute definitions\n        new_attrs = self.get_attr_defs_for_instance(instance)\n        instance.set_create_attr_defs(new_attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_workfile.html","title":"create_workfile","text":""},{"location":"autoapi/client/ayon_fusion/plugins/inventory/index.html","title":"inventory","text":""},{"location":"autoapi/client/ayon_fusion/plugins/inventory/select_containers.html","title":"select_containers","text":""},{"location":"autoapi/client/ayon_fusion/plugins/inventory/set_tool_color.html","title":"set_tool_color","text":""},{"location":"autoapi/client/ayon_fusion/plugins/inventory/set_tool_color.html#client.ayon_fusion.plugins.inventory.set_tool_color.FusionSetToolColor","title":"<code>FusionSetToolColor</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Update the color of the selected tools</p> Source code in <code>client/ayon_fusion/plugins/inventory/set_tool_color.py</code> <pre><code>class FusionSetToolColor(InventoryAction):\n    \"\"\"Update the color of the selected tools\"\"\"\n\n    label = \"Set Tool Color\"\n    icon = \"plus\"\n    color = \"#d8d8d8\"\n    _fallback_color = QtGui.QColor(1.0, 1.0, 1.0)\n\n    def process(self, containers):\n        \"\"\"Color all selected tools the selected colors\"\"\"\n\n        result = []\n        comp = get_current_comp()\n\n        # Get tool color\n        first = containers[0]\n        tool = first[\"_tool\"]\n        color = tool.TileColor\n\n        if color is not None:\n            qcolor = QtGui.QColor().fromRgbF(color[\"R\"], color[\"G\"], color[\"B\"])\n        else:\n            qcolor = self._fallback_color\n\n        # Launch pick color\n        picked_color = self.get_color_picker(qcolor)\n        if not picked_color:\n            return\n\n        with comp_lock_and_undo_chunk(comp):\n            for container in containers:\n                # Convert color to RGB 0-1 floats\n                rgb_f = picked_color.getRgbF()\n                rgb_f_table = {\"R\": rgb_f[0], \"G\": rgb_f[1], \"B\": rgb_f[2]}\n\n                # Update tool\n                tool = container[\"_tool\"]\n                tool.TileColor = rgb_f_table\n\n                result.append(container)\n\n        return result\n\n    def get_color_picker(self, color):\n        \"\"\"Launch color picker and return chosen color\n\n        Args:\n            color(QtGui.QColor): Start color to display\n\n        Returns:\n            QtGui.QColor\n\n        \"\"\"\n\n        color_dialog = QtWidgets.QColorDialog(color)\n        color_dialog.setStyleSheet(style.load_stylesheet())\n\n        accepted = color_dialog.exec_()\n        if not accepted:\n            return\n\n        return color_dialog.selectedColor()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/inventory/set_tool_color.html#client.ayon_fusion.plugins.inventory.set_tool_color.FusionSetToolColor.get_color_picker","title":"<code>get_color_picker(color)</code>","text":"<p>Launch color picker and return chosen color</p> <p>Parameters:</p> Name Type Description Default <code>color(QtGui.QColor)</code> <p>Start color to display</p> required <p>Returns:</p> Type Description <p>QtGui.QColor</p> Source code in <code>client/ayon_fusion/plugins/inventory/set_tool_color.py</code> <pre><code>def get_color_picker(self, color):\n    \"\"\"Launch color picker and return chosen color\n\n    Args:\n        color(QtGui.QColor): Start color to display\n\n    Returns:\n        QtGui.QColor\n\n    \"\"\"\n\n    color_dialog = QtWidgets.QColorDialog(color)\n    color_dialog.setStyleSheet(style.load_stylesheet())\n\n    accepted = color_dialog.exec_()\n    if not accepted:\n        return\n\n    return color_dialog.selectedColor()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/inventory/set_tool_color.html#client.ayon_fusion.plugins.inventory.set_tool_color.FusionSetToolColor.process","title":"<code>process(containers)</code>","text":"<p>Color all selected tools the selected colors</p> Source code in <code>client/ayon_fusion/plugins/inventory/set_tool_color.py</code> <pre><code>def process(self, containers):\n    \"\"\"Color all selected tools the selected colors\"\"\"\n\n    result = []\n    comp = get_current_comp()\n\n    # Get tool color\n    first = containers[0]\n    tool = first[\"_tool\"]\n    color = tool.TileColor\n\n    if color is not None:\n        qcolor = QtGui.QColor().fromRgbF(color[\"R\"], color[\"G\"], color[\"B\"])\n    else:\n        qcolor = self._fallback_color\n\n    # Launch pick color\n    picked_color = self.get_color_picker(qcolor)\n    if not picked_color:\n        return\n\n    with comp_lock_and_undo_chunk(comp):\n        for container in containers:\n            # Convert color to RGB 0-1 floats\n            rgb_f = picked_color.getRgbF()\n            rgb_f_table = {\"R\": rgb_f[0], \"G\": rgb_f[1], \"B\": rgb_f[2]}\n\n            # Update tool\n            tool = container[\"_tool\"]\n            tool.TileColor = rgb_f_table\n\n            result.append(container)\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/actions.html","title":"actions","text":"<p>A module containing generic loader actions that will display in the Loader.</p>"},{"location":"autoapi/client/ayon_fusion/plugins/load/actions.html#client.ayon_fusion.plugins.load.actions.FusionSetFrameRangeLoader","title":"<code>FusionSetFrameRangeLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range excluding pre- and post-handles</p> Source code in <code>client/ayon_fusion/plugins/load/actions.py</code> <pre><code>class FusionSetFrameRangeLoader(load.LoaderPlugin):\n    \"\"\"Set frame range excluding pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"imagesequence\",\n        \"render\",\n        \"yeticache\",\n        \"pointcache\",\n        \"render\",\n    }\n    representations = {\"*\"}\n    extensions = {\"*\"}\n\n    label = \"Set frame range\"\n    order = 11\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name, namespace, data):\n\n        from ayon_fusion.api import lib\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        start = version_attributes.get(\"frameStart\", None)\n        end = version_attributes.get(\"frameEnd\", None)\n\n        if start is None or end is None:\n            print(\"Skipping setting frame range because start or \"\n                  \"end frame data is missing..\")\n            return\n\n        lib.update_frame_range(start, end)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/actions.html#client.ayon_fusion.plugins.load.actions.FusionSetFrameRangeWithHandlesLoader","title":"<code>FusionSetFrameRangeWithHandlesLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range including pre- and post-handles</p> Source code in <code>client/ayon_fusion/plugins/load/actions.py</code> <pre><code>class FusionSetFrameRangeWithHandlesLoader(load.LoaderPlugin):\n    \"\"\"Set frame range including pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"imagesequence\",\n        \"render\",\n        \"yeticache\",\n        \"pointcache\",\n        \"render\",\n    }\n    representations = {\"*\"}\n\n    label = \"Set frame range (with handles)\"\n    order = 12\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name, namespace, data):\n\n        from ayon_fusion.api import lib\n\n        version_attributes = context[\"version\"][\"attrib\"]\n        start = version_attributes.get(\"frameStart\", None)\n        end = version_attributes.get(\"frameEnd\", None)\n\n        if start is None or end is None:\n            print(\"Skipping setting frame range because start or \"\n                  \"end frame data is missing..\")\n            return\n\n        # Include handles\n        start -= version_attributes.get(\"handleStart\", 0)\n        end += version_attributes.get(\"handleEnd\", 0)\n\n        lib.update_frame_range(start, end)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_alembic.html","title":"load_alembic","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/load_alembic.html#client.ayon_fusion.plugins.load.load_alembic.FusionLoadAlembicMesh","title":"<code>FusionLoadAlembicMesh</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load Alembic mesh into Fusion</p> Source code in <code>client/ayon_fusion/plugins/load/load_alembic.py</code> <pre><code>class FusionLoadAlembicMesh(load.LoaderPlugin):\n    \"\"\"Load Alembic mesh into Fusion\"\"\"\n\n    product_types = {\"pointcache\", \"model\"}\n    representations = {\"*\"}\n    extensions = {\"abc\"}\n\n    label = \"Load alembic mesh\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    tool_type = \"SurfaceAlembicMesh\"\n\n    def load(self, context, name, namespace, data):\n        # Fallback to folder name when namespace is None\n        if namespace is None:\n            namespace = context[\"folder\"][\"name\"]\n\n        # Create the Loader with the filename path set\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp, \"Create tool\"):\n\n            path = self.filepath_from_context(context)\n\n            args = (-32768, -32768)\n            tool = comp.AddTool(self.tool_type, *args)\n            tool[\"Filename\"] = path\n\n            imprint_container(tool,\n                              name=name,\n                              namespace=namespace,\n                              context=context,\n                              loader=self.__class__.__name__)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        \"\"\"Update Alembic path\"\"\"\n\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        repre_entity = context[\"representation\"]\n        path = get_representation_path(repre_entity)\n\n        with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n            tool[\"Filename\"] = path\n\n            # Update the imprinted representation\n            tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n\n    def remove(self, container):\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        with comp_lock_and_undo_chunk(comp, \"Remove tool\"):\n            tool.Delete()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_alembic.html#client.ayon_fusion.plugins.load.load_alembic.FusionLoadAlembicMesh.update","title":"<code>update(container, context)</code>","text":"<p>Update Alembic path</p> Source code in <code>client/ayon_fusion/plugins/load/load_alembic.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update Alembic path\"\"\"\n\n    tool = container[\"_tool\"]\n    assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n    comp = tool.Comp()\n\n    repre_entity = context[\"representation\"]\n    path = get_representation_path(repre_entity)\n\n    with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n        tool[\"Filename\"] = path\n\n        # Update the imprinted representation\n        tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_fbx.html","title":"load_fbx","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/load_fbx.html#client.ayon_fusion.plugins.load.load_fbx.FusionLoadFBXMesh","title":"<code>FusionLoadFBXMesh</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load FBX mesh into Fusion</p> Source code in <code>client/ayon_fusion/plugins/load/load_fbx.py</code> <pre><code>class FusionLoadFBXMesh(load.LoaderPlugin):\n    \"\"\"Load FBX mesh into Fusion\"\"\"\n\n    product_types = {\"*\"}\n    representations = {\"*\"}\n    extensions = {\n        \"3ds\",\n        \"amc\",\n        \"aoa\",\n        \"asf\",\n        \"bvh\",\n        \"c3d\",\n        \"dae\",\n        \"dxf\",\n        \"fbx\",\n        \"htr\",\n        \"mcd\",\n        \"obj\",\n        \"trc\",\n    }\n\n    label = \"Load FBX mesh\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    tool_type = \"SurfaceFBXMesh\"\n\n    def load(self, context, name, namespace, data):\n        # Fallback to folder name when namespace is None\n        if namespace is None:\n            namespace = context[\"folder\"][\"name\"]\n\n        # Create the Loader with the filename path set\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp, \"Create tool\"):\n            path = self.filepath_from_context(context)\n\n            args = (-32768, -32768)\n            tool = comp.AddTool(self.tool_type, *args)\n            tool[\"ImportFile\"] = path\n\n            imprint_container(\n                tool,\n                name=name,\n                namespace=namespace,\n                context=context,\n                loader=self.__class__.__name__,\n            )\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        \"\"\"Update path\"\"\"\n\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        repre_entity = context[\"representation\"]\n        path = get_representation_path(repre_entity)\n\n        with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n            tool[\"ImportFile\"] = path\n\n            # Update the imprinted representation\n            tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n\n    def remove(self, container):\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        with comp_lock_and_undo_chunk(comp, \"Remove tool\"):\n            tool.Delete()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_fbx.html#client.ayon_fusion.plugins.load.load_fbx.FusionLoadFBXMesh.update","title":"<code>update(container, context)</code>","text":"<p>Update path</p> Source code in <code>client/ayon_fusion/plugins/load/load_fbx.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update path\"\"\"\n\n    tool = container[\"_tool\"]\n    assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n    comp = tool.Comp()\n\n    repre_entity = context[\"representation\"]\n    path = get_representation_path(repre_entity)\n\n    with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n        tool[\"ImportFile\"] = path\n\n        # Update the imprinted representation\n        tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html","title":"load_sequence","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.FusionLoadSequence","title":"<code>FusionLoadSequence</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load image sequence into Fusion</p> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>class FusionLoadSequence(load.LoaderPlugin):\n    \"\"\"Load image sequence into Fusion\"\"\"\n\n    product_types = {\n        \"imagesequence\",\n        \"review\",\n        \"render\",\n        \"plate\",\n        \"image\",\n        \"online\",\n    }\n    representations = {\"*\"}\n    extensions = set(\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS.union(VIDEO_EXTENSIONS)\n    )\n\n    label = \"Load sequence\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n        # Fallback to folder name when namespace is None\n        if namespace is None:\n            namespace = context[\"folder\"][\"name\"]\n\n        # Use the first file for now\n        path = self.filepath_from_context(context)\n\n        # Create the Loader with the filename path set\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp, \"Create Loader\"):\n            args = (-32768, -32768)\n            tool = comp.AddTool(\"Loader\", *args)\n            tool[\"Clip\"] = comp.ReverseMapPath(path)\n            tool.SetAttrs({\"TOOLB_NameSet\": True, \"TOOLS_Name\": name})\n\n            # Set global in point to start frame (if in version.data)\n            start = self._get_start(context[\"version\"], tool)\n            loader_shift(tool, start, relative=False)\n\n            imprint_container(\n                tool,\n                name=name,\n                namespace=namespace,\n                context=context,\n                loader=self.__class__.__name__,\n            )\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        \"\"\"Update the Loader's path\n\n        Fusion automatically tries to reset some variables when changing\n        the loader's path to a new file. These automatic changes are to its\n        inputs:\n            - ClipTimeStart: Fusion reset to 0 if duration changes\n              - We keep the trim in as close as possible to the previous value.\n                When there are less frames then the amount of trim we reduce\n                it accordingly.\n\n            - ClipTimeEnd: Fusion reset to 0 if duration changes\n              - We keep the trim out as close as possible to the previous value\n                within new amount of frames after trim in (ClipTimeStart) has\n                been set.\n\n            - GlobalIn: Fusion reset to comp's global in if duration changes\n              - We change it to the \"frameStart\"\n\n            - GlobalEnd: Fusion resets to globalIn + length if duration changes\n              - We do the same like Fusion - allow fusion to take control.\n\n            - HoldFirstFrame: Fusion resets this to 0\n              - We preserve the value.\n\n            - HoldLastFrame: Fusion resets this to 0\n              - We preserve the value.\n\n            - Reverse: Fusion resets to disabled if \"Loop\" is not enabled.\n              - We preserve the value.\n\n            - Depth: Fusion resets to \"Format\"\n              - We preserve the value.\n\n            - KeyCode: Fusion resets to \"\"\n              - We preserve the value.\n\n            - TimeCodeOffset: Fusion resets to 0\n              - We preserve the value.\n\n        \"\"\"\n\n        tool = container[\"_tool\"]\n        assert tool.ID == \"Loader\", \"Must be Loader\"\n        comp = tool.Comp()\n\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n\n        # Get start frame from version data\n        start = self._get_start(context[\"version\"], tool)\n\n        with comp_lock_and_undo_chunk(comp, \"Update Loader\"):\n            # Update the loader's path whilst preserving some values\n            with preserve_trim(tool, log=self.log):\n                with preserve_inputs(\n                    tool,\n                    inputs=(\n                        \"HoldFirstFrame\",\n                        \"HoldLastFrame\",\n                        \"Reverse\",\n                        \"Depth\",\n                        \"KeyCode\",\n                        \"TimeCodeOffset\",\n                    ),\n                ):\n                    tool[\"Clip\"] = comp.ReverseMapPath(path)\n                    tool.SetAttrs(\n                        {\n                            \"TOOLB_NameSet\": True,\n                            \"TOOLS_Name\": repre_entity[\"context\"][\"product\"][\n                                \"name\"\n                            ],\n                        }\n                    )\n\n            # Set the global in to the start frame of the sequence\n            global_in_changed = loader_shift(tool, start, relative=False)\n            if global_in_changed:\n                # Log this change to the user\n                self.log.debug(\n                    \"Changed '%s' global in: %d\" % (tool.Name, start)\n                )\n\n            # Update the imprinted representation\n            tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n\n    def remove(self, container):\n        tool = container[\"_tool\"]\n        assert tool.ID == \"Loader\", \"Must be Loader\"\n        comp = tool.Comp()\n\n        with comp_lock_and_undo_chunk(comp, \"Remove Loader\"):\n            tool.Delete()\n\n    def _get_start(self, version_entity, tool):\n        \"\"\"Return real start frame of published files (incl. handles)\"\"\"\n        attributes = version_entity[\"attrib\"]\n\n        # Get start frame directly with handle if it's in data\n        start = attributes.get(\"frameStartHandle\")\n        if start is not None:\n            return start\n\n        # Get frame start without handles\n        start = attributes.get(\"frameStart\")\n        if start is None:\n            self.log.warning(\n                \"Missing start frame for version \"\n                \"assuming starts at frame 0 for: \"\n                \"{}\".format(tool.Name)\n            )\n            return 0\n\n        # Use `handleStart` if the data is available\n        handle_start = attributes.get(\"handleStart\")\n        if handle_start:\n            start -= handle_start\n\n        return start\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.FusionLoadSequence.update","title":"<code>update(container, context)</code>","text":"<p>Update the Loader's path</p> <p>Fusion automatically tries to reset some variables when changing the loader's path to a new file. These automatic changes are to its inputs:     - ClipTimeStart: Fusion reset to 0 if duration changes       - We keep the trim in as close as possible to the previous value.         When there are less frames then the amount of trim we reduce         it accordingly.</p> <pre><code>- ClipTimeEnd: Fusion reset to 0 if duration changes\n  - We keep the trim out as close as possible to the previous value\n    within new amount of frames after trim in (ClipTimeStart) has\n    been set.\n\n- GlobalIn: Fusion reset to comp's global in if duration changes\n  - We change it to the \"frameStart\"\n\n- GlobalEnd: Fusion resets to globalIn + length if duration changes\n  - We do the same like Fusion - allow fusion to take control.\n\n- HoldFirstFrame: Fusion resets this to 0\n  - We preserve the value.\n\n- HoldLastFrame: Fusion resets this to 0\n  - We preserve the value.\n\n- Reverse: Fusion resets to disabled if \"Loop\" is not enabled.\n  - We preserve the value.\n\n- Depth: Fusion resets to \"Format\"\n  - We preserve the value.\n\n- KeyCode: Fusion resets to \"\"\n  - We preserve the value.\n\n- TimeCodeOffset: Fusion resets to 0\n  - We preserve the value.\n</code></pre> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update the Loader's path\n\n    Fusion automatically tries to reset some variables when changing\n    the loader's path to a new file. These automatic changes are to its\n    inputs:\n        - ClipTimeStart: Fusion reset to 0 if duration changes\n          - We keep the trim in as close as possible to the previous value.\n            When there are less frames then the amount of trim we reduce\n            it accordingly.\n\n        - ClipTimeEnd: Fusion reset to 0 if duration changes\n          - We keep the trim out as close as possible to the previous value\n            within new amount of frames after trim in (ClipTimeStart) has\n            been set.\n\n        - GlobalIn: Fusion reset to comp's global in if duration changes\n          - We change it to the \"frameStart\"\n\n        - GlobalEnd: Fusion resets to globalIn + length if duration changes\n          - We do the same like Fusion - allow fusion to take control.\n\n        - HoldFirstFrame: Fusion resets this to 0\n          - We preserve the value.\n\n        - HoldLastFrame: Fusion resets this to 0\n          - We preserve the value.\n\n        - Reverse: Fusion resets to disabled if \"Loop\" is not enabled.\n          - We preserve the value.\n\n        - Depth: Fusion resets to \"Format\"\n          - We preserve the value.\n\n        - KeyCode: Fusion resets to \"\"\n          - We preserve the value.\n\n        - TimeCodeOffset: Fusion resets to 0\n          - We preserve the value.\n\n    \"\"\"\n\n    tool = container[\"_tool\"]\n    assert tool.ID == \"Loader\", \"Must be Loader\"\n    comp = tool.Comp()\n\n    repre_entity = context[\"representation\"]\n    path = self.filepath_from_context(context)\n\n    # Get start frame from version data\n    start = self._get_start(context[\"version\"], tool)\n\n    with comp_lock_and_undo_chunk(comp, \"Update Loader\"):\n        # Update the loader's path whilst preserving some values\n        with preserve_trim(tool, log=self.log):\n            with preserve_inputs(\n                tool,\n                inputs=(\n                    \"HoldFirstFrame\",\n                    \"HoldLastFrame\",\n                    \"Reverse\",\n                    \"Depth\",\n                    \"KeyCode\",\n                    \"TimeCodeOffset\",\n                ),\n            ):\n                tool[\"Clip\"] = comp.ReverseMapPath(path)\n                tool.SetAttrs(\n                    {\n                        \"TOOLB_NameSet\": True,\n                        \"TOOLS_Name\": repre_entity[\"context\"][\"product\"][\n                            \"name\"\n                        ],\n                    }\n                )\n\n        # Set the global in to the start frame of the sequence\n        global_in_changed = loader_shift(tool, start, relative=False)\n        if global_in_changed:\n            # Log this change to the user\n            self.log.debug(\n                \"Changed '%s' global in: %d\" % (tool.Name, start)\n            )\n\n        # Update the imprinted representation\n        tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.loader_shift","title":"<code>loader_shift(loader, frame, relative=True)</code>","text":"<p>Shift global in time by i preserving duration</p> <p>This moves the loader by i frames preserving global duration. When relative is False it will shift the global in to the start frame.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>tool</code> <p>The fusion loader tool.</p> required <code>frame</code> <code>int</code> <p>The amount of frames to move.</p> required <code>relative</code> <code>bool</code> <p>When True the shift is relative, else the shift will change the global in to frame.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The resulting relative frame change (how much it moved)</p> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>def loader_shift(loader, frame, relative=True):\n    \"\"\"Shift global in time by i preserving duration\n\n    This moves the loader by i frames preserving global duration. When relative\n    is False it will shift the global in to the start frame.\n\n    Args:\n        loader (tool): The fusion loader tool.\n        frame (int): The amount of frames to move.\n        relative (bool): When True the shift is relative, else the shift will\n            change the global in to frame.\n\n    Returns:\n        int: The resulting relative frame change (how much it moved)\n\n    \"\"\"\n    comp = loader.Comp()\n    time = comp.TIME_UNDEFINED\n\n    old_in = loader[\"GlobalIn\"][time]\n    old_out = loader[\"GlobalOut\"][time]\n\n    if relative:\n        shift = frame\n    else:\n        shift = frame - old_in\n\n    if not shift:\n        return 0\n\n    # Shifting global in will try to automatically compensate for the change\n    # in the \"ClipTimeStart\" and \"HoldFirstFrame\" inputs, so we preserve those\n    # input values to \"just shift\" the clip\n    with preserve_inputs(\n        loader,\n        inputs=[\n            \"ClipTimeStart\",\n            \"ClipTimeEnd\",\n            \"HoldFirstFrame\",\n            \"HoldLastFrame\",\n        ],\n    ):\n        # GlobalIn cannot be set past GlobalOut or vice versa\n        # so we must apply them in the order of the shift.\n        if shift &gt; 0:\n            loader[\"GlobalOut\"][time] = old_out + shift\n            loader[\"GlobalIn\"][time] = old_in + shift\n        else:\n            loader[\"GlobalIn\"][time] = old_in + shift\n            loader[\"GlobalOut\"][time] = old_out + shift\n\n    return int(shift)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.preserve_inputs","title":"<code>preserve_inputs(tool, inputs)</code>","text":"<p>Preserve the tool's inputs after context</p> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>@contextlib.contextmanager\ndef preserve_inputs(tool, inputs):\n    \"\"\"Preserve the tool's inputs after context\"\"\"\n\n    comp = tool.Comp()\n\n    values = {}\n    for name in inputs:\n        tool_input = getattr(tool, name)\n        value = tool_input[comp.TIME_UNDEFINED]\n        values[name] = value\n\n    try:\n        yield\n    finally:\n        for name, value in values.items():\n            tool_input = getattr(tool, name)\n            tool_input[comp.TIME_UNDEFINED] = value\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.preserve_trim","title":"<code>preserve_trim(loader, log=None)</code>","text":"<p>Preserve the relative trim of the Loader tool.</p> <p>This tries to preserve the loader's trim (trim in and trim out) after the context by reapplying the \"amount\" it trims on the clip's length at start and end.</p> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>@contextlib.contextmanager\ndef preserve_trim(loader, log=None):\n    \"\"\"Preserve the relative trim of the Loader tool.\n\n    This tries to preserve the loader's trim (trim in and trim out) after\n    the context by reapplying the \"amount\" it trims on the clip's length at\n    start and end.\n\n    \"\"\"\n\n    # Get original trim as amount of \"trimming\" from length\n    time = loader.Comp().TIME_UNDEFINED\n    length = loader.GetAttrs()[\"TOOLIT_Clip_Length\"][1] - 1\n    trim_from_start = loader[\"ClipTimeStart\"][time]\n    trim_from_end = length - loader[\"ClipTimeEnd\"][time]\n\n    try:\n        yield\n    finally:\n        length = loader.GetAttrs()[\"TOOLIT_Clip_Length\"][1] - 1\n        if trim_from_start &gt; length:\n            trim_from_start = length\n            if log:\n                log.warning(\n                    \"Reducing trim in to %d \"\n                    \"(because of less frames)\" % trim_from_start\n                )\n\n        remainder = length - trim_from_start\n        if trim_from_end &gt; remainder:\n            trim_from_end = remainder\n            if log:\n                log.warning(\n                    \"Reducing trim in to %d \"\n                    \"(because of less frames)\" % trim_from_end\n                )\n\n        loader[\"ClipTimeStart\"][time] = trim_from_start\n        loader[\"ClipTimeEnd\"][time] = length - trim_from_end\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_usd.html","title":"load_usd","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/load_usd.html#client.ayon_fusion.plugins.load.load_usd.FusionLoadUSD","title":"<code>FusionLoadUSD</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load USD into Fusion</p> <p>Support for USD was added since Fusion 18.5</p> Source code in <code>client/ayon_fusion/plugins/load/load_usd.py</code> <pre><code>class FusionLoadUSD(load.LoaderPlugin):\n    \"\"\"Load USD into Fusion\n\n    Support for USD was added since Fusion 18.5\n    \"\"\"\n\n    product_types = {\"*\"}\n    representations = {\"*\"}\n    extensions = {\"usd\", \"usda\", \"usdz\"}\n\n    label = \"Load USD\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    tool_type = \"uLoader\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(FusionLoadUSD, cls).apply_settings(project_settings)\n        if cls.enabled:\n            # Enable only in Fusion 18.5+\n            fusion = get_fusion_module()\n            version = fusion.GetVersion()\n            major = version[1]\n            minor = version[2]\n            is_usd_supported = (major, minor) &gt;= (18, 5)\n            cls.enabled = is_usd_supported\n\n    def load(self, context, name, namespace, data):\n        # Fallback to folder name when namespace is None\n        if namespace is None:\n            namespace = context[\"folder\"][\"name\"]\n\n        # Create the Loader with the filename path set\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp, \"Create tool\"):\n\n            path = self.fname\n\n            args = (-32768, -32768)\n            tool = comp.AddTool(self.tool_type, *args)\n            tool[\"Filename\"] = path\n\n            imprint_container(tool,\n                              name=name,\n                              namespace=namespace,\n                              context=context,\n                              loader=self.__class__.__name__)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        repre_entity = context[\"representation\"]\n        path = get_representation_path(repre_entity)\n\n        with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n            tool[\"Filename\"] = path\n\n            # Update the imprinted representation\n            tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n\n    def remove(self, container):\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        with comp_lock_and_undo_chunk(comp, \"Remove tool\"):\n            tool.Delete()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_workfile.html","title":"load_workfile","text":"<p>Import workfiles into your current comp. As all imported nodes are free floating and will probably be changed there is no update or reload function added for this plugin</p>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_workfile.html#client.ayon_fusion.plugins.load.load_workfile.FusionLoadWorkfile","title":"<code>FusionLoadWorkfile</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load the content of a workfile into Fusion</p> Source code in <code>client/ayon_fusion/plugins/load/load_workfile.py</code> <pre><code>class FusionLoadWorkfile(load.LoaderPlugin):\n    \"\"\"Load the content of a workfile into Fusion\"\"\"\n\n    product_types = {\"workfile\"}\n    representations = {\"*\"}\n    extensions = {\"comp\"}\n\n    label = \"Load Workfile\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n        # Get needed elements\n        bmd = get_bmd_library()\n        comp = get_current_comp()\n        path = self.filepath_from_context(context)\n\n        # Paste the content of the file into the current comp\n        comp.Paste(bmd.readfile(path))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp.html","title":"collect_comp","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp.html#client.ayon_fusion.plugins.publish.collect_comp.CollectCurrentCompFusion","title":"<code>CollectCurrentCompFusion</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect current comp</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp.py</code> <pre><code>class CollectCurrentCompFusion(pyblish.api.ContextPlugin):\n    \"\"\"Collect current comp\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.4\n    label = \"Collect Current Comp\"\n    hosts = [\"fusion\"]\n\n    def process(self, context):\n        \"\"\"Collect all image sequence tools\"\"\"\n\n        current_comp = get_current_comp()\n        assert current_comp, \"Must have active Fusion composition\"\n        context.data[\"currentComp\"] = current_comp\n\n        # Store path to current file\n        filepath = current_comp.GetAttrs().get(\"COMPS_FileName\", \"\")\n        context.data['currentFile'] = filepath\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp.html#client.ayon_fusion.plugins.publish.collect_comp.CollectCurrentCompFusion.process","title":"<code>process(context)</code>","text":"<p>Collect all image sequence tools</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp.py</code> <pre><code>def process(self, context):\n    \"\"\"Collect all image sequence tools\"\"\"\n\n    current_comp = get_current_comp()\n    assert current_comp, \"Must have active Fusion composition\"\n    context.data[\"currentComp\"] = current_comp\n\n    # Store path to current file\n    filepath = current_comp.GetAttrs().get(\"COMPS_FileName\", \"\")\n    context.data['currentFile'] = filepath\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp_frame_range.html","title":"collect_comp_frame_range","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp_frame_range.html#client.ayon_fusion.plugins.publish.collect_comp_frame_range.CollectFusionCompFrameRanges","title":"<code>CollectFusionCompFrameRanges</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect current comp</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp_frame_range.py</code> <pre><code>class CollectFusionCompFrameRanges(pyblish.api.ContextPlugin):\n    \"\"\"Collect current comp\"\"\"\n\n    # We run this after CollectorOrder - 0.1 otherwise it gets\n    # overridden by global plug-in `CollectContextEntities`\n    order = pyblish.api.CollectorOrder - 0.05\n    label = \"Collect Comp Frame Ranges\"\n    hosts = [\"fusion\"]\n\n    def process(self, context):\n        \"\"\"Collect all image sequence tools\"\"\"\n\n        comp = context.data[\"currentComp\"]\n\n        # Store comp render ranges\n        start, end, global_start, global_end = get_comp_render_range(comp)\n\n        context.data.update({\n            \"renderFrameStart\": int(start),\n            \"renderFrameEnd\": int(end),\n            \"compFrameStart\": int(global_start),\n            \"compFrameEnd\": int(global_end)\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp_frame_range.html#client.ayon_fusion.plugins.publish.collect_comp_frame_range.CollectFusionCompFrameRanges.process","title":"<code>process(context)</code>","text":"<p>Collect all image sequence tools</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp_frame_range.py</code> <pre><code>def process(self, context):\n    \"\"\"Collect all image sequence tools\"\"\"\n\n    comp = context.data[\"currentComp\"]\n\n    # Store comp render ranges\n    start, end, global_start, global_end = get_comp_render_range(comp)\n\n    context.data.update({\n        \"renderFrameStart\": int(start),\n        \"renderFrameEnd\": int(end),\n        \"compFrameStart\": int(global_start),\n        \"compFrameEnd\": int(global_end)\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp_frame_range.html#client.ayon_fusion.plugins.publish.collect_comp_frame_range.get_comp_render_range","title":"<code>get_comp_render_range(comp)</code>","text":"<p>Return comp's start-end render range and global start-end range.</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp_frame_range.py</code> <pre><code>def get_comp_render_range(comp):\n    \"\"\"Return comp's start-end render range and global start-end range.\"\"\"\n    comp_attrs = comp.GetAttrs()\n    start = comp_attrs[\"COMPN_RenderStart\"]\n    end = comp_attrs[\"COMPN_RenderEnd\"]\n    global_start = comp_attrs[\"COMPN_GlobalStart\"]\n    global_end = comp_attrs[\"COMPN_GlobalEnd\"]\n\n    # Whenever render ranges are undefined fall back\n    # to the comp's global start and end\n    if start == -1000000000:\n        start = global_start\n    if end == -1000000000:\n        end = global_end\n\n    return start, end, global_start, global_end\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_inputs.html","title":"collect_inputs","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_inputs.html#client.ayon_fusion.plugins.publish.collect_inputs.CollectUpstreamInputs","title":"<code>CollectUpstreamInputs</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect source input containers used for this publish.</p> <p>This will include <code>inputs</code> data of which loaded publishes were used in the generation of this publish. This leaves an upstream trace to what was used as input.</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_inputs.py</code> <pre><code>class CollectUpstreamInputs(pyblish.api.InstancePlugin):\n    \"\"\"Collect source input containers used for this publish.\n\n    This will include `inputs` data of which loaded publishes were used in the\n    generation of this publish. This leaves an upstream trace to what was used\n    as input.\n\n    \"\"\"\n\n    label = \"Collect Inputs\"\n    order = pyblish.api.CollectorOrder + 0.2\n    hosts = [\"fusion\"]\n    families = [\"render\", \"image\"]\n\n    def process(self, instance):\n\n        # Get all upstream and include itself\n        if not any(instance[:]):\n            self.log.debug(\"No tool found in instance, skipping..\")\n            return\n\n        tool = instance[0]\n        nodes = list(iter_upstream(tool))\n        nodes.append(tool)\n\n        # Collect containers for the given set of nodes\n        containers = collect_input_containers(nodes)\n\n        inputs = [c[\"representation\"] for c in containers]\n        instance.data[\"inputRepresentations\"] = inputs\n        self.log.debug(\"Collected inputs: %s\" % inputs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_inputs.html#client.ayon_fusion.plugins.publish.collect_inputs.collect_input_containers","title":"<code>collect_input_containers(tools)</code>","text":"<p>Collect containers that contain any of the node in <code>nodes</code>.</p> <p>This will return any loaded Avalon container that contains at least one of the nodes. As such, the Avalon container is an input for it. Or in short, there are member nodes of that container.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Input avalon containers</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_inputs.py</code> <pre><code>def collect_input_containers(tools):\n    \"\"\"Collect containers that contain any of the node in `nodes`.\n\n    This will return any loaded Avalon container that contains at least one of\n    the nodes. As such, the Avalon container is an input for it. Or in short,\n    there are member nodes of that container.\n\n    Returns:\n        list: Input avalon containers\n\n    \"\"\"\n\n    # Lookup by node ids\n    lookup = frozenset([tool.Name for tool in tools])\n\n    containers = []\n    host = registered_host()\n    for container in host.ls():\n\n        name = container[\"_tool\"].Name\n\n        # We currently assume no \"groups\" as containers but just single tools\n        # like a single \"Loader\" operator. As such we just check whether the\n        # Loader is part of the processing queue.\n        if name in lookup:\n            containers.append(container)\n\n    return containers\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_inputs.html#client.ayon_fusion.plugins.publish.collect_inputs.iter_upstream","title":"<code>iter_upstream(tool)</code>","text":"<p>Yields all upstream inputs for the current tool.</p> <p>Yields:</p> Name Type Description <code>tool</code> <p>The input tools.</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_inputs.py</code> <pre><code>def iter_upstream(tool):\n    \"\"\"Yields all upstream inputs for the current tool.\n\n    Yields:\n        tool: The input tools.\n\n    \"\"\"\n\n    def get_connected_input_tools(tool):\n        \"\"\"Helper function that returns connected input tools for a tool.\"\"\"\n        inputs = []\n\n        # Filter only to actual types that will have sensible upstream\n        # connections. So we ignore just \"Number\" inputs as they can be\n        # many to iterate, slowing things down quite a bit - and in practice\n        # they don't have upstream connections.\n        VALID_INPUT_TYPES = ['Image', 'Particles', 'Mask', 'DataType3D']\n        for type_ in VALID_INPUT_TYPES:\n            for input_ in tool.GetInputList(type_).values():\n                output = input_.GetConnectedOutput()\n                if output:\n                    input_tool = output.GetTool()\n                    inputs.append(input_tool)\n\n        return inputs\n\n    # Initialize process queue with the node's inputs itself\n    queue = get_connected_input_tools(tool)\n\n    # We keep track of which node names we have processed so far, to ensure we\n    # don't process the same hierarchy again. We are not pushing the tool\n    # itself into the set as that doesn't correctly recognize the same tool.\n    # Since tool names are unique in a comp in Fusion we rely on that.\n    collected = set(tool.Name for tool in queue)\n\n    # Traverse upstream references for all nodes and yield them as we\n    # process the queue.\n    while queue:\n        upstream_tool = queue.pop()\n        yield upstream_tool\n\n        # Find upstream tools that are not collected yet.\n        upstream_inputs = get_connected_input_tools(upstream_tool)\n        upstream_inputs = [t for t in upstream_inputs if\n                           t.Name not in collected]\n\n        queue.extend(upstream_inputs)\n        collected.update(tool.Name for tool in upstream_inputs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_instances.html","title":"collect_instances","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_instances.html#client.ayon_fusion.plugins.publish.collect_instances.CollectInstanceData","title":"<code>CollectInstanceData</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Fusion saver instances</p> <p>This additionally stores the Comp start and end render range in the current context's data as \"frameStart\" and \"frameEnd\".</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_instances.py</code> <pre><code>class CollectInstanceData(pyblish.api.InstancePlugin):\n    \"\"\"Collect Fusion saver instances\n\n    This additionally stores the Comp start and end render range in the\n    current context's data as \"frameStart\" and \"frameEnd\".\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder\n    label = \"Collect Instances Data\"\n    hosts = [\"fusion\"]\n\n    def process(self, instance):\n        \"\"\"Collect all image sequence tools\"\"\"\n\n        context = instance.context\n\n        # Include creator attributes directly as instance data\n        creator_attributes = instance.data[\"creator_attributes\"]\n        instance.data.update(creator_attributes)\n\n        frame_range_source = creator_attributes.get(\"frame_range_source\")\n        instance.data[\"frame_range_source\"] = frame_range_source\n\n        # get folder frame ranges to all instances\n        # render product type instances `current_context` render target\n        start = context.data[\"frameStart\"]\n        end = context.data[\"frameEnd\"]\n        handle_start = context.data[\"handleStart\"]\n        handle_end = context.data[\"handleEnd\"]\n        start_with_handle = start - handle_start\n        end_with_handle = end + handle_end\n\n        # conditions for render product type instances\n        if frame_range_source == \"render_range\":\n            # set comp render frame ranges\n            start = context.data[\"renderFrameStart\"]\n            end = context.data[\"renderFrameEnd\"]\n            handle_start = 0\n            handle_end = 0\n            start_with_handle = start\n            end_with_handle = end\n\n        if frame_range_source == \"comp_range\":\n            comp_start = context.data[\"compFrameStart\"]\n            comp_end = context.data[\"compFrameEnd\"]\n            render_start = context.data[\"renderFrameStart\"]\n            render_end = context.data[\"renderFrameEnd\"]\n            # set comp frame ranges\n            start = render_start\n            end = render_end\n            handle_start = render_start - comp_start\n            handle_end = comp_end - render_end\n            start_with_handle = comp_start\n            end_with_handle = comp_end\n\n        if frame_range_source == \"custom_range\":\n            start = int(instance.data[\"custom_frameStart\"])\n            end = int(instance.data[\"custom_frameEnd\"])\n            handle_start = int(instance.data[\"custom_handleStart\"])\n            handle_end = int(instance.data[\"custom_handleEnd\"])\n            start_with_handle = start - handle_start\n            end_with_handle = end + handle_end\n\n        frame = instance.data[\"creator_attributes\"].get(\"frame\")\n        # explicitly publishing only single frame\n        if frame is not None:\n            frame = int(frame)\n\n            start = frame\n            end = frame\n            handle_start = 0\n            handle_end = 0\n            start_with_handle = frame\n            end_with_handle = frame\n\n        # Include start and end render frame in label\n        product_name = instance.data[\"productName\"]\n        label = (\n            \"{product_name} ({start}-{end}) [{handle_start}-{handle_end}]\"\n        ).format(\n            product_name=product_name,\n            start=int(start),\n            end=int(end),\n            handle_start=int(handle_start),\n            handle_end=int(handle_end)\n        )\n\n        instance.data.update({\n            \"label\": label,\n\n            # todo: Allow custom frame range per instance\n            \"frameStart\": start,\n            \"frameEnd\": end,\n            \"frameStartHandle\": start_with_handle,\n            \"frameEndHandle\": end_with_handle,\n            \"handleStart\": handle_start,\n            \"handleEnd\": handle_end,\n            \"fps\": context.data[\"fps\"],\n        })\n\n        # Add review family if the instance is marked as 'review'\n        # This could be done through a 'review' Creator attribute.\n        if instance.data.get(\"review\", False):\n            self.log.debug(\"Adding review family..\")\n            instance.data[\"families\"].append(\"review\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_instances.html#client.ayon_fusion.plugins.publish.collect_instances.CollectInstanceData.process","title":"<code>process(instance)</code>","text":"<p>Collect all image sequence tools</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_instances.py</code> <pre><code>def process(self, instance):\n    \"\"\"Collect all image sequence tools\"\"\"\n\n    context = instance.context\n\n    # Include creator attributes directly as instance data\n    creator_attributes = instance.data[\"creator_attributes\"]\n    instance.data.update(creator_attributes)\n\n    frame_range_source = creator_attributes.get(\"frame_range_source\")\n    instance.data[\"frame_range_source\"] = frame_range_source\n\n    # get folder frame ranges to all instances\n    # render product type instances `current_context` render target\n    start = context.data[\"frameStart\"]\n    end = context.data[\"frameEnd\"]\n    handle_start = context.data[\"handleStart\"]\n    handle_end = context.data[\"handleEnd\"]\n    start_with_handle = start - handle_start\n    end_with_handle = end + handle_end\n\n    # conditions for render product type instances\n    if frame_range_source == \"render_range\":\n        # set comp render frame ranges\n        start = context.data[\"renderFrameStart\"]\n        end = context.data[\"renderFrameEnd\"]\n        handle_start = 0\n        handle_end = 0\n        start_with_handle = start\n        end_with_handle = end\n\n    if frame_range_source == \"comp_range\":\n        comp_start = context.data[\"compFrameStart\"]\n        comp_end = context.data[\"compFrameEnd\"]\n        render_start = context.data[\"renderFrameStart\"]\n        render_end = context.data[\"renderFrameEnd\"]\n        # set comp frame ranges\n        start = render_start\n        end = render_end\n        handle_start = render_start - comp_start\n        handle_end = comp_end - render_end\n        start_with_handle = comp_start\n        end_with_handle = comp_end\n\n    if frame_range_source == \"custom_range\":\n        start = int(instance.data[\"custom_frameStart\"])\n        end = int(instance.data[\"custom_frameEnd\"])\n        handle_start = int(instance.data[\"custom_handleStart\"])\n        handle_end = int(instance.data[\"custom_handleEnd\"])\n        start_with_handle = start - handle_start\n        end_with_handle = end + handle_end\n\n    frame = instance.data[\"creator_attributes\"].get(\"frame\")\n    # explicitly publishing only single frame\n    if frame is not None:\n        frame = int(frame)\n\n        start = frame\n        end = frame\n        handle_start = 0\n        handle_end = 0\n        start_with_handle = frame\n        end_with_handle = frame\n\n    # Include start and end render frame in label\n    product_name = instance.data[\"productName\"]\n    label = (\n        \"{product_name} ({start}-{end}) [{handle_start}-{handle_end}]\"\n    ).format(\n        product_name=product_name,\n        start=int(start),\n        end=int(end),\n        handle_start=int(handle_start),\n        handle_end=int(handle_end)\n    )\n\n    instance.data.update({\n        \"label\": label,\n\n        # todo: Allow custom frame range per instance\n        \"frameStart\": start,\n        \"frameEnd\": end,\n        \"frameStartHandle\": start_with_handle,\n        \"frameEndHandle\": end_with_handle,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"fps\": context.data[\"fps\"],\n    })\n\n    # Add review family if the instance is marked as 'review'\n    # This could be done through a 'review' Creator attribute.\n    if instance.data.get(\"review\", False):\n        self.log.debug(\"Adding review family..\")\n        instance.data[\"families\"].append(\"review\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_render.html","title":"collect_render","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_render.html#client.ayon_fusion.plugins.publish.collect_render.CollectFusionRender","title":"<code>CollectFusionRender</code>","text":"<p>               Bases: <code>AbstractCollectRender</code>, <code>ColormanagedPyblishPluginMixin</code></p> Source code in <code>client/ayon_fusion/plugins/publish/collect_render.py</code> <pre><code>class CollectFusionRender(\n    publish.AbstractCollectRender,\n    publish.ColormanagedPyblishPluginMixin\n):\n\n    order = pyblish.api.CollectorOrder + 0.09\n    label = \"Collect Fusion Render\"\n    hosts = [\"fusion\"]\n\n    def get_instances(self, context):\n\n        comp = context.data.get(\"currentComp\")\n        comp_frame_format_prefs = comp.GetPrefs(\"Comp.FrameFormat\")\n        aspect_x = comp_frame_format_prefs[\"AspectX\"]\n        aspect_y = comp_frame_format_prefs[\"AspectY\"]\n\n        current_file = context.data[\"currentFile\"]\n        version = context.data.get(\"version\")\n        project_entity = context.data[\"projectEntity\"]\n\n        instances = []\n        for inst in context:\n            if not inst.data.get(\"active\", True):\n                continue\n\n            product_type = inst.data[\"productType\"]\n            if product_type not in [\"render\", \"image\"]:\n                continue\n\n            # Get resolution from tool if we can\n            tool = inst.data[\"transientData\"][\"tool\"]\n            try:\n                width, height = get_tool_resolution(\n                    tool, frame=inst.data[\"frameStart\"])\n            except ValueError:\n                self.log.debug(\n                    f\"Unable to get resolution from tool: {tool}. \"\n                    \"Falling back to comp frame format resolution \"\n                    \"preferences.\")\n                width = comp_frame_format_prefs.get(\"Width\")\n                height = comp_frame_format_prefs.get(\"Height\")\n\n            instance_families = inst.data.get(\"families\", [])\n            product_name = inst.data[\"productName\"]\n            instance = FusionRenderInstance(\n                tool=inst.data[\"transientData\"][\"tool\"],\n                workfileComp=comp,\n                productType=product_type,\n                family=product_type,\n                families=instance_families,\n                version=version,\n                time=\"\",\n                source=current_file,\n                label=inst.data[\"label\"],\n                productName=product_name,\n                folderPath=inst.data[\"folderPath\"],\n                task=inst.data[\"task\"],\n                attachTo=False,\n                setMembers='',\n                publish=True,\n                name=product_name,\n                resolutionWidth=width,\n                resolutionHeight=height,\n                pixelAspect=aspect_x / aspect_y,\n                tileRendering=False,\n                tilesX=0,\n                tilesY=0,\n                review=\"review\" in instance_families,\n                frameStart=inst.data[\"frameStart\"],\n                frameEnd=inst.data[\"frameEnd\"],\n                handleStart=inst.data[\"handleStart\"],\n                handleEnd=inst.data[\"handleEnd\"],\n                frameStartHandle=inst.data[\"frameStartHandle\"],\n                frameEndHandle=inst.data[\"frameEndHandle\"],\n                frameStep=1,\n                fps=comp_frame_format_prefs.get(\"Rate\"),\n                app_version=comp.GetApp().Version,\n                publish_attributes=inst.data.get(\"publish_attributes\", {}),\n\n                # The source instance this render instance replaces\n                source_instance=inst\n            )\n\n            render_target = inst.data[\"creator_attributes\"][\"render_target\"]\n\n            # Add render target family\n            render_target_family = f\"render.{render_target}\"\n            if render_target_family not in instance.families:\n                instance.families.append(render_target_family)\n\n            # Add render target specific data\n            if render_target in {\"local\", \"frames\"}:\n                instance.projectEntity = project_entity\n\n            if render_target == \"farm\":\n                fam = \"render.farm\"\n                if fam not in instance.families:\n                    instance.families.append(fam)\n                instance.farm = True  # to skip integrate\n                if \"review\" in instance.families:\n                    # to skip ExtractReview locally\n                    instance.families.remove(\"review\")\n                instance.deadline = inst.data.get(\"deadline\")\n\n            instances.append(instance)\n\n        return instances\n\n    def post_collecting_action(self):\n        for instance in self._context:\n            if \"render.frames\" in instance.data.get(\"families\", []):\n                # adding representation data to the instance\n                self._update_for_frames(instance)\n\n    def get_expected_files(self, render_instance):\n        \"\"\"\n            Returns list of rendered files that should be created by\n            Deadline. These are not published directly, they are source\n            for later 'submit_publish_job'.\n\n        Args:\n            render_instance (RenderInstance): to pull anatomy and parts used\n                in url\n\n        Returns:\n            (list) of absolute urls to rendered file\n        \"\"\"\n        start = render_instance.frameStart - render_instance.handleStart\n        end = render_instance.frameEnd + render_instance.handleEnd\n\n        comp = render_instance.workfileComp\n        path = comp.MapPath(\n            render_instance.tool[\"Clip\"][\n                render_instance.workfileComp.TIME_UNDEFINED\n            ]\n        )\n        output_dir = os.path.dirname(path)\n        render_instance.outputDir = output_dir\n\n        basename = os.path.basename(path)\n\n        head, padding, ext = get_frame_path(basename)\n\n        expected_files = []\n        for frame in range(start, end + 1):\n            expected_files.append(\n                os.path.join(\n                    output_dir,\n                    f\"{head}{str(frame).zfill(padding)}{ext}\"\n                )\n            )\n\n        return expected_files\n\n    def _update_for_frames(self, instance):\n        \"\"\"Updating instance for render.frames family\n\n        Adding representation data to the instance. Also setting\n        colorspaceData to the representation based on file rules.\n        \"\"\"\n\n        expected_files = instance.data[\"expectedFiles\"]\n\n        start = instance.data[\"frameStart\"] - instance.data[\"handleStart\"]\n\n        path = expected_files[0]\n        basename = os.path.basename(path)\n        staging_dir = os.path.dirname(path)\n        _, padding, ext = get_frame_path(basename)\n\n        repre = {\n            \"name\": ext[1:],\n            \"ext\": ext[1:],\n            \"frameStart\": f\"%0{padding}d\" % start,\n            \"files\": [os.path.basename(f) for f in expected_files],\n            \"stagingDir\": staging_dir,\n        }\n\n        self.set_representation_colorspace(\n            representation=repre,\n            context=instance.context,\n        )\n\n        # review representation\n        if instance.data.get(\"review\", False):\n            repre[\"tags\"] = [\"review\"]\n\n        # add the repre to the instance\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n        instance.data[\"representations\"].append(repre)\n\n        return instance\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_render.html#client.ayon_fusion.plugins.publish.collect_render.CollectFusionRender.get_expected_files","title":"<code>get_expected_files(render_instance)</code>","text":"<pre><code>Returns list of rendered files that should be created by\nDeadline. These are not published directly, they are source\nfor later 'submit_publish_job'.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>render_instance</code> <code>RenderInstance</code> <p>to pull anatomy and parts used in url</p> required <p>Returns:</p> Type Description <p>(list) of absolute urls to rendered file</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_render.py</code> <pre><code>def get_expected_files(self, render_instance):\n    \"\"\"\n        Returns list of rendered files that should be created by\n        Deadline. These are not published directly, they are source\n        for later 'submit_publish_job'.\n\n    Args:\n        render_instance (RenderInstance): to pull anatomy and parts used\n            in url\n\n    Returns:\n        (list) of absolute urls to rendered file\n    \"\"\"\n    start = render_instance.frameStart - render_instance.handleStart\n    end = render_instance.frameEnd + render_instance.handleEnd\n\n    comp = render_instance.workfileComp\n    path = comp.MapPath(\n        render_instance.tool[\"Clip\"][\n            render_instance.workfileComp.TIME_UNDEFINED\n        ]\n    )\n    output_dir = os.path.dirname(path)\n    render_instance.outputDir = output_dir\n\n    basename = os.path.basename(path)\n\n    head, padding, ext = get_frame_path(basename)\n\n    expected_files = []\n    for frame in range(start, end + 1):\n        expected_files.append(\n            os.path.join(\n                output_dir,\n                f\"{head}{str(frame).zfill(padding)}{ext}\"\n            )\n        )\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_workfile.html#client.ayon_fusion.plugins.publish.collect_workfile.CollectFusionWorkfile","title":"<code>CollectFusionWorkfile</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Fusion workfile representation.</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_workfile.py</code> <pre><code>class CollectFusionWorkfile(pyblish.api.InstancePlugin):\n    \"\"\"Collect Fusion workfile representation.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.1\n    label = \"Collect Workfile\"\n    hosts = [\"fusion\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n\n        current_file = instance.context.data[\"currentFile\"]\n\n        folder, file = os.path.split(current_file)\n        filename, ext = os.path.splitext(file)\n\n        instance.data['representations'] = [{\n            'name': ext.lstrip(\".\"),\n            'ext': ext.lstrip(\".\"),\n            'files': file,\n            \"stagingDir\": folder,\n        }]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html","title":"extract_render_local","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html#client.ayon_fusion.plugins.publish.extract_render_local.FusionRenderLocal","title":"<code>FusionRenderLocal</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Render the current Fusion composition locally.</p> Source code in <code>client/ayon_fusion/plugins/publish/extract_render_local.py</code> <pre><code>class FusionRenderLocal(\n    pyblish.api.InstancePlugin,\n    publish.ColormanagedPyblishPluginMixin\n):\n    \"\"\"Render the current Fusion composition locally.\"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.2\n    label = \"Render Local\"\n    hosts = [\"fusion\"]\n    families = [\"render.local\"]\n    settings_category = \"fusion\"\n\n    is_rendered_key = \"_fusionrenderlocal_has_rendered\"\n\n    # Settings\n    suppress_dialogs = True\n\n    def process(self, instance):\n\n        # Start render\n        result = self.render(instance)\n        if result is False:\n            raise RuntimeError(f\"Comp render failed for {instance}\")\n\n        self._add_representation(instance)\n\n        # Log render status\n        self.log.info(\n            \"Rendered '{}' for folder '{}' under the task '{}'\".format(\n                instance.data[\"name\"],\n                instance.data[\"folderPath\"],\n                instance.data[\"task\"],\n            )\n        )\n\n    def render(self, instance):\n        \"\"\"Render instance.\n\n        We try to render the minimal amount of times by combining the instances\n        that have a matching frame range in one Fusion render. Then for the\n        batch of instances we store whether the render succeeded or failed.\n\n        \"\"\"\n\n        if self.is_rendered_key in instance.data:\n            # This instance was already processed in batch with another\n            # instance, so we just return the render result directly\n            self.log.debug(f\"Instance {instance} was already rendered\")\n            return instance.data[self.is_rendered_key]\n\n        instances_by_frame_range = self.get_render_instances_by_frame_range(\n            instance.context\n        )\n\n        # Render matching batch of instances that share the same frame range\n        frame_range = self.get_instance_render_frame_range(instance)\n        render_instances = instances_by_frame_range[frame_range]\n\n        # We initialize render state false to indicate it wasn't successful\n        # yet to keep track of whether Fusion succeeded. This is for cases\n        # where an error below this might cause the comp render result not\n        # to be stored for the instances of this batch\n        for render_instance in render_instances:\n            render_instance.data[self.is_rendered_key] = False\n\n        savers_to_render = [inst.data[\"tool\"] for inst in render_instances]\n        current_comp = instance.context.data[\"currentComp\"]\n        frame_start, frame_end = frame_range\n\n        self.log.info(\n            f\"Starting Fusion render frame range {frame_start}-{frame_end}\"\n        )\n        saver_names = \", \".join(saver.Name for saver in savers_to_render)\n        self.log.info(f\"Rendering tools: {saver_names}\")\n\n        with comp_lock_and_undo_chunk(current_comp):\n            with maintained_comp_range(current_comp):\n                with enabled_savers(current_comp, savers_to_render):\n                    render_kwargs = {\n                        \"Start\": frame_start,\n                        \"End\": frame_end,\n                        \"Wait\": True\n                    }\n                    if self.suppress_dialogs:\n                        render_kwargs[\"RenderFlags\"] = REQF_Quiet\n\n                    result = current_comp.Render(render_kwargs)\n\n        # Store the render state for all the rendered instances\n        for render_instance in render_instances:\n            render_instance.data[self.is_rendered_key] = bool(result)\n\n        return result\n\n    def _add_representation(self, instance):\n        \"\"\"Add representation to instance\"\"\"\n\n        expected_files = instance.data[\"expectedFiles\"]\n\n        start = instance.data[\"frameStart\"] - instance.data[\"handleStart\"]\n\n        path = expected_files[0]\n        _, padding, ext = get_frame_path(path)\n\n        staging_dir = os.path.dirname(path)\n\n        files = [os.path.basename(f) for f in expected_files]\n        if len(expected_files) == 1:\n            files = files[0]\n\n        repre = {\n            \"name\": ext[1:],\n            \"ext\": ext[1:],\n            \"frameStart\": f\"%0{padding}d\" % start,\n            \"files\": files,\n            \"stagingDir\": staging_dir,\n        }\n\n        self.set_representation_colorspace(\n            representation=repre,\n            context=instance.context,\n        )\n\n        # review representation\n        if instance.data.get(\"review\", False):\n            repre[\"tags\"] = [\"review\"]\n\n        # add the repre to the instance\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n        instance.data[\"representations\"].append(repre)\n\n        return instance\n\n    def get_render_instances_by_frame_range(self, context):\n        \"\"\"Return enabled render.local instances grouped by their frame range.\n\n        Arguments:\n            context (pyblish.Context): The pyblish context\n\n        Returns:\n            dict: (start, end): instances mapping\n\n        \"\"\"\n\n        instances_to_render = [\n            instance for instance in context if\n            # Only active instances\n            instance.data.get(\"publish\", True) and\n            # Only render.local instances\n            \"render.local\" in instance.data.get(\"families\", [])\n        ]\n\n        # Instances by frame ranges\n        instances_by_frame_range = collections.defaultdict(list)\n        for instance in instances_to_render:\n            start, end = self.get_instance_render_frame_range(instance)\n            instances_by_frame_range[(start, end)].append(instance)\n\n        return dict(instances_by_frame_range)\n\n    def get_instance_render_frame_range(self, instance):\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n        return start, end\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html#client.ayon_fusion.plugins.publish.extract_render_local.FusionRenderLocal.get_render_instances_by_frame_range","title":"<code>get_render_instances_by_frame_range(context)</code>","text":"<p>Return enabled render.local instances grouped by their frame range.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The pyblish context</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>(start, end): instances mapping</p> Source code in <code>client/ayon_fusion/plugins/publish/extract_render_local.py</code> <pre><code>def get_render_instances_by_frame_range(self, context):\n    \"\"\"Return enabled render.local instances grouped by their frame range.\n\n    Arguments:\n        context (pyblish.Context): The pyblish context\n\n    Returns:\n        dict: (start, end): instances mapping\n\n    \"\"\"\n\n    instances_to_render = [\n        instance for instance in context if\n        # Only active instances\n        instance.data.get(\"publish\", True) and\n        # Only render.local instances\n        \"render.local\" in instance.data.get(\"families\", [])\n    ]\n\n    # Instances by frame ranges\n    instances_by_frame_range = collections.defaultdict(list)\n    for instance in instances_to_render:\n        start, end = self.get_instance_render_frame_range(instance)\n        instances_by_frame_range[(start, end)].append(instance)\n\n    return dict(instances_by_frame_range)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html#client.ayon_fusion.plugins.publish.extract_render_local.FusionRenderLocal.render","title":"<code>render(instance)</code>","text":"<p>Render instance.</p> <p>We try to render the minimal amount of times by combining the instances that have a matching frame range in one Fusion render. Then for the batch of instances we store whether the render succeeded or failed.</p> Source code in <code>client/ayon_fusion/plugins/publish/extract_render_local.py</code> <pre><code>def render(self, instance):\n    \"\"\"Render instance.\n\n    We try to render the minimal amount of times by combining the instances\n    that have a matching frame range in one Fusion render. Then for the\n    batch of instances we store whether the render succeeded or failed.\n\n    \"\"\"\n\n    if self.is_rendered_key in instance.data:\n        # This instance was already processed in batch with another\n        # instance, so we just return the render result directly\n        self.log.debug(f\"Instance {instance} was already rendered\")\n        return instance.data[self.is_rendered_key]\n\n    instances_by_frame_range = self.get_render_instances_by_frame_range(\n        instance.context\n    )\n\n    # Render matching batch of instances that share the same frame range\n    frame_range = self.get_instance_render_frame_range(instance)\n    render_instances = instances_by_frame_range[frame_range]\n\n    # We initialize render state false to indicate it wasn't successful\n    # yet to keep track of whether Fusion succeeded. This is for cases\n    # where an error below this might cause the comp render result not\n    # to be stored for the instances of this batch\n    for render_instance in render_instances:\n        render_instance.data[self.is_rendered_key] = False\n\n    savers_to_render = [inst.data[\"tool\"] for inst in render_instances]\n    current_comp = instance.context.data[\"currentComp\"]\n    frame_start, frame_end = frame_range\n\n    self.log.info(\n        f\"Starting Fusion render frame range {frame_start}-{frame_end}\"\n    )\n    saver_names = \", \".join(saver.Name for saver in savers_to_render)\n    self.log.info(f\"Rendering tools: {saver_names}\")\n\n    with comp_lock_and_undo_chunk(current_comp):\n        with maintained_comp_range(current_comp):\n            with enabled_savers(current_comp, savers_to_render):\n                render_kwargs = {\n                    \"Start\": frame_start,\n                    \"End\": frame_end,\n                    \"Wait\": True\n                }\n                if self.suppress_dialogs:\n                    render_kwargs[\"RenderFlags\"] = REQF_Quiet\n\n                result = current_comp.Render(render_kwargs)\n\n    # Store the render state for all the rendered instances\n    for render_instance in render_instances:\n        render_instance.data[self.is_rendered_key] = bool(result)\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html#client.ayon_fusion.plugins.publish.extract_render_local.enabled_savers","title":"<code>enabled_savers(comp, savers)</code>","text":"<p>Enable only the <code>savers</code> in Comp during the context.</p> <p>Any Saver tool in the passed composition that is not in the savers list will be set to passthrough during the context.</p> <p>Parameters:</p> Name Type Description Default <code>comp</code> <code>object</code> <p>Fusion composition object.</p> required <code>savers</code> <code>list</code> <p>List of Saver tool objects.</p> required Source code in <code>client/ayon_fusion/plugins/publish/extract_render_local.py</code> <pre><code>@contextlib.contextmanager\ndef enabled_savers(comp, savers):\n    \"\"\"Enable only the `savers` in Comp during the context.\n\n    Any Saver tool in the passed composition that is not in the savers list\n    will be set to passthrough during the context.\n\n    Args:\n        comp (object): Fusion composition object.\n        savers (list): List of Saver tool objects.\n\n    \"\"\"\n    passthrough_key = \"TOOLB_PassThrough\"\n    original_states = {}\n    enabled_saver_names = {saver.Name for saver in savers}\n\n    all_savers = comp.GetToolList(False, \"Saver\").values()\n    savers_by_name = {saver.Name: saver for saver in all_savers}\n\n    try:\n        for saver in all_savers:\n            original_state = saver.GetAttrs()[passthrough_key]\n            original_states[saver.Name] = original_state\n\n            # The passthrough state we want to set (passthrough != enabled)\n            state = saver.Name not in enabled_saver_names\n            if state != original_state:\n                saver.SetAttrs({passthrough_key: state})\n        yield\n    finally:\n        for saver_name, original_state in original_states.items():\n            saver = savers_by_name[saver_name]\n            saver.SetAttrs({\"TOOLB_PassThrough\": original_state})\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/increment_current_file.html","title":"increment_current_file","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/increment_current_file.html#client.ayon_fusion.plugins.publish.increment_current_file.FusionIncrementCurrentFile","title":"<code>FusionIncrementCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Increment the current file.</p> <p>Saves the current file with an increased version number.</p> Source code in <code>client/ayon_fusion/plugins/publish/increment_current_file.py</code> <pre><code>class FusionIncrementCurrentFile(\n    pyblish.api.ContextPlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Increment the current file.\n\n    Saves the current file with an increased version number.\n\n    \"\"\"\n\n    label = \"Increment workfile version\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    hosts = [\"fusion\"]\n    optional = True\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        from ayon_core.lib import version_up\n        from ayon_core.pipeline.publish import get_errored_plugins_from_context\n\n        errored_plugins = get_errored_plugins_from_context(context)\n        if any(\n            plugin.__name__ == \"FusionSubmitDeadline\"\n            for plugin in errored_plugins\n        ):\n            raise KnownPublishError(\n                \"Skipping incrementing current file because \"\n                \"submission to render farm failed.\"\n            )\n\n        comp = context.data.get(\"currentComp\")\n        assert comp, \"Must have comp\"\n\n        current_filepath = context.data[\"currentFile\"]\n        new_filepath = version_up(current_filepath)\n\n        comp.Save(new_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/save_scene.html","title":"save_scene","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/save_scene.html#client.ayon_fusion.plugins.publish.save_scene.FusionSaveComp","title":"<code>FusionSaveComp</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Save current comp</p> Source code in <code>client/ayon_fusion/plugins/publish/save_scene.py</code> <pre><code>class FusionSaveComp(pyblish.api.ContextPlugin):\n    \"\"\"Save current comp\"\"\"\n\n    label = \"Save current file\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    hosts = [\"fusion\"]\n    families = [\"render\", \"image\", \"workfile\"]\n\n    def process(self, context):\n\n        comp = context.data.get(\"currentComp\")\n        assert comp, \"Must have comp\"\n\n        current = comp.GetAttrs().get(\"COMPS_FileName\", \"\")\n        assert context.data['currentFile'] == current\n\n        self.log.info(\"Saving current file: {}\".format(current))\n        comp.Save()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_background_depth.html","title":"validate_background_depth","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_background_depth.html#client.ayon_fusion.plugins.publish.validate_background_depth.ValidateBackgroundDepth","title":"<code>ValidateBackgroundDepth</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if all Background tool are set to float32 bit</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_background_depth.py</code> <pre><code>class ValidateBackgroundDepth(\n    pyblish.api.InstancePlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Validate if all Background tool are set to float32 bit\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Background Depth 32 bit\"\n    hosts = [\"fusion\"]\n    families = [\"render\", \"image\"]\n    optional = True\n\n    actions = [SelectInvalidAction, publish.RepairAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n        context = instance.context\n        comp = context.data.get(\"currentComp\")\n        assert comp, \"Must have Comp object\"\n\n        backgrounds = comp.GetToolList(False, \"Background\").values()\n        if not backgrounds:\n            return []\n\n        return [i for i in backgrounds if i.GetInput(\"Depth\") != 4.0]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Found {} Backgrounds tools which\"\n                \" are not set to float32\".format(len(invalid)),\n                title=self.label,\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        comp = instance.context.data.get(\"currentComp\")\n        invalid = cls.get_invalid(instance)\n        for i in invalid:\n            i.SetInput(\"Depth\", 4.0, comp.TIME_UNDEFINED)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_comp_saved.html","title":"validate_comp_saved","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_comp_saved.html#client.ayon_fusion.plugins.publish.validate_comp_saved.ValidateFusionCompSaved","title":"<code>ValidateFusionCompSaved</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Ensure current comp is saved</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_comp_saved.py</code> <pre><code>class ValidateFusionCompSaved(pyblish.api.ContextPlugin):\n    \"\"\"Ensure current comp is saved\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Comp Saved\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n\n    def process(self, context):\n\n        comp = context.data.get(\"currentComp\")\n        assert comp, \"Must have Comp object\"\n        attrs = comp.GetAttrs()\n\n        filename = attrs[\"COMPS_FileName\"]\n        if not filename:\n            raise PublishValidationError(\"Comp is not saved.\",\n                                         title=self.label)\n\n        if not os.path.exists(filename):\n            raise PublishValidationError(\n                \"Comp file does not exist: %s\" % filename, title=self.label)\n\n        if attrs[\"COMPB_Modified\"]:\n            self.log.warning(\"Comp is modified. Save your comp to ensure your \"\n                             \"changes propagate correctly.\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_create_folder_checked.html","title":"validate_create_folder_checked","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_create_folder_checked.html#client.ayon_fusion.plugins.publish.validate_create_folder_checked.ValidateCreateFolderChecked","title":"<code>ValidateCreateFolderChecked</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Valid if all savers have the input attribute CreateDir checked on</p> <p>This attribute ensures that the folders to which the saver will write will be created.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_create_folder_checked.py</code> <pre><code>class ValidateCreateFolderChecked(pyblish.api.InstancePlugin):\n    \"\"\"Valid if all savers have the input attribute CreateDir checked on\n\n    This attribute ensures that the folders to which the saver will write\n    will be created.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Create Folder Checked\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [RepairAction, SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n        tool = instance.data[\"tool\"]\n        create_dir = tool.GetInput(\"CreateDir\")\n        if create_dir == 0.0:\n            cls.log.error(\n                \"%s has Create Folder turned off\" % instance[0].Name\n            )\n            return [tool]\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Found Saver with Create Folder During Render checked off\",\n                title=self.label,\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        invalid = cls.get_invalid(instance)\n        for tool in invalid:\n            tool.SetInput(\"CreateDir\", 1.0)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_expected_frames_existence.html","title":"validate_expected_frames_existence","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_expected_frames_existence.html#client.ayon_fusion.plugins.publish.validate_expected_frames_existence.ValidateLocalFramesExistence","title":"<code>ValidateLocalFramesExistence</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Checks if files for savers that's set to publish expected frames exists</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_expected_frames_existence.py</code> <pre><code>class ValidateLocalFramesExistence(pyblish.api.InstancePlugin):\n    \"\"\"Checks if files for savers that's set\n    to publish expected frames exists\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Expected Frames Exists\"\n    families = [\"render.frames\"]\n    hosts = [\"fusion\"]\n    actions = [RepairAction, SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, instance, non_existing_frames=None):\n        if non_existing_frames is None:\n            non_existing_frames = []\n\n        tool = instance.data[\"tool\"]\n\n        expected_files = instance.data[\"expectedFiles\"]\n\n        for file in expected_files:\n            if not os.path.exists(file):\n                cls.log.error(\n                    f\"Missing file: {file}\"\n                )\n                non_existing_frames.append(file)\n\n        if len(non_existing_frames) &gt; 0:\n            cls.log.error(f\"Some of {tool.Name}'s files does not exist\")\n            return [tool]\n\n    def process(self, instance):\n        non_existing_frames = []\n        invalid = self.get_invalid(instance, non_existing_frames)\n        if invalid:\n            raise PublishValidationError(\n                \"{} is set to publish existing frames but \"\n                \"some frames are missing. \"\n                \"The missing file(s) are:\\n\\n{}\".format(\n                    invalid[0].Name,\n                    \"\\n\\n\".join(non_existing_frames),\n                ),\n                title=self.label,\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        invalid = cls.get_invalid(instance)\n        if invalid:\n            tool = instance.data[\"tool\"]\n            # Change render target to local to render locally\n            tool.SetData(\"openpype.creator_attributes.render_target\", \"local\")\n\n            cls.log.info(\n                f\"Reload the publisher and {tool.Name} \"\n                \"will be set to render locally\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_filename_has_extension.html","title":"validate_filename_has_extension","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_filename_has_extension.html#client.ayon_fusion.plugins.publish.validate_filename_has_extension.ValidateFilenameHasExtension","title":"<code>ValidateFilenameHasExtension</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Ensure the Saver has an extension in the filename path</p> <p>This disallows files written as <code>filename</code> instead of <code>filename.frame.ext</code>. Fusion does not always set an extension for your filename when changing the file format of the saver.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_filename_has_extension.py</code> <pre><code>class ValidateFilenameHasExtension(pyblish.api.InstancePlugin):\n    \"\"\"Ensure the Saver has an extension in the filename path\n\n    This disallows files written as `filename` instead of `filename.frame.ext`.\n    Fusion does not always set an extension for your filename when\n    changing the file format of the saver.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Filename Has Extension\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [SelectInvalidAction]\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\"Found Saver without an extension\",\n                                         title=self.label)\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        path = instance.data[\"expectedFiles\"][0]\n        fname, ext = os.path.splitext(path)\n\n        if not ext:\n            tool = instance.data[\"tool\"]\n            cls.log.error(\"%s has no extension specified\" % tool.Name)\n            return [tool]\n\n        return []\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_image_frame.html","title":"validate_image_frame","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_image_frame.html#client.ayon_fusion.plugins.publish.validate_image_frame.ValidateImageFrame","title":"<code>ValidateImageFrame</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validates that <code>image</code> product type contains only single frame.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_image_frame.py</code> <pre><code>class ValidateImageFrame(pyblish.api.InstancePlugin):\n    \"\"\"Validates that `image` product type contains only single frame.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Image Frame\"\n    families = [\"image\"]\n    hosts = [\"fusion\"]\n\n    def process(self, instance):\n        render_start = instance.data[\"frameStartHandle\"]\n        render_end = instance.data[\"frameEndHandle\"]\n        too_many_frames = (isinstance(instance.data[\"expectedFiles\"], list)\n                           and len(instance.data[\"expectedFiles\"]) &gt; 1)\n\n        if render_end - render_start &gt; 0 or too_many_frames:\n            desc = (\"Trying to render multiple frames. 'image' product type \"\n                    \"is meant for single frame. Please use 'render' creator.\")\n            raise PublishValidationError(\n                title=\"Frame range outside of comp range\",\n                message=desc,\n                description=desc\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_frame_range.html","title":"validate_instance_frame_range","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_frame_range.html#client.ayon_fusion.plugins.publish.validate_instance_frame_range.ValidateInstanceFrameRange","title":"<code>ValidateInstanceFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate instance frame range is within comp's global render range.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_instance_frame_range.py</code> <pre><code>class ValidateInstanceFrameRange(pyblish.api.InstancePlugin):\n    \"\"\"Validate instance frame range is within comp's global render range.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Frame Range\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n\n    def process(self, instance):\n\n        context = instance.context\n        global_start = context.data[\"compFrameStart\"]\n        global_end = context.data[\"compFrameEnd\"]\n\n        render_start = instance.data[\"frameStartHandle\"]\n        render_end = instance.data[\"frameEndHandle\"]\n\n        if render_start &lt; global_start or render_end &gt; global_end:\n\n            message = (\n                f\"Instance {instance} render frame range \"\n                f\"({render_start}-{render_end}) is outside of the comp's \"\n                f\"global render range ({global_start}-{global_end}) and thus \"\n                f\"can't be rendered. \"\n            )\n            description = (\n                f\"{message}\\n\\n\"\n                f\"Either update the comp's global range or the instance's \"\n                f\"frame range to ensure the comp's frame range includes the \"\n                f\"to render frame range for the instance.\"\n            )\n            raise PublishValidationError(\n                title=\"Frame range outside of comp range\",\n                message=message,\n                description=description\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_in_context.html","title":"validate_instance_in_context","text":"<p>Validate if instance context is the same as publish context.</p>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_in_context.html#client.ayon_fusion.plugins.publish.validate_instance_in_context.ValidateInstanceInContextFusion","title":"<code>ValidateInstanceInContextFusion</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validator to check if instance context matches context of publish.</p> <p>When working in per-shot style you always publish data in context of current asset (shot). This validator checks if this is so. It is optional so it can be disabled when needed.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_instance_in_context.py</code> <pre><code>class ValidateInstanceInContextFusion(pyblish.api.InstancePlugin,\n                                      OptionalPyblishPluginMixin):\n    \"\"\"Validator to check if instance context matches context of publish.\n\n    When working in per-shot style you always publish data in context of\n    current asset (shot). This validator checks if this is so. It is optional\n    so it can be disabled when needed.\n    \"\"\"\n    # Similar to maya and houdini-equivalent `ValidateInstanceInContext`\n\n    order = ValidateContentsOrder\n    label = \"Instance in same Context\"\n    optional = True\n    hosts = [\"fusion\"]\n    actions = [SelectToolAction, RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        instance_context = self.get_context(instance.data)\n        context = self.get_context(instance.context.data)\n        if instance_context != context:\n            context_label = \"{} &gt; {}\".format(*context)\n            instance_label = \"{} &gt; {}\".format(*instance_context)\n\n            raise PublishValidationError(\n                message=(\n                    \"Instance '{}' publishes to different asset than current \"\n                    \"context: {}. Current context: {}\".format(\n                        instance.name, instance_label, context_label\n                    )\n                ),\n                description=(\n                    \"## Publishing to a different asset\\n\"\n                    \"There are publish instances present which are publishing \"\n                    \"into a different asset than your current context.\\n\\n\"\n                    \"Usually this is not what you want but there can be cases \"\n                    \"where you might want to publish into another asset or \"\n                    \"shot. If that's the case you can disable the validation \"\n                    \"on the instance to ignore it.\"\n                )\n            )\n\n    @classmethod\n    def repair(cls, instance):\n\n        create_context = instance.context.data[\"create_context\"]\n        instance_id = instance.data.get(\"instance_id\")\n        created_instance = create_context.get_instance_by_id(\n            instance_id\n        )\n        if created_instance is None:\n            raise RuntimeError(\n                f\"No CreatedInstances found with id '{instance_id} \"\n                f\"in {create_context.instances_by_id}\"\n            )\n\n        context_asset, context_task = cls.get_context(instance.context.data)\n        created_instance[\"folderPath\"] = context_asset\n        created_instance[\"task\"] = context_task\n        create_context.save_changes()\n\n    @staticmethod\n    def get_context(data):\n        \"\"\"Return asset, task from publishing context data\"\"\"\n        return data[\"folderPath\"], data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_in_context.html#client.ayon_fusion.plugins.publish.validate_instance_in_context.ValidateInstanceInContextFusion.get_context","title":"<code>get_context(data)</code>  <code>staticmethod</code>","text":"<p>Return asset, task from publishing context data</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_instance_in_context.py</code> <pre><code>@staticmethod\ndef get_context(data):\n    \"\"\"Return asset, task from publishing context data\"\"\"\n    return data[\"folderPath\"], data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_has_input.html","title":"validate_saver_has_input","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_has_input.html#client.ayon_fusion.plugins.publish.validate_saver_has_input.ValidateSaverHasInput","title":"<code>ValidateSaverHasInput</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate saver has incoming connection</p> <p>This ensures a Saver has at least an input connection.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_saver_has_input.py</code> <pre><code>class ValidateSaverHasInput(pyblish.api.InstancePlugin):\n    \"\"\"Validate saver has incoming connection\n\n    This ensures a Saver has at least an input connection.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Saver Has Input\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        saver = instance.data[\"tool\"]\n        if not saver.Input.GetConnectedOutput():\n            return [saver]\n\n        return []\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            saver_name = invalid[0].Name\n            raise PublishValidationError(\n                \"Saver has no incoming connection: {} ({})\".format(instance,\n                                                                   saver_name),\n                title=self.label)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_passthrough.html","title":"validate_saver_passthrough","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_passthrough.html#client.ayon_fusion.plugins.publish.validate_saver_passthrough.ValidateSaverPassthrough","title":"<code>ValidateSaverPassthrough</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Validate saver passthrough is similar to Pyblish publish state</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_saver_passthrough.py</code> <pre><code>class ValidateSaverPassthrough(pyblish.api.ContextPlugin):\n    \"\"\"Validate saver passthrough is similar to Pyblish publish state\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Saver Passthrough\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [SelectInvalidAction]\n\n    def process(self, context):\n\n        # Workaround for ContextPlugin always running, even if no instance\n        # is present with the family\n        instances = pyblish.api.instances_by_plugin(instances=list(context),\n                                                    plugin=self)\n        if not instances:\n            self.log.debug(\"Ignoring plugin.. (bugfix)\")\n\n        invalid_instances = []\n        for instance in instances:\n            invalid = self.is_invalid(instance)\n            if invalid:\n                invalid_instances.append(instance)\n\n        if invalid_instances:\n            self.log.info(\"Reset pyblish to collect your current scene state, \"\n                          \"that should fix error.\")\n            raise PublishValidationError(\n                \"Invalid instances: {0}\".format(invalid_instances),\n                title=self.label)\n\n    def is_invalid(self, instance):\n\n        saver = instance.data[\"tool\"]\n        attr = saver.GetAttrs()\n        active = not attr[\"TOOLB_PassThrough\"]\n\n        if active != instance.data.get(\"publish\", True):\n            self.log.info(\"Saver has different passthrough state than \"\n                          \"Pyblish: {} ({})\".format(instance, saver.Name))\n            return [saver]\n\n        return []\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_resolution.html","title":"validate_saver_resolution","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_resolution.html#client.ayon_fusion.plugins.publish.validate_saver_resolution.ValidateSaverResolution","title":"<code>ValidateSaverResolution</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that the saver input resolution matches the folder resolution</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_saver_resolution.py</code> <pre><code>class ValidateSaverResolution(\n    pyblish.api.InstancePlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Validate that the saver input resolution matches the folder resolution\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Folder Resolution\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    optional = True\n    actions = [SelectInvalidAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        resolution = self.get_resolution(instance)\n        expected_resolution = self.get_expected_resolution(instance)\n        if resolution != expected_resolution:\n            raise PublishValidationError(\n                \"The input's resolution does not match \"\n                \"the folder's resolution {}x{}.\\n\\n\"\n                \"The input's resolution is {}x{}.\".format(\n                    expected_resolution[0], expected_resolution[1],\n                    resolution[0], resolution[1]\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        saver = instance.data[\"tool\"]\n        try:\n            resolution = cls.get_resolution(instance)\n        except PublishValidationError:\n            resolution = None\n        expected_resolution = cls.get_expected_resolution(instance)\n        if resolution != expected_resolution:\n            return [saver]\n\n    @classmethod\n    def get_resolution(cls, instance):\n        saver = instance.data[\"tool\"]\n        first_frame = instance.data[\"frameStartHandle\"]\n\n        try:\n            return get_tool_resolution(saver, frame=first_frame)\n        except ValueError:\n            raise PublishValidationError(\n                \"Cannot get resolution info for frame '{}'.\\n\\n \"\n                \"Please check that saver has connected input.\".format(\n                    first_frame\n                )\n            )\n\n    @classmethod\n    def get_expected_resolution(cls, instance):\n\n        entity = instance.data.get(\"taskEntity\")\n        if not entity:\n            cls.log.debug(\n                \"Using folder entity resolution for validation because \"\n                f\"task entity not found for instance: {instance}\")\n            entity = instance.data[\"folderEntity\"]\n\n        attributes = entity[\"attrib\"]\n        return attributes[\"resolutionWidth\"], attributes[\"resolutionHeight\"]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_unique_subsets.html","title":"validate_unique_subsets","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_unique_subsets.html#client.ayon_fusion.plugins.publish.validate_unique_subsets.ValidateUniqueSubsets","title":"<code>ValidateUniqueSubsets</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Ensure all instances have a unique product name</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_unique_subsets.py</code> <pre><code>class ValidateUniqueSubsets(pyblish.api.ContextPlugin):\n    \"\"\"Ensure all instances have a unique product name\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Unique Products\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, context):\n\n        # Collect instances per product per folder\n        instances_per_product_folder = defaultdict(lambda: defaultdict(list))\n        for instance in context:\n            folder_path = instance.data[\"folderPath\"]\n            product_name = instance.data[\"productName\"]\n            instances_per_product_folder[folder_path][product_name].append(\n                instance\n            )\n\n        # Find which folder + subset combination has more than one instance\n        # Those are considered invalid because they'd integrate to the same\n        # destination.\n        invalid = []\n        for folder_path, instances_per_product in (\n            instances_per_product_folder.items()\n        ):\n            for product_name, instances in instances_per_product.items():\n                if len(instances) &gt; 1:\n                    cls.log.warning(\n                        (\n                            \"{folder_path} &gt; {product_name} used by more than \"\n                            \"one instance: {instances}\"\n                        ).format(\n                            folder_path=folder_path,\n                            product_name=product_name,\n                            instances=instances\n                        )\n                    )\n                    invalid.extend(instances)\n\n        # Return tools for the invalid instances so they can be selected\n        invalid = [instance.data[\"tool\"] for instance in invalid]\n\n        return invalid\n\n    def process(self, context):\n        invalid = self.get_invalid(context)\n        if invalid:\n            raise PublishValidationError(\n                \"Multiple instances are set to the same folder &gt; product.\",\n                title=self.label\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/scripts/index.html","title":"scripts","text":""},{"location":"autoapi/client/ayon_fusion/scripts/duplicate_with_inputs.html","title":"duplicate_with_inputs","text":""},{"location":"autoapi/client/ayon_fusion/scripts/duplicate_with_inputs.html#client.ayon_fusion.scripts.duplicate_with_inputs.duplicate_with_input_connections","title":"<code>duplicate_with_input_connections()</code>","text":"<p>Duplicate selected tools with incoming connections.</p> Source code in <code>client/ayon_fusion/scripts/duplicate_with_inputs.py</code> <pre><code>def duplicate_with_input_connections():\n    \"\"\"Duplicate selected tools with incoming connections.\"\"\"\n\n    comp = get_current_comp()\n    original_tools = comp.GetToolList(True).values()\n    if not original_tools:\n        return  # nothing selected\n\n    with comp_lock_and_undo_chunk(\n            comp, \"Duplicate With Input Connections\"):\n\n        # Generate duplicates\n        comp.Copy()\n        comp.SetActiveTool()\n        comp.Paste()\n        duplicate_tools = comp.GetToolList(True).values()\n\n        # Copy connections\n        for original, new in zip(original_tools, duplicate_tools):\n\n            original_inputs = original.GetInputList().values()\n            new_inputs = new.GetInputList().values()\n            assert len(original_inputs) == len(new_inputs)\n\n            for original_input, new_input in zip(original_inputs, new_inputs):\n\n                if is_connected(original_input):\n\n                    if is_connected(new_input):\n                        # Already connected if it is between the copied tools\n                        continue\n\n                    new_input.ConnectTo(original_input.GetConnectedOutput())\n                    assert is_connected(new_input), \"Must be connected now\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/scripts/duplicate_with_inputs.html#client.ayon_fusion.scripts.duplicate_with_inputs.is_connected","title":"<code>is_connected(input)</code>","text":"<p>Return whether an input has incoming connection</p> Source code in <code>client/ayon_fusion/scripts/duplicate_with_inputs.py</code> <pre><code>def is_connected(input):\n    \"\"\"Return whether an input has incoming connection\"\"\"\n    return input.GetAttrs()[\"INPB_Connected\"]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/index.html","title":"vendor","text":""},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html","title":"attr","text":""},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.Attribute","title":"<code>Attribute = _add_hash(_add_eq(_add_repr(Attribute, attrs=_a), attrs=[a for a in _a if a.name != 'inherited']), attrs=[a for a in _a if a.hash and a.name != 'inherited'])</code>  <code>module-attribute</code>","text":"<p>Read-only representation of an attribute.</p> <p>Instances of this class are frequently used for introspection purposes like:</p> <ul> <li><code>fields</code> returns a tuple of them.</li> <li>Validators get them passed as the first argument.</li> <li>The field transformer hook receives a list of them.</li> </ul> <p>:attribute name: The name of the attribute. :attribute inherited: Whether or not that attribute has been inherited from     a base class.</p> <p>Plus all arguments of <code>attr.ib</code> (except for <code>factory</code> which is only syntactic sugar for <code>default=Factory(...)</code>.</p> <p>.. versionadded:: 20.1.0 inherited .. versionadded:: 20.1.0 on_setattr .. versionchanged:: 20.2.0 inherited is not taken into account for     equality checks and hashing anymore. .. versionadded:: 21.1.0 eq_key and order_key</p> <p>For the full version history of the fields, see <code>attr.ib</code>.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.Factory","title":"<code>Factory = _add_hash(_add_eq(_add_repr(Factory, attrs=_f), attrs=_f), attrs=_f)</code>  <code>module-attribute</code>","text":"<p>Stores a factory callable.</p> <p>If passed as the default value to <code>attr.ib</code>, the factory is used to generate a new value.</p> <p>:param callable factory: A callable that takes either none or exactly one     mandatory positional argument depending on takes_self. :param bool takes_self: Pass the partially initialized instance that is     being initialized as a positional argument.</p> <p>.. versionadded:: 17.1.0  takes_self</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.NOTHING","title":"<code>NOTHING = _Nothing()</code>  <code>module-attribute</code>","text":"<p>Sentinel to indicate the lack of a value when <code>None</code> is ambiguous.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.asdict","title":"<code>asdict(inst, recurse=True, filter=None, dict_factory=dict, retain_collection_types=False, value_serializer=None)</code>","text":"<p>Return the <code>attrs</code> attribute values of inst as a dict.</p> <p>Optionally recurse into other <code>attrs</code>-decorated classes.</p> <p>:param inst: Instance of an <code>attrs</code>-decorated class. :param bool recurse: Recurse into classes that are also     <code>attrs</code>-decorated. :param callable filter: A callable whose return code determines whether an     attribute or element is included (<code>True</code>) or dropped (<code>False</code>).  Is     called with the <code>attr.Attribute</code> as the first argument and the     value as the second argument. :param callable dict_factory: A callable to produce dictionaries from.  For     example, to produce ordered dictionaries instead of normal Python     dictionaries, pass in <code>collections.OrderedDict</code>. :param bool retain_collection_types: Do not convert to <code>list</code> when     encountering an attribute whose type is <code>tuple</code> or <code>set</code>.  Only     meaningful if <code>recurse</code> is <code>True</code>. :param Optional[callable] value_serializer: A hook that is called for every     attribute or dict key/value.  It receives the current instance, field     and value and must return the (updated) value.  The hook is run after     the optional filter has been applied.</p> <p>:rtype: return type of dict_factory</p> <p>:raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>..  versionadded:: 16.0.0 dict_factory ..  versionadded:: 16.1.0 retain_collection_types ..  versionadded:: 20.3.0 value_serializer</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def asdict(\n    inst,\n    recurse=True,\n    filter=None,\n    dict_factory=dict,\n    retain_collection_types=False,\n    value_serializer=None,\n):\n    \"\"\"\n    Return the ``attrs`` attribute values of *inst* as a dict.\n\n    Optionally recurse into other ``attrs``-decorated classes.\n\n    :param inst: Instance of an ``attrs``-decorated class.\n    :param bool recurse: Recurse into classes that are also\n        ``attrs``-decorated.\n    :param callable filter: A callable whose return code determines whether an\n        attribute or element is included (``True``) or dropped (``False``).  Is\n        called with the `attr.Attribute` as the first argument and the\n        value as the second argument.\n    :param callable dict_factory: A callable to produce dictionaries from.  For\n        example, to produce ordered dictionaries instead of normal Python\n        dictionaries, pass in ``collections.OrderedDict``.\n    :param bool retain_collection_types: Do not convert to ``list`` when\n        encountering an attribute whose type is ``tuple`` or ``set``.  Only\n        meaningful if ``recurse`` is ``True``.\n    :param Optional[callable] value_serializer: A hook that is called for every\n        attribute or dict key/value.  It receives the current instance, field\n        and value and must return the (updated) value.  The hook is run *after*\n        the optional *filter* has been applied.\n\n    :rtype: return type of *dict_factory*\n\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    ..  versionadded:: 16.0.0 *dict_factory*\n    ..  versionadded:: 16.1.0 *retain_collection_types*\n    ..  versionadded:: 20.3.0 *value_serializer*\n    \"\"\"\n    attrs = fields(inst.__class__)\n    rv = dict_factory()\n    for a in attrs:\n        v = getattr(inst, a.name)\n        if filter is not None and not filter(a, v):\n            continue\n\n        if value_serializer is not None:\n            v = value_serializer(inst, a, v)\n\n        if recurse is True:\n            if has(v.__class__):\n                rv[a.name] = asdict(\n                    v,\n                    True,\n                    filter,\n                    dict_factory,\n                    retain_collection_types,\n                    value_serializer,\n                )\n            elif isinstance(v, (tuple, list, set, frozenset)):\n                cf = v.__class__ if retain_collection_types is True else list\n                rv[a.name] = cf(\n                    [\n                        _asdict_anything(\n                            i,\n                            filter,\n                            dict_factory,\n                            retain_collection_types,\n                            value_serializer,\n                        )\n                        for i in v\n                    ]\n                )\n            elif isinstance(v, dict):\n                df = dict_factory\n                rv[a.name] = df(\n                    (\n                        _asdict_anything(\n                            kk,\n                            filter,\n                            df,\n                            retain_collection_types,\n                            value_serializer,\n                        ),\n                        _asdict_anything(\n                            vv,\n                            filter,\n                            df,\n                            retain_collection_types,\n                            value_serializer,\n                        ),\n                    )\n                    for kk, vv in iteritems(v)\n                )\n            else:\n                rv[a.name] = v\n        else:\n            rv[a.name] = v\n    return rv\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.assoc","title":"<code>assoc(inst, **changes)</code>","text":"<p>Copy inst and apply changes.</p> <p>:param inst: Instance of a class with <code>attrs</code> attributes. :param changes: Keyword changes in the new copy.</p> <p>:return: A copy of inst with changes incorporated.</p> <p>:raise attr.exceptions.AttrsAttributeNotFoundError: If attr_name couldn't     be found on cls. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>..  deprecated:: 17.1.0     Use <code>evolve</code> instead.</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def assoc(inst, **changes):\n    \"\"\"\n    Copy *inst* and apply *changes*.\n\n    :param inst: Instance of a class with ``attrs`` attributes.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise attr.exceptions.AttrsAttributeNotFoundError: If *attr_name* couldn't\n        be found on *cls*.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    ..  deprecated:: 17.1.0\n        Use `evolve` instead.\n    \"\"\"\n    import warnings\n\n    warnings.warn(\n        \"assoc is deprecated and will be removed after 2018/01.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    new = copy.copy(inst)\n    attrs = fields(inst.__class__)\n    for k, v in iteritems(changes):\n        a = getattr(attrs, k, NOTHING)\n        if a is NOTHING:\n            raise AttrsAttributeNotFoundError(\n                \"{k} is not an attrs attribute on {cl}.\".format(\n                    k=k, cl=new.__class__\n                )\n            )\n        _obj_setattr(new, k, v)\n    return new\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.astuple","title":"<code>astuple(inst, recurse=True, filter=None, tuple_factory=tuple, retain_collection_types=False)</code>","text":"<p>Return the <code>attrs</code> attribute values of inst as a tuple.</p> <p>Optionally recurse into other <code>attrs</code>-decorated classes.</p> <p>:param inst: Instance of an <code>attrs</code>-decorated class. :param bool recurse: Recurse into classes that are also     <code>attrs</code>-decorated. :param callable filter: A callable whose return code determines whether an     attribute or element is included (<code>True</code>) or dropped (<code>False</code>).  Is     called with the <code>attr.Attribute</code> as the first argument and the     value as the second argument. :param callable tuple_factory: A callable to produce tuples from.  For     example, to produce lists instead of tuples. :param bool retain_collection_types: Do not convert to <code>list</code>     or <code>dict</code> when encountering an attribute which type is     <code>tuple</code>, <code>dict</code> or <code>set</code>.  Only meaningful if <code>recurse</code> is     <code>True</code>.</p> <p>:rtype: return type of tuple_factory</p> <p>:raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>..  versionadded:: 16.2.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def astuple(\n    inst,\n    recurse=True,\n    filter=None,\n    tuple_factory=tuple,\n    retain_collection_types=False,\n):\n    \"\"\"\n    Return the ``attrs`` attribute values of *inst* as a tuple.\n\n    Optionally recurse into other ``attrs``-decorated classes.\n\n    :param inst: Instance of an ``attrs``-decorated class.\n    :param bool recurse: Recurse into classes that are also\n        ``attrs``-decorated.\n    :param callable filter: A callable whose return code determines whether an\n        attribute or element is included (``True``) or dropped (``False``).  Is\n        called with the `attr.Attribute` as the first argument and the\n        value as the second argument.\n    :param callable tuple_factory: A callable to produce tuples from.  For\n        example, to produce lists instead of tuples.\n    :param bool retain_collection_types: Do not convert to ``list``\n        or ``dict`` when encountering an attribute which type is\n        ``tuple``, ``dict`` or ``set``.  Only meaningful if ``recurse`` is\n        ``True``.\n\n    :rtype: return type of *tuple_factory*\n\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    ..  versionadded:: 16.2.0\n    \"\"\"\n    attrs = fields(inst.__class__)\n    rv = []\n    retain = retain_collection_types  # Very long. :/\n    for a in attrs:\n        v = getattr(inst, a.name)\n        if filter is not None and not filter(a, v):\n            continue\n        if recurse is True:\n            if has(v.__class__):\n                rv.append(\n                    astuple(\n                        v,\n                        recurse=True,\n                        filter=filter,\n                        tuple_factory=tuple_factory,\n                        retain_collection_types=retain,\n                    )\n                )\n            elif isinstance(v, (tuple, list, set, frozenset)):\n                cf = v.__class__ if retain is True else list\n                rv.append(\n                    cf(\n                        [\n                            astuple(\n                                j,\n                                recurse=True,\n                                filter=filter,\n                                tuple_factory=tuple_factory,\n                                retain_collection_types=retain,\n                            )\n                            if has(j.__class__)\n                            else j\n                            for j in v\n                        ]\n                    )\n                )\n            elif isinstance(v, dict):\n                df = v.__class__ if retain is True else dict\n                rv.append(\n                    df(\n                        (\n                            astuple(\n                                kk,\n                                tuple_factory=tuple_factory,\n                                retain_collection_types=retain,\n                            )\n                            if has(kk.__class__)\n                            else kk,\n                            astuple(\n                                vv,\n                                tuple_factory=tuple_factory,\n                                retain_collection_types=retain,\n                            )\n                            if has(vv.__class__)\n                            else vv,\n                        )\n                        for kk, vv in iteritems(v)\n                    )\n                )\n            else:\n                rv.append(v)\n        else:\n            rv.append(v)\n\n    return rv if tuple_factory is list else tuple_factory(rv)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.attrib","title":"<code>attrib(default=NOTHING, validator=None, repr=True, cmp=None, hash=None, init=True, metadata=None, type=None, converter=None, factory=None, kw_only=False, eq=None, order=None, on_setattr=None)</code>","text":"<p>Create a new attribute on a class.</p> <p>..  warning::</p> <pre><code>Does *not* do anything unless the class is also decorated with\n`attr.s`!\n</code></pre> <p>:param default: A value that is used if an <code>attrs</code>-generated <code>__init__</code>     is used and no value is passed while instantiating or the attribute is     excluded using <code>init=False</code>.</p> <pre><code>If the value is an instance of `Factory`, its callable will be\nused to construct a new value (useful for mutable data types like lists\nor dicts).\n\nIf a default is not set (or set manually to `attr.NOTHING`), a value\n*must* be supplied when instantiating; otherwise a `TypeError`\nwill be raised.\n\nThe default can also be set using decorator notation as shown below.\n</code></pre> <p>:type default: Any value</p> <p>:param callable factory: Syntactic sugar for     <code>default=attr.Factory(factory)</code>.</p> <p>:param validator: <code>callable</code> that is called by <code>attrs</code>-generated     <code>__init__</code> methods after the instance has been initialized.  They     receive the initialized instance, the <code>Attribute</code>, and the     passed value.</p> <pre><code>The return value is *not* inspected so the validator has to throw an\nexception itself.\n\nIf a `list` is passed, its items are treated as validators and must\nall pass.\n\nValidators can be globally disabled and re-enabled using\n`get_run_validators`.\n\nThe validator can also be set using decorator notation as shown below.\n</code></pre> <p>:type validator: <code>callable</code> or a <code>list</code> of <code>callable</code>\\ s.</p> <p>:param repr: Include this attribute in the generated <code>__repr__</code>     method. If <code>True</code>, include the attribute; if <code>False</code>, omit it. By     default, the built-in <code>repr()</code> function is used. To override how the     attribute value is formatted, pass a <code>callable</code> that takes a single     value and returns a string. Note that the resulting string is used     as-is, i.e. it will be used directly instead of calling <code>repr()</code>     (the default). :type repr: a <code>bool</code> or a <code>callable</code> to use a custom function.</p> <p>:param eq: If <code>True</code> (default), include this attribute in the     generated <code>__eq__</code> and <code>__ne__</code> methods that check two instances     for equality. To override how the attribute value is compared,     pass a <code>callable</code> that takes a single value and returns the value     to be compared. :type eq: a <code>bool</code> or a <code>callable</code>.</p> <p>:param order: If <code>True</code> (default), include this attributes in the     generated <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code> and <code>__ge__</code> methods.     To override how the attribute value is ordered,     pass a <code>callable</code> that takes a single value and returns the value     to be ordered. :type order: a <code>bool</code> or a <code>callable</code>.</p> <p>:param cmp: Setting cmp is equivalent to setting eq and order to the     same value. Must not be mixed with eq or order. :type cmp: a <code>bool</code> or a <code>callable</code>.</p> <p>:param Optional[bool] hash: Include this attribute in the generated     <code>__hash__</code> method.  If <code>None</code> (default), mirror eq's value.  This     is the correct behavior according the Python spec.  Setting this value     to anything else than <code>None</code> is discouraged. :param bool init: Include this attribute in the generated <code>__init__</code>     method.  It is possible to set this to <code>False</code> and set a default     value.  In that case this attributed is unconditionally initialized     with the specified default value or factory. :param callable converter: <code>callable</code> that is called by     <code>attrs</code>-generated <code>__init__</code> methods to convert attribute's value     to the desired format.  It is given the passed-in value, and the     returned value will be used as the new value of the attribute.  The     value is converted before being passed to the validator, if any. :param metadata: An arbitrary mapping, to be used by third-party     components.  See <code>extending_metadata</code>. :param type: The type of the attribute.  In Python 3.6 or greater, the     preferred method to specify the type is using a variable annotation     (see <code>PEP 526 &lt;https://www.python.org/dev/peps/pep-0526/&gt;</code>_).     This argument is provided for backward compatibility.     Regardless of the approach used, the type will be stored on     <code>Attribute.type</code>.</p> <pre><code>Please note that ``attrs`` doesn't do anything with this metadata by\nitself. You can use it as part of your own code or for\n`static type checking &lt;types&gt;`.\n</code></pre> <p>:param kw_only: Make this attribute keyword-only (Python 3+)     in the generated <code>__init__</code> (if <code>init</code> is <code>False</code>, this     parameter is ignored). :param on_setattr: Allows to overwrite the on_setattr setting from     <code>attr.s</code>. If left <code>None</code>, the on_setattr value from <code>attr.s</code> is used.     Set to <code>attr.setters.NO_OP</code> to run no <code>setattr</code> hooks for this     attribute -- regardless of the setting in <code>attr.s</code>. :type on_setattr: <code>callable</code>, or a list of callables, or <code>None</code>, or     <code>attr.setters.NO_OP</code></p> <p>.. versionadded:: 15.2.0 convert .. versionadded:: 16.3.0 metadata .. versionchanged:: 17.1.0 validator can be a <code>list</code> now. .. versionchanged:: 17.1.0    hash is <code>None</code> and therefore mirrors eq by default. .. versionadded:: 17.3.0 type .. deprecated:: 17.4.0 convert .. versionadded:: 17.4.0 converter as a replacement for the deprecated    convert to achieve consistency with other noun-based arguments. .. versionadded:: 18.1.0    <code>factory=f</code> is syntactic sugar for <code>default=attr.Factory(f)</code>. .. versionadded:: 18.2.0 kw_only .. versionchanged:: 19.2.0 convert keyword argument removed. .. versionchanged:: 19.2.0 repr also accepts a custom callable. .. deprecated:: 19.2.0 cmp Removal on or after 2021-06-01. .. versionadded:: 19.2.0 eq and order .. versionadded:: 20.1.0 on_setattr .. versionchanged:: 20.3.0 kw_only backported to Python 2 .. versionchanged:: 21.1.0    eq, order, and cmp also accept a custom callable .. versionchanged:: 21.1.0 cmp undeprecated</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def attrib(\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    cmp=None,\n    hash=None,\n    init=True,\n    metadata=None,\n    type=None,\n    converter=None,\n    factory=None,\n    kw_only=False,\n    eq=None,\n    order=None,\n    on_setattr=None,\n):\n    \"\"\"\n    Create a new attribute on a class.\n\n    ..  warning::\n\n        Does *not* do anything unless the class is also decorated with\n        `attr.s`!\n\n    :param default: A value that is used if an ``attrs``-generated ``__init__``\n        is used and no value is passed while instantiating or the attribute is\n        excluded using ``init=False``.\n\n        If the value is an instance of `Factory`, its callable will be\n        used to construct a new value (useful for mutable data types like lists\n        or dicts).\n\n        If a default is not set (or set manually to `attr.NOTHING`), a value\n        *must* be supplied when instantiating; otherwise a `TypeError`\n        will be raised.\n\n        The default can also be set using decorator notation as shown below.\n\n    :type default: Any value\n\n    :param callable factory: Syntactic sugar for\n        ``default=attr.Factory(factory)``.\n\n    :param validator: `callable` that is called by ``attrs``-generated\n        ``__init__`` methods after the instance has been initialized.  They\n        receive the initialized instance, the `Attribute`, and the\n        passed value.\n\n        The return value is *not* inspected so the validator has to throw an\n        exception itself.\n\n        If a `list` is passed, its items are treated as validators and must\n        all pass.\n\n        Validators can be globally disabled and re-enabled using\n        `get_run_validators`.\n\n        The validator can also be set using decorator notation as shown below.\n\n    :type validator: `callable` or a `list` of `callable`\\\\ s.\n\n    :param repr: Include this attribute in the generated ``__repr__``\n        method. If ``True``, include the attribute; if ``False``, omit it. By\n        default, the built-in ``repr()`` function is used. To override how the\n        attribute value is formatted, pass a ``callable`` that takes a single\n        value and returns a string. Note that the resulting string is used\n        as-is, i.e. it will be used directly *instead* of calling ``repr()``\n        (the default).\n    :type repr: a `bool` or a `callable` to use a custom function.\n\n    :param eq: If ``True`` (default), include this attribute in the\n        generated ``__eq__`` and ``__ne__`` methods that check two instances\n        for equality. To override how the attribute value is compared,\n        pass a ``callable`` that takes a single value and returns the value\n        to be compared.\n    :type eq: a `bool` or a `callable`.\n\n    :param order: If ``True`` (default), include this attributes in the\n        generated ``__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods.\n        To override how the attribute value is ordered,\n        pass a ``callable`` that takes a single value and returns the value\n        to be ordered.\n    :type order: a `bool` or a `callable`.\n\n    :param cmp: Setting *cmp* is equivalent to setting *eq* and *order* to the\n        same value. Must not be mixed with *eq* or *order*.\n    :type cmp: a `bool` or a `callable`.\n\n    :param Optional[bool] hash: Include this attribute in the generated\n        ``__hash__`` method.  If ``None`` (default), mirror *eq*'s value.  This\n        is the correct behavior according the Python spec.  Setting this value\n        to anything else than ``None`` is *discouraged*.\n    :param bool init: Include this attribute in the generated ``__init__``\n        method.  It is possible to set this to ``False`` and set a default\n        value.  In that case this attributed is unconditionally initialized\n        with the specified default value or factory.\n    :param callable converter: `callable` that is called by\n        ``attrs``-generated ``__init__`` methods to convert attribute's value\n        to the desired format.  It is given the passed-in value, and the\n        returned value will be used as the new value of the attribute.  The\n        value is converted before being passed to the validator, if any.\n    :param metadata: An arbitrary mapping, to be used by third-party\n        components.  See `extending_metadata`.\n    :param type: The type of the attribute.  In Python 3.6 or greater, the\n        preferred method to specify the type is using a variable annotation\n        (see `PEP 526 &lt;https://www.python.org/dev/peps/pep-0526/&gt;`_).\n        This argument is provided for backward compatibility.\n        Regardless of the approach used, the type will be stored on\n        ``Attribute.type``.\n\n        Please note that ``attrs`` doesn't do anything with this metadata by\n        itself. You can use it as part of your own code or for\n        `static type checking &lt;types&gt;`.\n    :param kw_only: Make this attribute keyword-only (Python 3+)\n        in the generated ``__init__`` (if ``init`` is ``False``, this\n        parameter is ignored).\n    :param on_setattr: Allows to overwrite the *on_setattr* setting from\n        `attr.s`. If left `None`, the *on_setattr* value from `attr.s` is used.\n        Set to `attr.setters.NO_OP` to run **no** `setattr` hooks for this\n        attribute -- regardless of the setting in `attr.s`.\n    :type on_setattr: `callable`, or a list of callables, or `None`, or\n        `attr.setters.NO_OP`\n\n    .. versionadded:: 15.2.0 *convert*\n    .. versionadded:: 16.3.0 *metadata*\n    .. versionchanged:: 17.1.0 *validator* can be a ``list`` now.\n    .. versionchanged:: 17.1.0\n       *hash* is ``None`` and therefore mirrors *eq* by default.\n    .. versionadded:: 17.3.0 *type*\n    .. deprecated:: 17.4.0 *convert*\n    .. versionadded:: 17.4.0 *converter* as a replacement for the deprecated\n       *convert* to achieve consistency with other noun-based arguments.\n    .. versionadded:: 18.1.0\n       ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.\n    .. versionadded:: 18.2.0 *kw_only*\n    .. versionchanged:: 19.2.0 *convert* keyword argument removed.\n    .. versionchanged:: 19.2.0 *repr* also accepts a custom callable.\n    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n    .. versionadded:: 19.2.0 *eq* and *order*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionchanged:: 20.3.0 *kw_only* backported to Python 2\n    .. versionchanged:: 21.1.0\n       *eq*, *order*, and *cmp* also accept a custom callable\n    .. versionchanged:: 21.1.0 *cmp* undeprecated\n    \"\"\"\n    eq, eq_key, order, order_key = _determine_attrib_eq_order(\n        cmp, eq, order, True\n    )\n\n    if hash is not None and hash is not True and hash is not False:\n        raise TypeError(\n            \"Invalid value for hash.  Must be True, False, or None.\"\n        )\n\n    if factory is not None:\n        if default is not NOTHING:\n            raise ValueError(\n                \"The `default` and `factory` arguments are mutually \"\n                \"exclusive.\"\n            )\n        if not callable(factory):\n            raise ValueError(\"The `factory` argument must be a callable.\")\n        default = Factory(factory)\n\n    if metadata is None:\n        metadata = {}\n\n    # Apply syntactic sugar by auto-wrapping.\n    if isinstance(on_setattr, (list, tuple)):\n        on_setattr = setters.pipe(*on_setattr)\n\n    if validator and isinstance(validator, (list, tuple)):\n        validator = and_(*validator)\n\n    if converter and isinstance(converter, (list, tuple)):\n        converter = pipe(*converter)\n\n    return _CountingAttr(\n        default=default,\n        validator=validator,\n        repr=repr,\n        cmp=None,\n        hash=hash,\n        init=init,\n        converter=converter,\n        metadata=metadata,\n        type=type,\n        kw_only=kw_only,\n        eq=eq,\n        eq_key=eq_key,\n        order=order,\n        order_key=order_key,\n        on_setattr=on_setattr,\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.attrs","title":"<code>attrs(maybe_cls=None, these=None, repr_ns=None, repr=None, cmp=None, hash=None, init=None, slots=False, frozen=False, weakref_slot=True, str=False, auto_attribs=False, kw_only=False, cache_hash=False, auto_exc=False, eq=None, order=None, auto_detect=False, collect_by_mro=False, getstate_setstate=None, on_setattr=None, field_transformer=None)</code>","text":"<p>A class decorator that adds <code>dunder &lt;https://wiki.python.org/moin/DunderAlias&gt;</code>_\\ -methods according to the specified attributes using <code>attr.ib</code> or the these argument.</p> <p>:param these: A dictionary of name to <code>attr.ib</code> mappings.  This is     useful to avoid the definition of your attributes within the class body     because you can't (e.g. if you want to add <code>__repr__</code> methods to     Django models) or don't want to.</p> <pre><code>If *these* is not ``None``, ``attrs`` will *not* search the class body\nfor attributes and will *not* remove any attributes from it.\n\nIf *these* is an ordered dict (`dict` on Python 3.6+,\n`collections.OrderedDict` otherwise), the order is deduced from\nthe order of the attributes inside *these*.  Otherwise the order\nof the definition of the attributes is used.\n</code></pre> <p>:type these: <code>dict</code> of <code>str</code> to <code>attr.ib</code></p> <p>:param str repr_ns: When using nested classes, there's no way in Python 2     to automatically detect that.  Therefore it's possible to set the     namespace explicitly for a more meaningful <code>repr</code> output. :param bool auto_detect: Instead of setting the init, repr, eq,     order, and hash arguments explicitly, assume they are set to     <code>True</code> unless any of the involved methods for one of the     arguments is implemented in the current class (i.e. it is not     inherited from some base class).</p> <pre><code>So for example by implementing ``__eq__`` on a class yourself,\n``attrs`` will deduce ``eq=False`` and will create *neither*\n``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible\n``__ne__`` by default, so it *should* be enough to only implement\n``__eq__`` in most cases).\n\n.. warning::\n\n   If you prevent ``attrs`` from creating the ordering methods for you\n   (``order=False``, e.g. by implementing ``__le__``), it becomes\n   *your* responsibility to make sure its ordering is sound. The best\n   way is to use the `functools.total_ordering` decorator.\n\n\nPassing ``True`` or ``False`` to *init*, *repr*, *eq*, *order*,\n*cmp*, or *hash* overrides whatever *auto_detect* would determine.\n\n*auto_detect* requires Python 3. Setting it ``True`` on Python 2 raises\na `PythonTooOldError`.\n</code></pre> <p>:param bool repr: Create a <code>__repr__</code> method with a human readable     representation of <code>attrs</code> attributes.. :param bool str: Create a <code>__str__</code> method that is identical to     <code>__repr__</code>.  This is usually not necessary except for     <code>Exception</code>\\ s. :param Optional[bool] eq: If <code>True</code> or <code>None</code> (default), add <code>__eq__</code>     and <code>__ne__</code> methods that check two instances for equality.</p> <pre><code>They compare the instances as if they were tuples of their ``attrs``\nattributes if and only if the types of both classes are *identical*!\n</code></pre> <p>:param Optional[bool] order: If <code>True</code>, add <code>__lt__</code>, <code>__le__</code>,     <code>__gt__</code>, and <code>__ge__</code> methods that behave like eq above and     allow instances to be ordered. If <code>None</code> (default) mirror value of     eq. :param Optional[bool] cmp: Setting cmp is equivalent to setting eq     and order to the same value. Must not be mixed with eq or order. :param Optional[bool] hash: If <code>None</code> (default), the <code>__hash__</code> method     is generated according how eq and frozen are set.</p> <pre><code>1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.\n2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to\n   None, marking it unhashable (which it is).\n3. If *eq* is False, ``__hash__`` will be left untouched meaning the\n   ``__hash__`` method of the base class will be used (if base class is\n   ``object``, this means it will fall back to id-based hashing.).\n\nAlthough not recommended, you can decide for yourself and force\n``attrs`` to create one (e.g. if the class is immutable even though you\ndidn't freeze it programmatically) by passing ``True`` or not.  Both of\nthese cases are rather special and should be used carefully.\n\nSee our documentation on `hashing`, Python's documentation on\n`object.__hash__`, and the `GitHub issue that led to the default \\\nbehavior &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more\ndetails.\n</code></pre> <p>:param bool init: Create a <code>__init__</code> method that initializes the     <code>attrs</code> attributes. Leading underscores are stripped for the argument     name. If a <code>__attrs_pre_init__</code> method exists on the class, it will     be called before the class is initialized. If a <code>__attrs_post_init__</code>     method exists on the class, it will be called after the class is fully     initialized.</p> <pre><code>If ``init`` is ``False``, an ``__attrs_init__`` method will be\ninjected instead. This allows you to define a custom ``__init__``\nmethod that can do pre-init work such as ``super().__init__()``,\nand then call ``__attrs_init__()`` and ``__attrs_post_init__()``.\n</code></pre> <p>:param bool slots: Create a <code>slotted class &lt;slotted classes&gt;</code> that's more     memory-efficient. Slotted classes are generally superior to the default     dict classes, but have some gotchas you should know about, so we     encourage you to read the <code>glossary entry &lt;slotted classes&gt;</code>. :param bool frozen: Make instances immutable after initialization.  If     someone attempts to modify a frozen instance,     <code>attr.exceptions.FrozenInstanceError</code> is raised.</p> <pre><code>.. note::\n\n    1. This is achieved by installing a custom ``__setattr__`` method\n       on your class, so you can't implement your own.\n\n    2. True immutability is impossible in Python.\n\n    3. This *does* have a minor a runtime performance `impact\n       &lt;how-frozen&gt;` when initializing new instances.  In other words:\n       ``__init__`` is slightly slower with ``frozen=True``.\n\n    4. If a class is frozen, you cannot modify ``self`` in\n       ``__attrs_post_init__`` or a self-written ``__init__``. You can\n       circumvent that limitation by using\n       ``object.__setattr__(self, \"attribute_name\", value)``.\n\n    5. Subclasses of a frozen class are frozen too.\n</code></pre> <p>:param bool weakref_slot: Make instances weak-referenceable.  This has no     effect unless <code>slots</code> is also enabled. :param bool auto_attribs: If <code>True</code>, collect <code>PEP 526</code>_-annotated     attributes (Python 3.6 and later only) from the class body.</p> <pre><code>In this case, you **must** annotate every field.  If ``attrs``\nencounters a field that is set to an `attr.ib` but lacks a type\nannotation, an `attr.exceptions.UnannotatedAttributeError` is\nraised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don't\nwant to set a type.\n\nIf you assign a value to those attributes (e.g. ``x: int = 42``), that\nvalue becomes the default value like if it were passed using\n``attr.ib(default=42)``.  Passing an instance of `Factory` also\nworks as expected in most cases (see warning below).\n\nAttributes annotated as `typing.ClassVar`, and attributes that are\nneither annotated nor set to an `attr.ib` are **ignored**.\n\n.. warning::\n   For features that use the attribute name to create decorators (e.g.\n   `validators &lt;validators&gt;`), you still *must* assign `attr.ib` to\n   them. Otherwise Python will either not find the name or try to use\n   the default value to call e.g. ``validator`` on it.\n\n   These errors can be quite confusing and probably the most common bug\n   report on our bug tracker.\n\n.. _`PEP 526`: https://www.python.org/dev/peps/pep-0526/\n</code></pre> <p>:param bool kw_only: Make all attributes keyword-only (Python 3+)     in the generated <code>__init__</code> (if <code>init</code> is <code>False</code>, this     parameter is ignored). :param bool cache_hash: Ensure that the object's hash code is computed     only once and stored on the object.  If this is set to <code>True</code>,     hashing must be either explicitly or implicitly enabled for this     class.  If the hash code is cached, avoid any reassignments of     fields involved in hash code computation or mutations of the objects     those fields point to after object creation.  If such changes occur,     the behavior of the object's hash code is undefined. :param bool auto_exc: If the class subclasses <code>BaseException</code>     (which implicitly includes any subclass of any exception), the     following happens to behave like a well-behaved Python exceptions     class:</p> <pre><code>- the values for *eq*, *order*, and *hash* are ignored and the\n  instances compare and hash by the instance's ids (N.B. ``attrs`` will\n  *not* remove existing implementations of ``__hash__`` or the equality\n  methods. It just won't add own ones.),\n- all attributes that are either passed into ``__init__`` or have a\n  default value are additionally available as a tuple in the ``args``\n  attribute,\n- the value of *str* is ignored leaving ``__str__`` to base classes.\n</code></pre> <p>:param bool collect_by_mro: Setting this to <code>True</code> fixes the way <code>attrs</code>    collects attributes from base classes.  The default behavior is    incorrect in certain cases of multiple inheritance.  It should be on by    default but is kept off for backward-compatability.</p> <p>See issue <code>#428 &lt;https://github.com/python-attrs/attrs/issues/428&gt;</code>_ for    more details.</p> <p>:param Optional[bool] getstate_setstate:    .. note::       This is usually only interesting for slotted classes and you should       probably just set auto_detect to <code>True</code>.</p> <p>If <code>True</code>, <code>__getstate__</code> and    <code>__setstate__</code> are generated and attached to the class. This is    necessary for slotted classes to be pickleable. If left <code>None</code>, it's    <code>True</code> by default for slotted classes and <code>False</code> for dict classes.</p> <p>If auto_detect is <code>True</code>, and getstate_setstate is left <code>None</code>,    and either <code>__getstate__</code> or <code>__setstate__</code> is detected directly    on the class (i.e. not inherited), it is set to <code>False</code> (this is usually    what you want).</p> <p>:param on_setattr: A callable that is run whenever the user attempts to set     an attribute (either by assignment like <code>i.x = 42</code> or by using     <code>setattr</code> like <code>setattr(i, \"x\", 42)</code>). It receives the same arguments     as validators: the instance, the attribute that is being modified, and     the new value.</p> <pre><code>If no exception is raised, the attribute is set to the return value of\nthe callable.\n\nIf a list of callables is passed, they're automatically wrapped in an\n`attr.setters.pipe`.\n</code></pre> <p>:param Optional[callable] field_transformer:     A function that is called with the original class object and all     fields right before <code>attrs</code> finalizes the class.  You can use     this, e.g., to automatically add converters or validators to     fields based on their types.  See <code>transform-fields</code> for more details.</p> <p>.. versionadded:: 16.0.0 slots .. versionadded:: 16.1.0 frozen .. versionadded:: 16.3.0 str .. versionadded:: 16.3.0 Support for <code>__attrs_post_init__</code>. .. versionchanged:: 17.1.0    hash supports <code>None</code> as value which is also the default now. .. versionadded:: 17.3.0 auto_attribs .. versionchanged:: 18.1.0    If these is passed, no attributes are deleted from the class body. .. versionchanged:: 18.1.0 If these is ordered, the order is retained. .. versionadded:: 18.2.0 weakref_slot .. deprecated:: 18.2.0    <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, and <code>__ge__</code> now raise a    <code>DeprecationWarning</code> if the classes compared are subclasses of    each other. <code>__eq</code> and <code>__ne__</code> never tried to compared subclasses    to each other. .. versionchanged:: 19.2.0    <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, and <code>__ge__</code> now do not consider    subclasses comparable anymore. .. versionadded:: 18.2.0 kw_only .. versionadded:: 18.2.0 cache_hash .. versionadded:: 19.1.0 auto_exc .. deprecated:: 19.2.0 cmp Removal on or after 2021-06-01. .. versionadded:: 19.2.0 eq and order .. versionadded:: 20.1.0 auto_detect .. versionadded:: 20.1.0 collect_by_mro .. versionadded:: 20.1.0 getstate_setstate .. versionadded:: 20.1.0 on_setattr .. versionadded:: 20.3.0 field_transformer .. versionchanged:: 21.1.0    <code>init=False</code> injects <code>__attrs_init__</code> .. versionchanged:: 21.1.0 Support for <code>__attrs_pre_init__</code> .. versionchanged:: 21.1.0 cmp undeprecated</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def attrs(\n    maybe_cls=None,\n    these=None,\n    repr_ns=None,\n    repr=None,\n    cmp=None,\n    hash=None,\n    init=None,\n    slots=False,\n    frozen=False,\n    weakref_slot=True,\n    str=False,\n    auto_attribs=False,\n    kw_only=False,\n    cache_hash=False,\n    auto_exc=False,\n    eq=None,\n    order=None,\n    auto_detect=False,\n    collect_by_mro=False,\n    getstate_setstate=None,\n    on_setattr=None,\n    field_transformer=None,\n):\n    r\"\"\"\n    A class decorator that adds `dunder\n    &lt;https://wiki.python.org/moin/DunderAlias&gt;`_\\ -methods according to the\n    specified attributes using `attr.ib` or the *these* argument.\n\n    :param these: A dictionary of name to `attr.ib` mappings.  This is\n        useful to avoid the definition of your attributes within the class body\n        because you can't (e.g. if you want to add ``__repr__`` methods to\n        Django models) or don't want to.\n\n        If *these* is not ``None``, ``attrs`` will *not* search the class body\n        for attributes and will *not* remove any attributes from it.\n\n        If *these* is an ordered dict (`dict` on Python 3.6+,\n        `collections.OrderedDict` otherwise), the order is deduced from\n        the order of the attributes inside *these*.  Otherwise the order\n        of the definition of the attributes is used.\n\n    :type these: `dict` of `str` to `attr.ib`\n\n    :param str repr_ns: When using nested classes, there's no way in Python 2\n        to automatically detect that.  Therefore it's possible to set the\n        namespace explicitly for a more meaningful ``repr`` output.\n    :param bool auto_detect: Instead of setting the *init*, *repr*, *eq*,\n        *order*, and *hash* arguments explicitly, assume they are set to\n        ``True`` **unless any** of the involved methods for one of the\n        arguments is implemented in the *current* class (i.e. it is *not*\n        inherited from some base class).\n\n        So for example by implementing ``__eq__`` on a class yourself,\n        ``attrs`` will deduce ``eq=False`` and will create *neither*\n        ``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible\n        ``__ne__`` by default, so it *should* be enough to only implement\n        ``__eq__`` in most cases).\n\n        .. warning::\n\n           If you prevent ``attrs`` from creating the ordering methods for you\n           (``order=False``, e.g. by implementing ``__le__``), it becomes\n           *your* responsibility to make sure its ordering is sound. The best\n           way is to use the `functools.total_ordering` decorator.\n\n\n        Passing ``True`` or ``False`` to *init*, *repr*, *eq*, *order*,\n        *cmp*, or *hash* overrides whatever *auto_detect* would determine.\n\n        *auto_detect* requires Python 3. Setting it ``True`` on Python 2 raises\n        a `PythonTooOldError`.\n\n    :param bool repr: Create a ``__repr__`` method with a human readable\n        representation of ``attrs`` attributes..\n    :param bool str: Create a ``__str__`` method that is identical to\n        ``__repr__``.  This is usually not necessary except for\n        `Exception`\\ s.\n    :param Optional[bool] eq: If ``True`` or ``None`` (default), add ``__eq__``\n        and ``__ne__`` methods that check two instances for equality.\n\n        They compare the instances as if they were tuples of their ``attrs``\n        attributes if and only if the types of both classes are *identical*!\n    :param Optional[bool] order: If ``True``, add ``__lt__``, ``__le__``,\n        ``__gt__``, and ``__ge__`` methods that behave like *eq* above and\n        allow instances to be ordered. If ``None`` (default) mirror value of\n        *eq*.\n    :param Optional[bool] cmp: Setting *cmp* is equivalent to setting *eq*\n        and *order* to the same value. Must not be mixed with *eq* or *order*.\n    :param Optional[bool] hash: If ``None`` (default), the ``__hash__`` method\n        is generated according how *eq* and *frozen* are set.\n\n        1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.\n        2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to\n           None, marking it unhashable (which it is).\n        3. If *eq* is False, ``__hash__`` will be left untouched meaning the\n           ``__hash__`` method of the base class will be used (if base class is\n           ``object``, this means it will fall back to id-based hashing.).\n\n        Although not recommended, you can decide for yourself and force\n        ``attrs`` to create one (e.g. if the class is immutable even though you\n        didn't freeze it programmatically) by passing ``True`` or not.  Both of\n        these cases are rather special and should be used carefully.\n\n        See our documentation on `hashing`, Python's documentation on\n        `object.__hash__`, and the `GitHub issue that led to the default \\\n        behavior &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more\n        details.\n    :param bool init: Create a ``__init__`` method that initializes the\n        ``attrs`` attributes. Leading underscores are stripped for the argument\n        name. If a ``__attrs_pre_init__`` method exists on the class, it will\n        be called before the class is initialized. If a ``__attrs_post_init__``\n        method exists on the class, it will be called after the class is fully\n        initialized.\n\n        If ``init`` is ``False``, an ``__attrs_init__`` method will be\n        injected instead. This allows you to define a custom ``__init__``\n        method that can do pre-init work such as ``super().__init__()``,\n        and then call ``__attrs_init__()`` and ``__attrs_post_init__()``.\n    :param bool slots: Create a `slotted class &lt;slotted classes&gt;` that's more\n        memory-efficient. Slotted classes are generally superior to the default\n        dict classes, but have some gotchas you should know about, so we\n        encourage you to read the `glossary entry &lt;slotted classes&gt;`.\n    :param bool frozen: Make instances immutable after initialization.  If\n        someone attempts to modify a frozen instance,\n        `attr.exceptions.FrozenInstanceError` is raised.\n\n        .. note::\n\n            1. This is achieved by installing a custom ``__setattr__`` method\n               on your class, so you can't implement your own.\n\n            2. True immutability is impossible in Python.\n\n            3. This *does* have a minor a runtime performance `impact\n               &lt;how-frozen&gt;` when initializing new instances.  In other words:\n               ``__init__`` is slightly slower with ``frozen=True``.\n\n            4. If a class is frozen, you cannot modify ``self`` in\n               ``__attrs_post_init__`` or a self-written ``__init__``. You can\n               circumvent that limitation by using\n               ``object.__setattr__(self, \"attribute_name\", value)``.\n\n            5. Subclasses of a frozen class are frozen too.\n\n    :param bool weakref_slot: Make instances weak-referenceable.  This has no\n        effect unless ``slots`` is also enabled.\n    :param bool auto_attribs: If ``True``, collect `PEP 526`_-annotated\n        attributes (Python 3.6 and later only) from the class body.\n\n        In this case, you **must** annotate every field.  If ``attrs``\n        encounters a field that is set to an `attr.ib` but lacks a type\n        annotation, an `attr.exceptions.UnannotatedAttributeError` is\n        raised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don't\n        want to set a type.\n\n        If you assign a value to those attributes (e.g. ``x: int = 42``), that\n        value becomes the default value like if it were passed using\n        ``attr.ib(default=42)``.  Passing an instance of `Factory` also\n        works as expected in most cases (see warning below).\n\n        Attributes annotated as `typing.ClassVar`, and attributes that are\n        neither annotated nor set to an `attr.ib` are **ignored**.\n\n        .. warning::\n           For features that use the attribute name to create decorators (e.g.\n           `validators &lt;validators&gt;`), you still *must* assign `attr.ib` to\n           them. Otherwise Python will either not find the name or try to use\n           the default value to call e.g. ``validator`` on it.\n\n           These errors can be quite confusing and probably the most common bug\n           report on our bug tracker.\n\n        .. _`PEP 526`: https://www.python.org/dev/peps/pep-0526/\n    :param bool kw_only: Make all attributes keyword-only (Python 3+)\n        in the generated ``__init__`` (if ``init`` is ``False``, this\n        parameter is ignored).\n    :param bool cache_hash: Ensure that the object's hash code is computed\n        only once and stored on the object.  If this is set to ``True``,\n        hashing must be either explicitly or implicitly enabled for this\n        class.  If the hash code is cached, avoid any reassignments of\n        fields involved in hash code computation or mutations of the objects\n        those fields point to after object creation.  If such changes occur,\n        the behavior of the object's hash code is undefined.\n    :param bool auto_exc: If the class subclasses `BaseException`\n        (which implicitly includes any subclass of any exception), the\n        following happens to behave like a well-behaved Python exceptions\n        class:\n\n        - the values for *eq*, *order*, and *hash* are ignored and the\n          instances compare and hash by the instance's ids (N.B. ``attrs`` will\n          *not* remove existing implementations of ``__hash__`` or the equality\n          methods. It just won't add own ones.),\n        - all attributes that are either passed into ``__init__`` or have a\n          default value are additionally available as a tuple in the ``args``\n          attribute,\n        - the value of *str* is ignored leaving ``__str__`` to base classes.\n    :param bool collect_by_mro: Setting this to `True` fixes the way ``attrs``\n       collects attributes from base classes.  The default behavior is\n       incorrect in certain cases of multiple inheritance.  It should be on by\n       default but is kept off for backward-compatability.\n\n       See issue `#428 &lt;https://github.com/python-attrs/attrs/issues/428&gt;`_ for\n       more details.\n\n    :param Optional[bool] getstate_setstate:\n       .. note::\n          This is usually only interesting for slotted classes and you should\n          probably just set *auto_detect* to `True`.\n\n       If `True`, ``__getstate__`` and\n       ``__setstate__`` are generated and attached to the class. This is\n       necessary for slotted classes to be pickleable. If left `None`, it's\n       `True` by default for slotted classes and ``False`` for dict classes.\n\n       If *auto_detect* is `True`, and *getstate_setstate* is left `None`,\n       and **either** ``__getstate__`` or ``__setstate__`` is detected directly\n       on the class (i.e. not inherited), it is set to `False` (this is usually\n       what you want).\n\n    :param on_setattr: A callable that is run whenever the user attempts to set\n        an attribute (either by assignment like ``i.x = 42`` or by using\n        `setattr` like ``setattr(i, \"x\", 42)``). It receives the same arguments\n        as validators: the instance, the attribute that is being modified, and\n        the new value.\n\n        If no exception is raised, the attribute is set to the return value of\n        the callable.\n\n        If a list of callables is passed, they're automatically wrapped in an\n        `attr.setters.pipe`.\n\n    :param Optional[callable] field_transformer:\n        A function that is called with the original class object and all\n        fields right before ``attrs`` finalizes the class.  You can use\n        this, e.g., to automatically add converters or validators to\n        fields based on their types.  See `transform-fields` for more details.\n\n    .. versionadded:: 16.0.0 *slots*\n    .. versionadded:: 16.1.0 *frozen*\n    .. versionadded:: 16.3.0 *str*\n    .. versionadded:: 16.3.0 Support for ``__attrs_post_init__``.\n    .. versionchanged:: 17.1.0\n       *hash* supports ``None`` as value which is also the default now.\n    .. versionadded:: 17.3.0 *auto_attribs*\n    .. versionchanged:: 18.1.0\n       If *these* is passed, no attributes are deleted from the class body.\n    .. versionchanged:: 18.1.0 If *these* is ordered, the order is retained.\n    .. versionadded:: 18.2.0 *weakref_slot*\n    .. deprecated:: 18.2.0\n       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a\n       `DeprecationWarning` if the classes compared are subclasses of\n       each other. ``__eq`` and ``__ne__`` never tried to compared subclasses\n       to each other.\n    .. versionchanged:: 19.2.0\n       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider\n       subclasses comparable anymore.\n    .. versionadded:: 18.2.0 *kw_only*\n    .. versionadded:: 18.2.0 *cache_hash*\n    .. versionadded:: 19.1.0 *auto_exc*\n    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n    .. versionadded:: 19.2.0 *eq* and *order*\n    .. versionadded:: 20.1.0 *auto_detect*\n    .. versionadded:: 20.1.0 *collect_by_mro*\n    .. versionadded:: 20.1.0 *getstate_setstate*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionadded:: 20.3.0 *field_transformer*\n    .. versionchanged:: 21.1.0\n       ``init=False`` injects ``__attrs_init__``\n    .. versionchanged:: 21.1.0 Support for ``__attrs_pre_init__``\n    .. versionchanged:: 21.1.0 *cmp* undeprecated\n    \"\"\"\n    if auto_detect and PY2:\n        raise PythonTooOldError(\n            \"auto_detect only works on Python 3 and later.\"\n        )\n\n    eq_, order_ = _determine_attrs_eq_order(cmp, eq, order, None)\n    hash_ = hash  # work around the lack of nonlocal\n\n    if isinstance(on_setattr, (list, tuple)):\n        on_setattr = setters.pipe(*on_setattr)\n\n    def wrap(cls):\n\n        if getattr(cls, \"__class__\", None) is None:\n            raise TypeError(\"attrs only works with new-style classes.\")\n\n        is_frozen = frozen or _has_frozen_base_class(cls)\n        is_exc = auto_exc is True and issubclass(cls, BaseException)\n        has_own_setattr = auto_detect and _has_own_attribute(\n            cls, \"__setattr__\"\n        )\n\n        if has_own_setattr and is_frozen:\n            raise ValueError(\"Can't freeze a class with a custom __setattr__.\")\n\n        builder = _ClassBuilder(\n            cls,\n            these,\n            slots,\n            is_frozen,\n            weakref_slot,\n            _determine_whether_to_implement(\n                cls,\n                getstate_setstate,\n                auto_detect,\n                (\"__getstate__\", \"__setstate__\"),\n                default=slots,\n            ),\n            auto_attribs,\n            kw_only,\n            cache_hash,\n            is_exc,\n            collect_by_mro,\n            on_setattr,\n            has_own_setattr,\n            field_transformer,\n        )\n        if _determine_whether_to_implement(\n            cls, repr, auto_detect, (\"__repr__\",)\n        ):\n            builder.add_repr(repr_ns)\n        if str is True:\n            builder.add_str()\n\n        eq = _determine_whether_to_implement(\n            cls, eq_, auto_detect, (\"__eq__\", \"__ne__\")\n        )\n        if not is_exc and eq is True:\n            builder.add_eq()\n        if not is_exc and _determine_whether_to_implement(\n            cls, order_, auto_detect, (\"__lt__\", \"__le__\", \"__gt__\", \"__ge__\")\n        ):\n            builder.add_order()\n\n        builder.add_setattr()\n\n        if (\n            hash_ is None\n            and auto_detect is True\n            and _has_own_attribute(cls, \"__hash__\")\n        ):\n            hash = False\n        else:\n            hash = hash_\n        if hash is not True and hash is not False and hash is not None:\n            # Can't use `hash in` because 1 == True for example.\n            raise TypeError(\n                \"Invalid value for hash.  Must be True, False, or None.\"\n            )\n        elif hash is False or (hash is None and eq is False) or is_exc:\n            # Don't do anything. Should fall back to __object__'s __hash__\n            # which is by id.\n            if cache_hash:\n                raise TypeError(\n                    \"Invalid value for cache_hash.  To use hash caching,\"\n                    \" hashing must be either explicitly or implicitly \"\n                    \"enabled.\"\n                )\n        elif hash is True or (\n            hash is None and eq is True and is_frozen is True\n        ):\n            # Build a __hash__ if told so, or if it's safe.\n            builder.add_hash()\n        else:\n            # Raise TypeError on attempts to hash.\n            if cache_hash:\n                raise TypeError(\n                    \"Invalid value for cache_hash.  To use hash caching,\"\n                    \" hashing must be either explicitly or implicitly \"\n                    \"enabled.\"\n                )\n            builder.make_unhashable()\n\n        if _determine_whether_to_implement(\n            cls, init, auto_detect, (\"__init__\",)\n        ):\n            builder.add_init()\n        else:\n            builder.add_attrs_init()\n            if cache_hash:\n                raise TypeError(\n                    \"Invalid value for cache_hash.  To use hash caching,\"\n                    \" init must be True.\"\n                )\n\n        return builder.build_class()\n\n    # maybe_cls's type depends on the usage of the decorator.  It's a class\n    # if it's used as `@attrs` but ``None`` if used as `@attrs()`.\n    if maybe_cls is None:\n        return wrap\n    else:\n        return wrap(maybe_cls)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.cmp_using","title":"<code>cmp_using(eq=None, lt=None, le=None, gt=None, ge=None, require_same_type=True, class_name='Comparable')</code>","text":"<p>Create a class that can be passed into <code>attr.ib</code>'s <code>eq</code>, <code>order</code>, and <code>cmp</code> arguments to customize field comparison.</p> <p>The resulting class will have a full set of ordering methods if at least one of <code>{lt, le, gt, ge}</code> and <code>eq</code>  are provided.</p> <p>:param Optional[callable] eq: <code>callable</code> used to evaluate equality     of two objects. :param Optional[callable] lt: <code>callable</code> used to evaluate whether     one object is less than another object. :param Optional[callable] le: <code>callable</code> used to evaluate whether     one object is less than or equal to another object. :param Optional[callable] gt: <code>callable</code> used to evaluate whether     one object is greater than another object. :param Optional[callable] ge: <code>callable</code> used to evaluate whether     one object is greater than or equal to another object.</p> <p>:param bool require_same_type: When <code>True</code>, equality and ordering methods     will return <code>NotImplemented</code> if objects are not of the same type.</p> <p>:param Optional[str] class_name: Name of class. Defaults to 'Comparable'.</p> <p>See <code>comparison</code> for more details.</p> <p>.. versionadded:: 21.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_cmp.py</code> <pre><code>def cmp_using(\n    eq=None,\n    lt=None,\n    le=None,\n    gt=None,\n    ge=None,\n    require_same_type=True,\n    class_name=\"Comparable\",\n):\n    \"\"\"\n    Create a class that can be passed into `attr.ib`'s ``eq``, ``order``, and\n    ``cmp`` arguments to customize field comparison.\n\n    The resulting class will have a full set of ordering methods if\n    at least one of ``{lt, le, gt, ge}`` and ``eq``  are provided.\n\n    :param Optional[callable] eq: `callable` used to evaluate equality\n        of two objects.\n    :param Optional[callable] lt: `callable` used to evaluate whether\n        one object is less than another object.\n    :param Optional[callable] le: `callable` used to evaluate whether\n        one object is less than or equal to another object.\n    :param Optional[callable] gt: `callable` used to evaluate whether\n        one object is greater than another object.\n    :param Optional[callable] ge: `callable` used to evaluate whether\n        one object is greater than or equal to another object.\n\n    :param bool require_same_type: When `True`, equality and ordering methods\n        will return `NotImplemented` if objects are not of the same type.\n\n    :param Optional[str] class_name: Name of class. Defaults to 'Comparable'.\n\n    See `comparison` for more details.\n\n    .. versionadded:: 21.1.0\n    \"\"\"\n\n    body = {\n        \"__slots__\": [\"value\"],\n        \"__init__\": _make_init(),\n        \"_requirements\": [],\n        \"_is_comparable_to\": _is_comparable_to,\n    }\n\n    # Add operations.\n    num_order_functions = 0\n    has_eq_function = False\n\n    if eq is not None:\n        has_eq_function = True\n        body[\"__eq__\"] = _make_operator(\"eq\", eq)\n        body[\"__ne__\"] = _make_ne()\n\n    if lt is not None:\n        num_order_functions += 1\n        body[\"__lt__\"] = _make_operator(\"lt\", lt)\n\n    if le is not None:\n        num_order_functions += 1\n        body[\"__le__\"] = _make_operator(\"le\", le)\n\n    if gt is not None:\n        num_order_functions += 1\n        body[\"__gt__\"] = _make_operator(\"gt\", gt)\n\n    if ge is not None:\n        num_order_functions += 1\n        body[\"__ge__\"] = _make_operator(\"ge\", ge)\n\n    type_ = new_class(class_name, (object,), {}, lambda ns: ns.update(body))\n\n    # Add same type requirement.\n    if require_same_type:\n        type_._requirements.append(_check_same_type)\n\n    # Add total ordering if at least one operation was defined.\n    if 0 &lt; num_order_functions &lt; 4:\n        if not has_eq_function:\n            # functools.total_ordering requires __eq__ to be defined,\n            # so raise early error here to keep a nice stack.\n            raise ValueError(\n                \"eq must be define is order to complete ordering from \"\n                \"lt, le, gt, ge.\"\n            )\n        type_ = functools.total_ordering(type_)\n\n    return type_\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.evolve","title":"<code>evolve(inst, **changes)</code>","text":"<p>Create a new instance, based on inst with changes applied.</p> <p>:param inst: Instance of a class with <code>attrs</code> attributes. :param changes: Keyword changes in the new copy.</p> <p>:return: A copy of inst with changes incorporated.</p> <p>:raise TypeError: If attr_name couldn't be found in the class     <code>__init__</code>. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>..  versionadded:: 17.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def evolve(inst, **changes):\n    \"\"\"\n    Create a new instance, based on *inst* with *changes* applied.\n\n    :param inst: Instance of a class with ``attrs`` attributes.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise TypeError: If *attr_name* couldn't be found in the class\n        ``__init__``.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    ..  versionadded:: 17.1.0\n    \"\"\"\n    cls = inst.__class__\n    attrs = fields(cls)\n    for a in attrs:\n        if not a.init:\n            continue\n        attr_name = a.name  # To deal with private attributes.\n        init_name = attr_name if attr_name[0] != \"_\" else attr_name[1:]\n        if init_name not in changes:\n            changes[init_name] = getattr(inst, attr_name)\n\n    return cls(**changes)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.fields","title":"<code>fields(cls)</code>","text":"<p>Return the tuple of <code>attrs</code> attributes for a class.</p> <p>The tuple also allows accessing the fields by their names (see below for examples).</p> <p>:param type cls: Class to introspect.</p> <p>:raise TypeError: If cls is not a class. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>:rtype: tuple (with name accessors) of <code>attr.Attribute</code></p> <p>..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields     by name.</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def fields(cls):\n    \"\"\"\n    Return the tuple of ``attrs`` attributes for a class.\n\n    The tuple also allows accessing the fields by their names (see below for\n    examples).\n\n    :param type cls: Class to introspect.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    :rtype: tuple (with name accessors) of `attr.Attribute`\n\n    ..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields\n        by name.\n    \"\"\"\n    if not isclass(cls):\n        raise TypeError(\"Passed object must be a class.\")\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n    if attrs is None:\n        raise NotAnAttrsClassError(\n            \"{cls!r} is not an attrs-decorated class.\".format(cls=cls)\n        )\n    return attrs\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.fields_dict","title":"<code>fields_dict(cls)</code>","text":"<p>Return an ordered dictionary of <code>attrs</code> attributes for a class, whose keys are the attribute names.</p> <p>:param type cls: Class to introspect.</p> <p>:raise TypeError: If cls is not a class. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>:rtype: an ordered dict where keys are attribute names and values are     <code>attr.Attribute</code>\\ s. This will be a <code>dict</code> if it's     naturally ordered like on Python 3.6+ or an     :class:<code>~collections.OrderedDict</code> otherwise.</p> <p>.. versionadded:: 18.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def fields_dict(cls):\n    \"\"\"\n    Return an ordered dictionary of ``attrs`` attributes for a class, whose\n    keys are the attribute names.\n\n    :param type cls: Class to introspect.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    :rtype: an ordered dict where keys are attribute names and values are\n        `attr.Attribute`\\\\ s. This will be a `dict` if it's\n        naturally ordered like on Python 3.6+ or an\n        :class:`~collections.OrderedDict` otherwise.\n\n    .. versionadded:: 18.1.0\n    \"\"\"\n    if not isclass(cls):\n        raise TypeError(\"Passed object must be a class.\")\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n    if attrs is None:\n        raise NotAnAttrsClassError(\n            \"{cls!r} is not an attrs-decorated class.\".format(cls=cls)\n        )\n    return ordered_dict(((a.name, a) for a in attrs))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.get_run_validators","title":"<code>get_run_validators()</code>","text":"<p>Return whether or not validators are run.</p> Source code in <code>client/ayon_fusion/vendor/attr/_config.py</code> <pre><code>def get_run_validators():\n    \"\"\"\n    Return whether or not validators are run.\n    \"\"\"\n    return _run_validators\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.has","title":"<code>has(cls)</code>","text":"<p>Check whether cls is a class with <code>attrs</code> attributes.</p> <p>:param type cls: Class to introspect. :raise TypeError: If cls is not a class.</p> <p>:rtype: bool</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def has(cls):\n    \"\"\"\n    Check whether *cls* is a class with ``attrs`` attributes.\n\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n\n    :rtype: bool\n    \"\"\"\n    return getattr(cls, \"__attrs_attrs__\", None) is not None\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.make_class","title":"<code>make_class(name, attrs, bases=(object,), **attributes_arguments)</code>","text":"<p>A quick way to create a new class called name with attrs.</p> <p>:param str name: The name for the new class.</p> <p>:param attrs: A list of names or a dictionary of mappings of names to     attributes.</p> <pre><code>If *attrs* is a list or an ordered dict (`dict` on Python 3.6+,\n`collections.OrderedDict` otherwise), the order is deduced from\nthe order of the names or attributes inside *attrs*.  Otherwise the\norder of the definition of the attributes is used.\n</code></pre> <p>:type attrs: <code>list</code> or <code>dict</code></p> <p>:param tuple bases: Classes that the new class will subclass.</p> <p>:param attributes_arguments: Passed unmodified to <code>attr.s</code>.</p> <p>:return: A new class with attrs. :rtype: type</p> <p>.. versionadded:: 17.1.0 bases .. versionchanged:: 18.1.0 If attrs is ordered, the order is retained.</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def make_class(name, attrs, bases=(object,), **attributes_arguments):\n    \"\"\"\n    A quick way to create a new class called *name* with *attrs*.\n\n    :param str name: The name for the new class.\n\n    :param attrs: A list of names or a dictionary of mappings of names to\n        attributes.\n\n        If *attrs* is a list or an ordered dict (`dict` on Python 3.6+,\n        `collections.OrderedDict` otherwise), the order is deduced from\n        the order of the names or attributes inside *attrs*.  Otherwise the\n        order of the definition of the attributes is used.\n    :type attrs: `list` or `dict`\n\n    :param tuple bases: Classes that the new class will subclass.\n\n    :param attributes_arguments: Passed unmodified to `attr.s`.\n\n    :return: A new class with *attrs*.\n    :rtype: type\n\n    .. versionadded:: 17.1.0 *bases*\n    .. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained.\n    \"\"\"\n    if isinstance(attrs, dict):\n        cls_dict = attrs\n    elif isinstance(attrs, (list, tuple)):\n        cls_dict = dict((a, attrib()) for a in attrs)\n    else:\n        raise TypeError(\"attrs argument must be a dict or a list.\")\n\n    pre_init = cls_dict.pop(\"__attrs_pre_init__\", None)\n    post_init = cls_dict.pop(\"__attrs_post_init__\", None)\n    user_init = cls_dict.pop(\"__init__\", None)\n\n    body = {}\n    if pre_init is not None:\n        body[\"__attrs_pre_init__\"] = pre_init\n    if post_init is not None:\n        body[\"__attrs_post_init__\"] = post_init\n    if user_init is not None:\n        body[\"__init__\"] = user_init\n\n    type_ = new_class(name, bases, {}, lambda ns: ns.update(body))\n\n    # For pickling to work, the __module__ variable needs to be set to the\n    # frame where the class is created.  Bypass this step in environments where\n    # sys._getframe is not defined (Jython for example) or sys._getframe is not\n    # defined for arguments greater than 0 (IronPython).\n    try:\n        type_.__module__ = sys._getframe(1).f_globals.get(\n            \"__name__\", \"__main__\"\n        )\n    except (AttributeError, ValueError):\n        pass\n\n    # We do it here for proper warnings with meaningful stacklevel.\n    cmp = attributes_arguments.pop(\"cmp\", None)\n    (\n        attributes_arguments[\"eq\"],\n        attributes_arguments[\"order\"],\n    ) = _determine_attrs_eq_order(\n        cmp,\n        attributes_arguments.get(\"eq\"),\n        attributes_arguments.get(\"order\"),\n        True,\n    )\n\n    return _attrs(these=cls_dict, **attributes_arguments)(type_)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.resolve_types","title":"<code>resolve_types(cls, globalns=None, localns=None, attribs=None)</code>","text":"<p>Resolve any strings and forward annotations in type annotations.</p> <p>This is only required if you need concrete types in <code>Attribute</code>'s type field. In other words, you don't need to resolve your types if you only use them for static type checking.</p> <p>With no arguments, names will be looked up in the module in which the class was created. If this is not what you want, e.g. if the name only exists inside a method, you may pass globalns or localns to specify other dictionaries in which to look up these names. See the docs of <code>typing.get_type_hints</code> for more details.</p> <p>:param type cls: Class to resolve. :param Optional[dict] globalns: Dictionary containing global variables. :param Optional[dict] localns: Dictionary containing local variables. :param Optional[list] attribs: List of attribs for the given class.     This is necessary when calling from inside a <code>field_transformer</code>     since cls is not an <code>attrs</code> class yet.</p> <p>:raise TypeError: If cls is not a class. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class and you didn't pass any attribs. :raise NameError: If types cannot be resolved because of missing variables.</p> <p>:returns: cls so you can use this function also as a class decorator.     Please note that you have to apply it after <code>attr.s</code>. That means     the decorator has to come in the line before <code>attr.s</code>.</p> <p>..  versionadded:: 20.1.0 ..  versionadded:: 21.1.0 attribs</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def resolve_types(cls, globalns=None, localns=None, attribs=None):\n    \"\"\"\n    Resolve any strings and forward annotations in type annotations.\n\n    This is only required if you need concrete types in `Attribute`'s *type*\n    field. In other words, you don't need to resolve your types if you only\n    use them for static type checking.\n\n    With no arguments, names will be looked up in the module in which the class\n    was created. If this is not what you want, e.g. if the name only exists\n    inside a method, you may pass *globalns* or *localns* to specify other\n    dictionaries in which to look up these names. See the docs of\n    `typing.get_type_hints` for more details.\n\n    :param type cls: Class to resolve.\n    :param Optional[dict] globalns: Dictionary containing global variables.\n    :param Optional[dict] localns: Dictionary containing local variables.\n    :param Optional[list] attribs: List of attribs for the given class.\n        This is necessary when calling from inside a ``field_transformer``\n        since *cls* is not an ``attrs`` class yet.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class and you didn't pass any attribs.\n    :raise NameError: If types cannot be resolved because of missing variables.\n\n    :returns: *cls* so you can use this function also as a class decorator.\n        Please note that you have to apply it **after** `attr.s`. That means\n        the decorator has to come in the line **before** `attr.s`.\n\n    ..  versionadded:: 20.1.0\n    ..  versionadded:: 21.1.0 *attribs*\n\n    \"\"\"\n    try:\n        # Since calling get_type_hints is expensive we cache whether we've\n        # done it already.\n        cls.__attrs_types_resolved__\n    except AttributeError:\n        import typing\n\n        hints = typing.get_type_hints(cls, globalns=globalns, localns=localns)\n        for field in fields(cls) if attribs is None else attribs:\n            if field.name in hints:\n                # Since fields have been frozen we must work around it.\n                _obj_setattr(field, \"type\", hints[field.name])\n        cls.__attrs_types_resolved__ = True\n\n    # Return the class so you can use it as a decorator too.\n    return cls\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.set_run_validators","title":"<code>set_run_validators(run)</code>","text":"<p>Set whether or not validators are run.  By default, they are run.</p> Source code in <code>client/ayon_fusion/vendor/attr/_config.py</code> <pre><code>def set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n    \"\"\"\n    if not isinstance(run, bool):\n        raise TypeError(\"'run' must be bool.\")\n    global _run_validators\n    _run_validators = run\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/index.html#client.ayon_fusion.vendor.attr.validate","title":"<code>validate(inst)</code>","text":"<p>Validate all attributes on inst that have a validator.</p> <p>Leaves all exceptions through.</p> <p>:param inst: Instance of a class with <code>attrs</code> attributes.</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def validate(inst):\n    \"\"\"\n    Validate all attributes on *inst* that have a validator.\n\n    Leaves all exceptions through.\n\n    :param inst: Instance of a class with ``attrs`` attributes.\n    \"\"\"\n    if _config._run_validators is False:\n        return\n\n    for a in fields(inst.__class__):\n        v = a.validator\n        if v is not None:\n            v(inst, a, getattr(inst, a.name))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_cmp.html","title":"_cmp","text":""},{"location":"autoapi/client/ayon_fusion/vendor/attr/_cmp.html#client.ayon_fusion.vendor.attr._cmp.cmp_using","title":"<code>cmp_using(eq=None, lt=None, le=None, gt=None, ge=None, require_same_type=True, class_name='Comparable')</code>","text":"<p>Create a class that can be passed into <code>attr.ib</code>'s <code>eq</code>, <code>order</code>, and <code>cmp</code> arguments to customize field comparison.</p> <p>The resulting class will have a full set of ordering methods if at least one of <code>{lt, le, gt, ge}</code> and <code>eq</code>  are provided.</p> <p>:param Optional[callable] eq: <code>callable</code> used to evaluate equality     of two objects. :param Optional[callable] lt: <code>callable</code> used to evaluate whether     one object is less than another object. :param Optional[callable] le: <code>callable</code> used to evaluate whether     one object is less than or equal to another object. :param Optional[callable] gt: <code>callable</code> used to evaluate whether     one object is greater than another object. :param Optional[callable] ge: <code>callable</code> used to evaluate whether     one object is greater than or equal to another object.</p> <p>:param bool require_same_type: When <code>True</code>, equality and ordering methods     will return <code>NotImplemented</code> if objects are not of the same type.</p> <p>:param Optional[str] class_name: Name of class. Defaults to 'Comparable'.</p> <p>See <code>comparison</code> for more details.</p> <p>.. versionadded:: 21.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_cmp.py</code> <pre><code>def cmp_using(\n    eq=None,\n    lt=None,\n    le=None,\n    gt=None,\n    ge=None,\n    require_same_type=True,\n    class_name=\"Comparable\",\n):\n    \"\"\"\n    Create a class that can be passed into `attr.ib`'s ``eq``, ``order``, and\n    ``cmp`` arguments to customize field comparison.\n\n    The resulting class will have a full set of ordering methods if\n    at least one of ``{lt, le, gt, ge}`` and ``eq``  are provided.\n\n    :param Optional[callable] eq: `callable` used to evaluate equality\n        of two objects.\n    :param Optional[callable] lt: `callable` used to evaluate whether\n        one object is less than another object.\n    :param Optional[callable] le: `callable` used to evaluate whether\n        one object is less than or equal to another object.\n    :param Optional[callable] gt: `callable` used to evaluate whether\n        one object is greater than another object.\n    :param Optional[callable] ge: `callable` used to evaluate whether\n        one object is greater than or equal to another object.\n\n    :param bool require_same_type: When `True`, equality and ordering methods\n        will return `NotImplemented` if objects are not of the same type.\n\n    :param Optional[str] class_name: Name of class. Defaults to 'Comparable'.\n\n    See `comparison` for more details.\n\n    .. versionadded:: 21.1.0\n    \"\"\"\n\n    body = {\n        \"__slots__\": [\"value\"],\n        \"__init__\": _make_init(),\n        \"_requirements\": [],\n        \"_is_comparable_to\": _is_comparable_to,\n    }\n\n    # Add operations.\n    num_order_functions = 0\n    has_eq_function = False\n\n    if eq is not None:\n        has_eq_function = True\n        body[\"__eq__\"] = _make_operator(\"eq\", eq)\n        body[\"__ne__\"] = _make_ne()\n\n    if lt is not None:\n        num_order_functions += 1\n        body[\"__lt__\"] = _make_operator(\"lt\", lt)\n\n    if le is not None:\n        num_order_functions += 1\n        body[\"__le__\"] = _make_operator(\"le\", le)\n\n    if gt is not None:\n        num_order_functions += 1\n        body[\"__gt__\"] = _make_operator(\"gt\", gt)\n\n    if ge is not None:\n        num_order_functions += 1\n        body[\"__ge__\"] = _make_operator(\"ge\", ge)\n\n    type_ = new_class(class_name, (object,), {}, lambda ns: ns.update(body))\n\n    # Add same type requirement.\n    if require_same_type:\n        type_._requirements.append(_check_same_type)\n\n    # Add total ordering if at least one operation was defined.\n    if 0 &lt; num_order_functions &lt; 4:\n        if not has_eq_function:\n            # functools.total_ordering requires __eq__ to be defined,\n            # so raise early error here to keep a nice stack.\n            raise ValueError(\n                \"eq must be define is order to complete ordering from \"\n                \"lt, le, gt, ge.\"\n            )\n        type_ = functools.total_ordering(type_)\n\n    return type_\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_compat.html","title":"_compat","text":""},{"location":"autoapi/client/ayon_fusion/vendor/attr/_compat.html#client.ayon_fusion.vendor.attr._compat.ReadOnlyDict","title":"<code>ReadOnlyDict</code>","text":"<p>               Bases: <code>IterableUserDict</code></p> <p>Best-effort read-only dict wrapper.</p> Source code in <code>client/ayon_fusion/vendor/attr/_compat.py</code> <pre><code>class ReadOnlyDict(IterableUserDict):\n    \"\"\"\n    Best-effort read-only dict wrapper.\n    \"\"\"\n\n    def __setitem__(self, key, val):\n        # We gently pretend we're a Python 3 mappingproxy.\n        raise TypeError(\n            \"'mappingproxy' object does not support item assignment\"\n        )\n\n    def update(self, _):\n        # We gently pretend we're a Python 3 mappingproxy.\n        raise AttributeError(\n            \"'mappingproxy' object has no attribute 'update'\"\n        )\n\n    def __delitem__(self, _):\n        # We gently pretend we're a Python 3 mappingproxy.\n        raise TypeError(\n            \"'mappingproxy' object does not support item deletion\"\n        )\n\n    def clear(self):\n        # We gently pretend we're a Python 3 mappingproxy.\n        raise AttributeError(\n            \"'mappingproxy' object has no attribute 'clear'\"\n        )\n\n    def pop(self, key, default=None):\n        # We gently pretend we're a Python 3 mappingproxy.\n        raise AttributeError(\n            \"'mappingproxy' object has no attribute 'pop'\"\n        )\n\n    def popitem(self):\n        # We gently pretend we're a Python 3 mappingproxy.\n        raise AttributeError(\n            \"'mappingproxy' object has no attribute 'popitem'\"\n        )\n\n    def setdefault(self, key, default=None):\n        # We gently pretend we're a Python 3 mappingproxy.\n        raise AttributeError(\n            \"'mappingproxy' object has no attribute 'setdefault'\"\n        )\n\n    def __repr__(self):\n        # Override to be identical to the Python 3 version.\n        return \"mappingproxy(\" + repr(self.data) + \")\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_compat.html#client.ayon_fusion.vendor.attr._compat.just_warn","title":"<code>just_warn(*args, **kw)</code>","text":"<p>We only warn on Python 3 because we are not aware of any concrete consequences of not setting the cell on Python 2.</p> Source code in <code>client/ayon_fusion/vendor/attr/_compat.py</code> <pre><code>def just_warn(*args, **kw):\n    \"\"\"\n    We only warn on Python 3 because we are not aware of any concrete\n    consequences of not setting the cell on Python 2.\n    \"\"\"\n    warnings.warn(\n        \"Running interpreter doesn't sufficiently support code object \"\n        \"introspection.  Some features like bare super() or accessing \"\n        \"__class__ will not work with slotted classes.\",\n        RuntimeWarning,\n        stacklevel=2,\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_compat.html#client.ayon_fusion.vendor.attr._compat.make_set_closure_cell","title":"<code>make_set_closure_cell()</code>","text":"<p>Return a function of two arguments (cell, value) which sets the value stored in the closure cell <code>cell</code> to <code>value</code>.</p> Source code in <code>client/ayon_fusion/vendor/attr/_compat.py</code> <pre><code>def make_set_closure_cell():\n    \"\"\"Return a function of two arguments (cell, value) which sets\n    the value stored in the closure cell `cell` to `value`.\n    \"\"\"\n    # pypy makes this easy. (It also supports the logic below, but\n    # why not do the easy/fast thing?)\n    if PYPY:\n\n        def set_closure_cell(cell, value):\n            cell.__setstate__((value,))\n\n        return set_closure_cell\n\n    # Otherwise gotta do it the hard way.\n\n    # Create a function that will set its first cellvar to `value`.\n    def set_first_cellvar_to(value):\n        x = value\n        return\n\n        # This function will be eliminated as dead code, but\n        # not before its reference to `x` forces `x` to be\n        # represented as a closure cell rather than a local.\n        def force_x_to_be_a_cell():  # pragma: no cover\n            return x\n\n    try:\n        # Extract the code object and make sure our assumptions about\n        # the closure behavior are correct.\n        if PY2:\n            co = set_first_cellvar_to.func_code\n        else:\n            co = set_first_cellvar_to.__code__\n        if co.co_cellvars != (\"x\",) or co.co_freevars != ():\n            raise AssertionError  # pragma: no cover\n\n        # Convert this code object to a code object that sets the\n        # function's first _freevar_ (not cellvar) to the argument.\n        if sys.version_info &gt;= (3, 8):\n            # CPython 3.8+ has an incompatible CodeType signature\n            # (added a posonlyargcount argument) but also added\n            # CodeType.replace() to do this without counting parameters.\n            set_first_freevar_code = co.replace(\n                co_cellvars=co.co_freevars, co_freevars=co.co_cellvars\n            )\n        else:\n            args = [co.co_argcount]\n            if not PY2:\n                args.append(co.co_kwonlyargcount)\n            args.extend(\n                [\n                    co.co_nlocals,\n                    co.co_stacksize,\n                    co.co_flags,\n                    co.co_code,\n                    co.co_consts,\n                    co.co_names,\n                    co.co_varnames,\n                    co.co_filename,\n                    co.co_name,\n                    co.co_firstlineno,\n                    co.co_lnotab,\n                    # These two arguments are reversed:\n                    co.co_cellvars,\n                    co.co_freevars,\n                ]\n            )\n            set_first_freevar_code = types.CodeType(*args)\n\n        def set_closure_cell(cell, value):\n            # Create a function using the set_first_freevar_code,\n            # whose first closure cell is `cell`. Calling it will\n            # change the value of that cell.\n            setter = types.FunctionType(\n                set_first_freevar_code, {}, \"setter\", (), (cell,)\n            )\n            # And call it to set the cell.\n            setter(value)\n\n        # Make sure it works on this interpreter:\n        def make_func_with_cell():\n            x = None\n\n            def func():\n                return x  # pragma: no cover\n\n            return func\n\n        if PY2:\n            cell = make_func_with_cell().func_closure[0]\n        else:\n            cell = make_func_with_cell().__closure__[0]\n        set_closure_cell(cell, 100)\n        if cell.cell_contents != 100:\n            raise AssertionError  # pragma: no cover\n\n    except Exception:\n        return just_warn\n    else:\n        return set_closure_cell\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_compat.html#client.ayon_fusion.vendor.attr._compat.new_class","title":"<code>new_class(name, bases, kwds, exec_body)</code>","text":"<p>A minimal stub of types.new_class that we need for make_class.</p> Source code in <code>client/ayon_fusion/vendor/attr/_compat.py</code> <pre><code>def new_class(name, bases, kwds, exec_body):\n    \"\"\"\n    A minimal stub of types.new_class that we need for make_class.\n    \"\"\"\n    ns = {}\n    exec_body(ns)\n\n    return type(name, bases, ns)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_config.html","title":"_config","text":""},{"location":"autoapi/client/ayon_fusion/vendor/attr/_config.html#client.ayon_fusion.vendor.attr._config.get_run_validators","title":"<code>get_run_validators()</code>","text":"<p>Return whether or not validators are run.</p> Source code in <code>client/ayon_fusion/vendor/attr/_config.py</code> <pre><code>def get_run_validators():\n    \"\"\"\n    Return whether or not validators are run.\n    \"\"\"\n    return _run_validators\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_config.html#client.ayon_fusion.vendor.attr._config.set_run_validators","title":"<code>set_run_validators(run)</code>","text":"<p>Set whether or not validators are run.  By default, they are run.</p> Source code in <code>client/ayon_fusion/vendor/attr/_config.py</code> <pre><code>def set_run_validators(run):\n    \"\"\"\n    Set whether or not validators are run.  By default, they are run.\n    \"\"\"\n    if not isinstance(run, bool):\n        raise TypeError(\"'run' must be bool.\")\n    global _run_validators\n    _run_validators = run\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_funcs.html","title":"_funcs","text":""},{"location":"autoapi/client/ayon_fusion/vendor/attr/_funcs.html#client.ayon_fusion.vendor.attr._funcs.asdict","title":"<code>asdict(inst, recurse=True, filter=None, dict_factory=dict, retain_collection_types=False, value_serializer=None)</code>","text":"<p>Return the <code>attrs</code> attribute values of inst as a dict.</p> <p>Optionally recurse into other <code>attrs</code>-decorated classes.</p> <p>:param inst: Instance of an <code>attrs</code>-decorated class. :param bool recurse: Recurse into classes that are also     <code>attrs</code>-decorated. :param callable filter: A callable whose return code determines whether an     attribute or element is included (<code>True</code>) or dropped (<code>False</code>).  Is     called with the <code>attr.Attribute</code> as the first argument and the     value as the second argument. :param callable dict_factory: A callable to produce dictionaries from.  For     example, to produce ordered dictionaries instead of normal Python     dictionaries, pass in <code>collections.OrderedDict</code>. :param bool retain_collection_types: Do not convert to <code>list</code> when     encountering an attribute whose type is <code>tuple</code> or <code>set</code>.  Only     meaningful if <code>recurse</code> is <code>True</code>. :param Optional[callable] value_serializer: A hook that is called for every     attribute or dict key/value.  It receives the current instance, field     and value and must return the (updated) value.  The hook is run after     the optional filter has been applied.</p> <p>:rtype: return type of dict_factory</p> <p>:raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>..  versionadded:: 16.0.0 dict_factory ..  versionadded:: 16.1.0 retain_collection_types ..  versionadded:: 20.3.0 value_serializer</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def asdict(\n    inst,\n    recurse=True,\n    filter=None,\n    dict_factory=dict,\n    retain_collection_types=False,\n    value_serializer=None,\n):\n    \"\"\"\n    Return the ``attrs`` attribute values of *inst* as a dict.\n\n    Optionally recurse into other ``attrs``-decorated classes.\n\n    :param inst: Instance of an ``attrs``-decorated class.\n    :param bool recurse: Recurse into classes that are also\n        ``attrs``-decorated.\n    :param callable filter: A callable whose return code determines whether an\n        attribute or element is included (``True``) or dropped (``False``).  Is\n        called with the `attr.Attribute` as the first argument and the\n        value as the second argument.\n    :param callable dict_factory: A callable to produce dictionaries from.  For\n        example, to produce ordered dictionaries instead of normal Python\n        dictionaries, pass in ``collections.OrderedDict``.\n    :param bool retain_collection_types: Do not convert to ``list`` when\n        encountering an attribute whose type is ``tuple`` or ``set``.  Only\n        meaningful if ``recurse`` is ``True``.\n    :param Optional[callable] value_serializer: A hook that is called for every\n        attribute or dict key/value.  It receives the current instance, field\n        and value and must return the (updated) value.  The hook is run *after*\n        the optional *filter* has been applied.\n\n    :rtype: return type of *dict_factory*\n\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    ..  versionadded:: 16.0.0 *dict_factory*\n    ..  versionadded:: 16.1.0 *retain_collection_types*\n    ..  versionadded:: 20.3.0 *value_serializer*\n    \"\"\"\n    attrs = fields(inst.__class__)\n    rv = dict_factory()\n    for a in attrs:\n        v = getattr(inst, a.name)\n        if filter is not None and not filter(a, v):\n            continue\n\n        if value_serializer is not None:\n            v = value_serializer(inst, a, v)\n\n        if recurse is True:\n            if has(v.__class__):\n                rv[a.name] = asdict(\n                    v,\n                    True,\n                    filter,\n                    dict_factory,\n                    retain_collection_types,\n                    value_serializer,\n                )\n            elif isinstance(v, (tuple, list, set, frozenset)):\n                cf = v.__class__ if retain_collection_types is True else list\n                rv[a.name] = cf(\n                    [\n                        _asdict_anything(\n                            i,\n                            filter,\n                            dict_factory,\n                            retain_collection_types,\n                            value_serializer,\n                        )\n                        for i in v\n                    ]\n                )\n            elif isinstance(v, dict):\n                df = dict_factory\n                rv[a.name] = df(\n                    (\n                        _asdict_anything(\n                            kk,\n                            filter,\n                            df,\n                            retain_collection_types,\n                            value_serializer,\n                        ),\n                        _asdict_anything(\n                            vv,\n                            filter,\n                            df,\n                            retain_collection_types,\n                            value_serializer,\n                        ),\n                    )\n                    for kk, vv in iteritems(v)\n                )\n            else:\n                rv[a.name] = v\n        else:\n            rv[a.name] = v\n    return rv\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_funcs.html#client.ayon_fusion.vendor.attr._funcs.assoc","title":"<code>assoc(inst, **changes)</code>","text":"<p>Copy inst and apply changes.</p> <p>:param inst: Instance of a class with <code>attrs</code> attributes. :param changes: Keyword changes in the new copy.</p> <p>:return: A copy of inst with changes incorporated.</p> <p>:raise attr.exceptions.AttrsAttributeNotFoundError: If attr_name couldn't     be found on cls. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>..  deprecated:: 17.1.0     Use <code>evolve</code> instead.</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def assoc(inst, **changes):\n    \"\"\"\n    Copy *inst* and apply *changes*.\n\n    :param inst: Instance of a class with ``attrs`` attributes.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise attr.exceptions.AttrsAttributeNotFoundError: If *attr_name* couldn't\n        be found on *cls*.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    ..  deprecated:: 17.1.0\n        Use `evolve` instead.\n    \"\"\"\n    import warnings\n\n    warnings.warn(\n        \"assoc is deprecated and will be removed after 2018/01.\",\n        DeprecationWarning,\n        stacklevel=2,\n    )\n    new = copy.copy(inst)\n    attrs = fields(inst.__class__)\n    for k, v in iteritems(changes):\n        a = getattr(attrs, k, NOTHING)\n        if a is NOTHING:\n            raise AttrsAttributeNotFoundError(\n                \"{k} is not an attrs attribute on {cl}.\".format(\n                    k=k, cl=new.__class__\n                )\n            )\n        _obj_setattr(new, k, v)\n    return new\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_funcs.html#client.ayon_fusion.vendor.attr._funcs.astuple","title":"<code>astuple(inst, recurse=True, filter=None, tuple_factory=tuple, retain_collection_types=False)</code>","text":"<p>Return the <code>attrs</code> attribute values of inst as a tuple.</p> <p>Optionally recurse into other <code>attrs</code>-decorated classes.</p> <p>:param inst: Instance of an <code>attrs</code>-decorated class. :param bool recurse: Recurse into classes that are also     <code>attrs</code>-decorated. :param callable filter: A callable whose return code determines whether an     attribute or element is included (<code>True</code>) or dropped (<code>False</code>).  Is     called with the <code>attr.Attribute</code> as the first argument and the     value as the second argument. :param callable tuple_factory: A callable to produce tuples from.  For     example, to produce lists instead of tuples. :param bool retain_collection_types: Do not convert to <code>list</code>     or <code>dict</code> when encountering an attribute which type is     <code>tuple</code>, <code>dict</code> or <code>set</code>.  Only meaningful if <code>recurse</code> is     <code>True</code>.</p> <p>:rtype: return type of tuple_factory</p> <p>:raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>..  versionadded:: 16.2.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def astuple(\n    inst,\n    recurse=True,\n    filter=None,\n    tuple_factory=tuple,\n    retain_collection_types=False,\n):\n    \"\"\"\n    Return the ``attrs`` attribute values of *inst* as a tuple.\n\n    Optionally recurse into other ``attrs``-decorated classes.\n\n    :param inst: Instance of an ``attrs``-decorated class.\n    :param bool recurse: Recurse into classes that are also\n        ``attrs``-decorated.\n    :param callable filter: A callable whose return code determines whether an\n        attribute or element is included (``True``) or dropped (``False``).  Is\n        called with the `attr.Attribute` as the first argument and the\n        value as the second argument.\n    :param callable tuple_factory: A callable to produce tuples from.  For\n        example, to produce lists instead of tuples.\n    :param bool retain_collection_types: Do not convert to ``list``\n        or ``dict`` when encountering an attribute which type is\n        ``tuple``, ``dict`` or ``set``.  Only meaningful if ``recurse`` is\n        ``True``.\n\n    :rtype: return type of *tuple_factory*\n\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    ..  versionadded:: 16.2.0\n    \"\"\"\n    attrs = fields(inst.__class__)\n    rv = []\n    retain = retain_collection_types  # Very long. :/\n    for a in attrs:\n        v = getattr(inst, a.name)\n        if filter is not None and not filter(a, v):\n            continue\n        if recurse is True:\n            if has(v.__class__):\n                rv.append(\n                    astuple(\n                        v,\n                        recurse=True,\n                        filter=filter,\n                        tuple_factory=tuple_factory,\n                        retain_collection_types=retain,\n                    )\n                )\n            elif isinstance(v, (tuple, list, set, frozenset)):\n                cf = v.__class__ if retain is True else list\n                rv.append(\n                    cf(\n                        [\n                            astuple(\n                                j,\n                                recurse=True,\n                                filter=filter,\n                                tuple_factory=tuple_factory,\n                                retain_collection_types=retain,\n                            )\n                            if has(j.__class__)\n                            else j\n                            for j in v\n                        ]\n                    )\n                )\n            elif isinstance(v, dict):\n                df = v.__class__ if retain is True else dict\n                rv.append(\n                    df(\n                        (\n                            astuple(\n                                kk,\n                                tuple_factory=tuple_factory,\n                                retain_collection_types=retain,\n                            )\n                            if has(kk.__class__)\n                            else kk,\n                            astuple(\n                                vv,\n                                tuple_factory=tuple_factory,\n                                retain_collection_types=retain,\n                            )\n                            if has(vv.__class__)\n                            else vv,\n                        )\n                        for kk, vv in iteritems(v)\n                    )\n                )\n            else:\n                rv.append(v)\n        else:\n            rv.append(v)\n\n    return rv if tuple_factory is list else tuple_factory(rv)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_funcs.html#client.ayon_fusion.vendor.attr._funcs.evolve","title":"<code>evolve(inst, **changes)</code>","text":"<p>Create a new instance, based on inst with changes applied.</p> <p>:param inst: Instance of a class with <code>attrs</code> attributes. :param changes: Keyword changes in the new copy.</p> <p>:return: A copy of inst with changes incorporated.</p> <p>:raise TypeError: If attr_name couldn't be found in the class     <code>__init__</code>. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>..  versionadded:: 17.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def evolve(inst, **changes):\n    \"\"\"\n    Create a new instance, based on *inst* with *changes* applied.\n\n    :param inst: Instance of a class with ``attrs`` attributes.\n    :param changes: Keyword changes in the new copy.\n\n    :return: A copy of inst with *changes* incorporated.\n\n    :raise TypeError: If *attr_name* couldn't be found in the class\n        ``__init__``.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    ..  versionadded:: 17.1.0\n    \"\"\"\n    cls = inst.__class__\n    attrs = fields(cls)\n    for a in attrs:\n        if not a.init:\n            continue\n        attr_name = a.name  # To deal with private attributes.\n        init_name = attr_name if attr_name[0] != \"_\" else attr_name[1:]\n        if init_name not in changes:\n            changes[init_name] = getattr(inst, attr_name)\n\n    return cls(**changes)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_funcs.html#client.ayon_fusion.vendor.attr._funcs.has","title":"<code>has(cls)</code>","text":"<p>Check whether cls is a class with <code>attrs</code> attributes.</p> <p>:param type cls: Class to introspect. :raise TypeError: If cls is not a class.</p> <p>:rtype: bool</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def has(cls):\n    \"\"\"\n    Check whether *cls* is a class with ``attrs`` attributes.\n\n    :param type cls: Class to introspect.\n    :raise TypeError: If *cls* is not a class.\n\n    :rtype: bool\n    \"\"\"\n    return getattr(cls, \"__attrs_attrs__\", None) is not None\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_funcs.html#client.ayon_fusion.vendor.attr._funcs.resolve_types","title":"<code>resolve_types(cls, globalns=None, localns=None, attribs=None)</code>","text":"<p>Resolve any strings and forward annotations in type annotations.</p> <p>This is only required if you need concrete types in <code>Attribute</code>'s type field. In other words, you don't need to resolve your types if you only use them for static type checking.</p> <p>With no arguments, names will be looked up in the module in which the class was created. If this is not what you want, e.g. if the name only exists inside a method, you may pass globalns or localns to specify other dictionaries in which to look up these names. See the docs of <code>typing.get_type_hints</code> for more details.</p> <p>:param type cls: Class to resolve. :param Optional[dict] globalns: Dictionary containing global variables. :param Optional[dict] localns: Dictionary containing local variables. :param Optional[list] attribs: List of attribs for the given class.     This is necessary when calling from inside a <code>field_transformer</code>     since cls is not an <code>attrs</code> class yet.</p> <p>:raise TypeError: If cls is not a class. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class and you didn't pass any attribs. :raise NameError: If types cannot be resolved because of missing variables.</p> <p>:returns: cls so you can use this function also as a class decorator.     Please note that you have to apply it after <code>attr.s</code>. That means     the decorator has to come in the line before <code>attr.s</code>.</p> <p>..  versionadded:: 20.1.0 ..  versionadded:: 21.1.0 attribs</p> Source code in <code>client/ayon_fusion/vendor/attr/_funcs.py</code> <pre><code>def resolve_types(cls, globalns=None, localns=None, attribs=None):\n    \"\"\"\n    Resolve any strings and forward annotations in type annotations.\n\n    This is only required if you need concrete types in `Attribute`'s *type*\n    field. In other words, you don't need to resolve your types if you only\n    use them for static type checking.\n\n    With no arguments, names will be looked up in the module in which the class\n    was created. If this is not what you want, e.g. if the name only exists\n    inside a method, you may pass *globalns* or *localns* to specify other\n    dictionaries in which to look up these names. See the docs of\n    `typing.get_type_hints` for more details.\n\n    :param type cls: Class to resolve.\n    :param Optional[dict] globalns: Dictionary containing global variables.\n    :param Optional[dict] localns: Dictionary containing local variables.\n    :param Optional[list] attribs: List of attribs for the given class.\n        This is necessary when calling from inside a ``field_transformer``\n        since *cls* is not an ``attrs`` class yet.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class and you didn't pass any attribs.\n    :raise NameError: If types cannot be resolved because of missing variables.\n\n    :returns: *cls* so you can use this function also as a class decorator.\n        Please note that you have to apply it **after** `attr.s`. That means\n        the decorator has to come in the line **before** `attr.s`.\n\n    ..  versionadded:: 20.1.0\n    ..  versionadded:: 21.1.0 *attribs*\n\n    \"\"\"\n    try:\n        # Since calling get_type_hints is expensive we cache whether we've\n        # done it already.\n        cls.__attrs_types_resolved__\n    except AttributeError:\n        import typing\n\n        hints = typing.get_type_hints(cls, globalns=globalns, localns=localns)\n        for field in fields(cls) if attribs is None else attribs:\n            if field.name in hints:\n                # Since fields have been frozen we must work around it.\n                _obj_setattr(field, \"type\", hints[field.name])\n        cls.__attrs_types_resolved__ = True\n\n    # Return the class so you can use it as a decorator too.\n    return cls\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html","title":"_make","text":""},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.Attribute","title":"<code>Attribute = _add_hash(_add_eq(_add_repr(Attribute, attrs=_a), attrs=[a for a in _a if a.name != 'inherited']), attrs=[a for a in _a if a.hash and a.name != 'inherited'])</code>  <code>module-attribute</code>","text":"<p>Read-only representation of an attribute.</p> <p>Instances of this class are frequently used for introspection purposes like:</p> <ul> <li><code>fields</code> returns a tuple of them.</li> <li>Validators get them passed as the first argument.</li> <li>The field transformer hook receives a list of them.</li> </ul> <p>:attribute name: The name of the attribute. :attribute inherited: Whether or not that attribute has been inherited from     a base class.</p> <p>Plus all arguments of <code>attr.ib</code> (except for <code>factory</code> which is only syntactic sugar for <code>default=Factory(...)</code>.</p> <p>.. versionadded:: 20.1.0 inherited .. versionadded:: 20.1.0 on_setattr .. versionchanged:: 20.2.0 inherited is not taken into account for     equality checks and hashing anymore. .. versionadded:: 21.1.0 eq_key and order_key</p> <p>For the full version history of the fields, see <code>attr.ib</code>.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.Factory","title":"<code>Factory = _add_hash(_add_eq(_add_repr(Factory, attrs=_f), attrs=_f), attrs=_f)</code>  <code>module-attribute</code>","text":"<p>Stores a factory callable.</p> <p>If passed as the default value to <code>attr.ib</code>, the factory is used to generate a new value.</p> <p>:param callable factory: A callable that takes either none or exactly one     mandatory positional argument depending on takes_self. :param bool takes_self: Pass the partially initialized instance that is     being initialized as a positional argument.</p> <p>.. versionadded:: 17.1.0  takes_self</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.NOTHING","title":"<code>NOTHING = _Nothing()</code>  <code>module-attribute</code>","text":"<p>Sentinel to indicate the lack of a value when <code>None</code> is ambiguous.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.and_","title":"<code>and_(*validators)</code>","text":"<p>A validator that composes multiple validators into one.</p> <p>When called on a value, it runs all wrapped validators.</p> <p>:param callables validators: Arbitrary number of validators.</p> <p>.. versionadded:: 17.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def and_(*validators):\n    \"\"\"\n    A validator that composes multiple validators into one.\n\n    When called on a value, it runs all wrapped validators.\n\n    :param callables validators: Arbitrary number of validators.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n    vals = []\n    for validator in validators:\n        vals.extend(\n            validator._validators\n            if isinstance(validator, _AndValidator)\n            else [validator]\n        )\n\n    return _AndValidator(tuple(vals))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.attrib","title":"<code>attrib(default=NOTHING, validator=None, repr=True, cmp=None, hash=None, init=True, metadata=None, type=None, converter=None, factory=None, kw_only=False, eq=None, order=None, on_setattr=None)</code>","text":"<p>Create a new attribute on a class.</p> <p>..  warning::</p> <pre><code>Does *not* do anything unless the class is also decorated with\n`attr.s`!\n</code></pre> <p>:param default: A value that is used if an <code>attrs</code>-generated <code>__init__</code>     is used and no value is passed while instantiating or the attribute is     excluded using <code>init=False</code>.</p> <pre><code>If the value is an instance of `Factory`, its callable will be\nused to construct a new value (useful for mutable data types like lists\nor dicts).\n\nIf a default is not set (or set manually to `attr.NOTHING`), a value\n*must* be supplied when instantiating; otherwise a `TypeError`\nwill be raised.\n\nThe default can also be set using decorator notation as shown below.\n</code></pre> <p>:type default: Any value</p> <p>:param callable factory: Syntactic sugar for     <code>default=attr.Factory(factory)</code>.</p> <p>:param validator: <code>callable</code> that is called by <code>attrs</code>-generated     <code>__init__</code> methods after the instance has been initialized.  They     receive the initialized instance, the <code>Attribute</code>, and the     passed value.</p> <pre><code>The return value is *not* inspected so the validator has to throw an\nexception itself.\n\nIf a `list` is passed, its items are treated as validators and must\nall pass.\n\nValidators can be globally disabled and re-enabled using\n`get_run_validators`.\n\nThe validator can also be set using decorator notation as shown below.\n</code></pre> <p>:type validator: <code>callable</code> or a <code>list</code> of <code>callable</code>\\ s.</p> <p>:param repr: Include this attribute in the generated <code>__repr__</code>     method. If <code>True</code>, include the attribute; if <code>False</code>, omit it. By     default, the built-in <code>repr()</code> function is used. To override how the     attribute value is formatted, pass a <code>callable</code> that takes a single     value and returns a string. Note that the resulting string is used     as-is, i.e. it will be used directly instead of calling <code>repr()</code>     (the default). :type repr: a <code>bool</code> or a <code>callable</code> to use a custom function.</p> <p>:param eq: If <code>True</code> (default), include this attribute in the     generated <code>__eq__</code> and <code>__ne__</code> methods that check two instances     for equality. To override how the attribute value is compared,     pass a <code>callable</code> that takes a single value and returns the value     to be compared. :type eq: a <code>bool</code> or a <code>callable</code>.</p> <p>:param order: If <code>True</code> (default), include this attributes in the     generated <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code> and <code>__ge__</code> methods.     To override how the attribute value is ordered,     pass a <code>callable</code> that takes a single value and returns the value     to be ordered. :type order: a <code>bool</code> or a <code>callable</code>.</p> <p>:param cmp: Setting cmp is equivalent to setting eq and order to the     same value. Must not be mixed with eq or order. :type cmp: a <code>bool</code> or a <code>callable</code>.</p> <p>:param Optional[bool] hash: Include this attribute in the generated     <code>__hash__</code> method.  If <code>None</code> (default), mirror eq's value.  This     is the correct behavior according the Python spec.  Setting this value     to anything else than <code>None</code> is discouraged. :param bool init: Include this attribute in the generated <code>__init__</code>     method.  It is possible to set this to <code>False</code> and set a default     value.  In that case this attributed is unconditionally initialized     with the specified default value or factory. :param callable converter: <code>callable</code> that is called by     <code>attrs</code>-generated <code>__init__</code> methods to convert attribute's value     to the desired format.  It is given the passed-in value, and the     returned value will be used as the new value of the attribute.  The     value is converted before being passed to the validator, if any. :param metadata: An arbitrary mapping, to be used by third-party     components.  See <code>extending_metadata</code>. :param type: The type of the attribute.  In Python 3.6 or greater, the     preferred method to specify the type is using a variable annotation     (see <code>PEP 526 &lt;https://www.python.org/dev/peps/pep-0526/&gt;</code>_).     This argument is provided for backward compatibility.     Regardless of the approach used, the type will be stored on     <code>Attribute.type</code>.</p> <pre><code>Please note that ``attrs`` doesn't do anything with this metadata by\nitself. You can use it as part of your own code or for\n`static type checking &lt;types&gt;`.\n</code></pre> <p>:param kw_only: Make this attribute keyword-only (Python 3+)     in the generated <code>__init__</code> (if <code>init</code> is <code>False</code>, this     parameter is ignored). :param on_setattr: Allows to overwrite the on_setattr setting from     <code>attr.s</code>. If left <code>None</code>, the on_setattr value from <code>attr.s</code> is used.     Set to <code>attr.setters.NO_OP</code> to run no <code>setattr</code> hooks for this     attribute -- regardless of the setting in <code>attr.s</code>. :type on_setattr: <code>callable</code>, or a list of callables, or <code>None</code>, or     <code>attr.setters.NO_OP</code></p> <p>.. versionadded:: 15.2.0 convert .. versionadded:: 16.3.0 metadata .. versionchanged:: 17.1.0 validator can be a <code>list</code> now. .. versionchanged:: 17.1.0    hash is <code>None</code> and therefore mirrors eq by default. .. versionadded:: 17.3.0 type .. deprecated:: 17.4.0 convert .. versionadded:: 17.4.0 converter as a replacement for the deprecated    convert to achieve consistency with other noun-based arguments. .. versionadded:: 18.1.0    <code>factory=f</code> is syntactic sugar for <code>default=attr.Factory(f)</code>. .. versionadded:: 18.2.0 kw_only .. versionchanged:: 19.2.0 convert keyword argument removed. .. versionchanged:: 19.2.0 repr also accepts a custom callable. .. deprecated:: 19.2.0 cmp Removal on or after 2021-06-01. .. versionadded:: 19.2.0 eq and order .. versionadded:: 20.1.0 on_setattr .. versionchanged:: 20.3.0 kw_only backported to Python 2 .. versionchanged:: 21.1.0    eq, order, and cmp also accept a custom callable .. versionchanged:: 21.1.0 cmp undeprecated</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def attrib(\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    cmp=None,\n    hash=None,\n    init=True,\n    metadata=None,\n    type=None,\n    converter=None,\n    factory=None,\n    kw_only=False,\n    eq=None,\n    order=None,\n    on_setattr=None,\n):\n    \"\"\"\n    Create a new attribute on a class.\n\n    ..  warning::\n\n        Does *not* do anything unless the class is also decorated with\n        `attr.s`!\n\n    :param default: A value that is used if an ``attrs``-generated ``__init__``\n        is used and no value is passed while instantiating or the attribute is\n        excluded using ``init=False``.\n\n        If the value is an instance of `Factory`, its callable will be\n        used to construct a new value (useful for mutable data types like lists\n        or dicts).\n\n        If a default is not set (or set manually to `attr.NOTHING`), a value\n        *must* be supplied when instantiating; otherwise a `TypeError`\n        will be raised.\n\n        The default can also be set using decorator notation as shown below.\n\n    :type default: Any value\n\n    :param callable factory: Syntactic sugar for\n        ``default=attr.Factory(factory)``.\n\n    :param validator: `callable` that is called by ``attrs``-generated\n        ``__init__`` methods after the instance has been initialized.  They\n        receive the initialized instance, the `Attribute`, and the\n        passed value.\n\n        The return value is *not* inspected so the validator has to throw an\n        exception itself.\n\n        If a `list` is passed, its items are treated as validators and must\n        all pass.\n\n        Validators can be globally disabled and re-enabled using\n        `get_run_validators`.\n\n        The validator can also be set using decorator notation as shown below.\n\n    :type validator: `callable` or a `list` of `callable`\\\\ s.\n\n    :param repr: Include this attribute in the generated ``__repr__``\n        method. If ``True``, include the attribute; if ``False``, omit it. By\n        default, the built-in ``repr()`` function is used. To override how the\n        attribute value is formatted, pass a ``callable`` that takes a single\n        value and returns a string. Note that the resulting string is used\n        as-is, i.e. it will be used directly *instead* of calling ``repr()``\n        (the default).\n    :type repr: a `bool` or a `callable` to use a custom function.\n\n    :param eq: If ``True`` (default), include this attribute in the\n        generated ``__eq__`` and ``__ne__`` methods that check two instances\n        for equality. To override how the attribute value is compared,\n        pass a ``callable`` that takes a single value and returns the value\n        to be compared.\n    :type eq: a `bool` or a `callable`.\n\n    :param order: If ``True`` (default), include this attributes in the\n        generated ``__lt__``, ``__le__``, ``__gt__`` and ``__ge__`` methods.\n        To override how the attribute value is ordered,\n        pass a ``callable`` that takes a single value and returns the value\n        to be ordered.\n    :type order: a `bool` or a `callable`.\n\n    :param cmp: Setting *cmp* is equivalent to setting *eq* and *order* to the\n        same value. Must not be mixed with *eq* or *order*.\n    :type cmp: a `bool` or a `callable`.\n\n    :param Optional[bool] hash: Include this attribute in the generated\n        ``__hash__`` method.  If ``None`` (default), mirror *eq*'s value.  This\n        is the correct behavior according the Python spec.  Setting this value\n        to anything else than ``None`` is *discouraged*.\n    :param bool init: Include this attribute in the generated ``__init__``\n        method.  It is possible to set this to ``False`` and set a default\n        value.  In that case this attributed is unconditionally initialized\n        with the specified default value or factory.\n    :param callable converter: `callable` that is called by\n        ``attrs``-generated ``__init__`` methods to convert attribute's value\n        to the desired format.  It is given the passed-in value, and the\n        returned value will be used as the new value of the attribute.  The\n        value is converted before being passed to the validator, if any.\n    :param metadata: An arbitrary mapping, to be used by third-party\n        components.  See `extending_metadata`.\n    :param type: The type of the attribute.  In Python 3.6 or greater, the\n        preferred method to specify the type is using a variable annotation\n        (see `PEP 526 &lt;https://www.python.org/dev/peps/pep-0526/&gt;`_).\n        This argument is provided for backward compatibility.\n        Regardless of the approach used, the type will be stored on\n        ``Attribute.type``.\n\n        Please note that ``attrs`` doesn't do anything with this metadata by\n        itself. You can use it as part of your own code or for\n        `static type checking &lt;types&gt;`.\n    :param kw_only: Make this attribute keyword-only (Python 3+)\n        in the generated ``__init__`` (if ``init`` is ``False``, this\n        parameter is ignored).\n    :param on_setattr: Allows to overwrite the *on_setattr* setting from\n        `attr.s`. If left `None`, the *on_setattr* value from `attr.s` is used.\n        Set to `attr.setters.NO_OP` to run **no** `setattr` hooks for this\n        attribute -- regardless of the setting in `attr.s`.\n    :type on_setattr: `callable`, or a list of callables, or `None`, or\n        `attr.setters.NO_OP`\n\n    .. versionadded:: 15.2.0 *convert*\n    .. versionadded:: 16.3.0 *metadata*\n    .. versionchanged:: 17.1.0 *validator* can be a ``list`` now.\n    .. versionchanged:: 17.1.0\n       *hash* is ``None`` and therefore mirrors *eq* by default.\n    .. versionadded:: 17.3.0 *type*\n    .. deprecated:: 17.4.0 *convert*\n    .. versionadded:: 17.4.0 *converter* as a replacement for the deprecated\n       *convert* to achieve consistency with other noun-based arguments.\n    .. versionadded:: 18.1.0\n       ``factory=f`` is syntactic sugar for ``default=attr.Factory(f)``.\n    .. versionadded:: 18.2.0 *kw_only*\n    .. versionchanged:: 19.2.0 *convert* keyword argument removed.\n    .. versionchanged:: 19.2.0 *repr* also accepts a custom callable.\n    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n    .. versionadded:: 19.2.0 *eq* and *order*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionchanged:: 20.3.0 *kw_only* backported to Python 2\n    .. versionchanged:: 21.1.0\n       *eq*, *order*, and *cmp* also accept a custom callable\n    .. versionchanged:: 21.1.0 *cmp* undeprecated\n    \"\"\"\n    eq, eq_key, order, order_key = _determine_attrib_eq_order(\n        cmp, eq, order, True\n    )\n\n    if hash is not None and hash is not True and hash is not False:\n        raise TypeError(\n            \"Invalid value for hash.  Must be True, False, or None.\"\n        )\n\n    if factory is not None:\n        if default is not NOTHING:\n            raise ValueError(\n                \"The `default` and `factory` arguments are mutually \"\n                \"exclusive.\"\n            )\n        if not callable(factory):\n            raise ValueError(\"The `factory` argument must be a callable.\")\n        default = Factory(factory)\n\n    if metadata is None:\n        metadata = {}\n\n    # Apply syntactic sugar by auto-wrapping.\n    if isinstance(on_setattr, (list, tuple)):\n        on_setattr = setters.pipe(*on_setattr)\n\n    if validator and isinstance(validator, (list, tuple)):\n        validator = and_(*validator)\n\n    if converter and isinstance(converter, (list, tuple)):\n        converter = pipe(*converter)\n\n    return _CountingAttr(\n        default=default,\n        validator=validator,\n        repr=repr,\n        cmp=None,\n        hash=hash,\n        init=init,\n        converter=converter,\n        metadata=metadata,\n        type=type,\n        kw_only=kw_only,\n        eq=eq,\n        eq_key=eq_key,\n        order=order,\n        order_key=order_key,\n        on_setattr=on_setattr,\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.attrs","title":"<code>attrs(maybe_cls=None, these=None, repr_ns=None, repr=None, cmp=None, hash=None, init=None, slots=False, frozen=False, weakref_slot=True, str=False, auto_attribs=False, kw_only=False, cache_hash=False, auto_exc=False, eq=None, order=None, auto_detect=False, collect_by_mro=False, getstate_setstate=None, on_setattr=None, field_transformer=None)</code>","text":"<p>A class decorator that adds <code>dunder &lt;https://wiki.python.org/moin/DunderAlias&gt;</code>_\\ -methods according to the specified attributes using <code>attr.ib</code> or the these argument.</p> <p>:param these: A dictionary of name to <code>attr.ib</code> mappings.  This is     useful to avoid the definition of your attributes within the class body     because you can't (e.g. if you want to add <code>__repr__</code> methods to     Django models) or don't want to.</p> <pre><code>If *these* is not ``None``, ``attrs`` will *not* search the class body\nfor attributes and will *not* remove any attributes from it.\n\nIf *these* is an ordered dict (`dict` on Python 3.6+,\n`collections.OrderedDict` otherwise), the order is deduced from\nthe order of the attributes inside *these*.  Otherwise the order\nof the definition of the attributes is used.\n</code></pre> <p>:type these: <code>dict</code> of <code>str</code> to <code>attr.ib</code></p> <p>:param str repr_ns: When using nested classes, there's no way in Python 2     to automatically detect that.  Therefore it's possible to set the     namespace explicitly for a more meaningful <code>repr</code> output. :param bool auto_detect: Instead of setting the init, repr, eq,     order, and hash arguments explicitly, assume they are set to     <code>True</code> unless any of the involved methods for one of the     arguments is implemented in the current class (i.e. it is not     inherited from some base class).</p> <pre><code>So for example by implementing ``__eq__`` on a class yourself,\n``attrs`` will deduce ``eq=False`` and will create *neither*\n``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible\n``__ne__`` by default, so it *should* be enough to only implement\n``__eq__`` in most cases).\n\n.. warning::\n\n   If you prevent ``attrs`` from creating the ordering methods for you\n   (``order=False``, e.g. by implementing ``__le__``), it becomes\n   *your* responsibility to make sure its ordering is sound. The best\n   way is to use the `functools.total_ordering` decorator.\n\n\nPassing ``True`` or ``False`` to *init*, *repr*, *eq*, *order*,\n*cmp*, or *hash* overrides whatever *auto_detect* would determine.\n\n*auto_detect* requires Python 3. Setting it ``True`` on Python 2 raises\na `PythonTooOldError`.\n</code></pre> <p>:param bool repr: Create a <code>__repr__</code> method with a human readable     representation of <code>attrs</code> attributes.. :param bool str: Create a <code>__str__</code> method that is identical to     <code>__repr__</code>.  This is usually not necessary except for     <code>Exception</code>\\ s. :param Optional[bool] eq: If <code>True</code> or <code>None</code> (default), add <code>__eq__</code>     and <code>__ne__</code> methods that check two instances for equality.</p> <pre><code>They compare the instances as if they were tuples of their ``attrs``\nattributes if and only if the types of both classes are *identical*!\n</code></pre> <p>:param Optional[bool] order: If <code>True</code>, add <code>__lt__</code>, <code>__le__</code>,     <code>__gt__</code>, and <code>__ge__</code> methods that behave like eq above and     allow instances to be ordered. If <code>None</code> (default) mirror value of     eq. :param Optional[bool] cmp: Setting cmp is equivalent to setting eq     and order to the same value. Must not be mixed with eq or order. :param Optional[bool] hash: If <code>None</code> (default), the <code>__hash__</code> method     is generated according how eq and frozen are set.</p> <pre><code>1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.\n2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to\n   None, marking it unhashable (which it is).\n3. If *eq* is False, ``__hash__`` will be left untouched meaning the\n   ``__hash__`` method of the base class will be used (if base class is\n   ``object``, this means it will fall back to id-based hashing.).\n\nAlthough not recommended, you can decide for yourself and force\n``attrs`` to create one (e.g. if the class is immutable even though you\ndidn't freeze it programmatically) by passing ``True`` or not.  Both of\nthese cases are rather special and should be used carefully.\n\nSee our documentation on `hashing`, Python's documentation on\n`object.__hash__`, and the `GitHub issue that led to the default \\\nbehavior &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more\ndetails.\n</code></pre> <p>:param bool init: Create a <code>__init__</code> method that initializes the     <code>attrs</code> attributes. Leading underscores are stripped for the argument     name. If a <code>__attrs_pre_init__</code> method exists on the class, it will     be called before the class is initialized. If a <code>__attrs_post_init__</code>     method exists on the class, it will be called after the class is fully     initialized.</p> <pre><code>If ``init`` is ``False``, an ``__attrs_init__`` method will be\ninjected instead. This allows you to define a custom ``__init__``\nmethod that can do pre-init work such as ``super().__init__()``,\nand then call ``__attrs_init__()`` and ``__attrs_post_init__()``.\n</code></pre> <p>:param bool slots: Create a <code>slotted class &lt;slotted classes&gt;</code> that's more     memory-efficient. Slotted classes are generally superior to the default     dict classes, but have some gotchas you should know about, so we     encourage you to read the <code>glossary entry &lt;slotted classes&gt;</code>. :param bool frozen: Make instances immutable after initialization.  If     someone attempts to modify a frozen instance,     <code>attr.exceptions.FrozenInstanceError</code> is raised.</p> <pre><code>.. note::\n\n    1. This is achieved by installing a custom ``__setattr__`` method\n       on your class, so you can't implement your own.\n\n    2. True immutability is impossible in Python.\n\n    3. This *does* have a minor a runtime performance `impact\n       &lt;how-frozen&gt;` when initializing new instances.  In other words:\n       ``__init__`` is slightly slower with ``frozen=True``.\n\n    4. If a class is frozen, you cannot modify ``self`` in\n       ``__attrs_post_init__`` or a self-written ``__init__``. You can\n       circumvent that limitation by using\n       ``object.__setattr__(self, \"attribute_name\", value)``.\n\n    5. Subclasses of a frozen class are frozen too.\n</code></pre> <p>:param bool weakref_slot: Make instances weak-referenceable.  This has no     effect unless <code>slots</code> is also enabled. :param bool auto_attribs: If <code>True</code>, collect <code>PEP 526</code>_-annotated     attributes (Python 3.6 and later only) from the class body.</p> <pre><code>In this case, you **must** annotate every field.  If ``attrs``\nencounters a field that is set to an `attr.ib` but lacks a type\nannotation, an `attr.exceptions.UnannotatedAttributeError` is\nraised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don't\nwant to set a type.\n\nIf you assign a value to those attributes (e.g. ``x: int = 42``), that\nvalue becomes the default value like if it were passed using\n``attr.ib(default=42)``.  Passing an instance of `Factory` also\nworks as expected in most cases (see warning below).\n\nAttributes annotated as `typing.ClassVar`, and attributes that are\nneither annotated nor set to an `attr.ib` are **ignored**.\n\n.. warning::\n   For features that use the attribute name to create decorators (e.g.\n   `validators &lt;validators&gt;`), you still *must* assign `attr.ib` to\n   them. Otherwise Python will either not find the name or try to use\n   the default value to call e.g. ``validator`` on it.\n\n   These errors can be quite confusing and probably the most common bug\n   report on our bug tracker.\n\n.. _`PEP 526`: https://www.python.org/dev/peps/pep-0526/\n</code></pre> <p>:param bool kw_only: Make all attributes keyword-only (Python 3+)     in the generated <code>__init__</code> (if <code>init</code> is <code>False</code>, this     parameter is ignored). :param bool cache_hash: Ensure that the object's hash code is computed     only once and stored on the object.  If this is set to <code>True</code>,     hashing must be either explicitly or implicitly enabled for this     class.  If the hash code is cached, avoid any reassignments of     fields involved in hash code computation or mutations of the objects     those fields point to after object creation.  If such changes occur,     the behavior of the object's hash code is undefined. :param bool auto_exc: If the class subclasses <code>BaseException</code>     (which implicitly includes any subclass of any exception), the     following happens to behave like a well-behaved Python exceptions     class:</p> <pre><code>- the values for *eq*, *order*, and *hash* are ignored and the\n  instances compare and hash by the instance's ids (N.B. ``attrs`` will\n  *not* remove existing implementations of ``__hash__`` or the equality\n  methods. It just won't add own ones.),\n- all attributes that are either passed into ``__init__`` or have a\n  default value are additionally available as a tuple in the ``args``\n  attribute,\n- the value of *str* is ignored leaving ``__str__`` to base classes.\n</code></pre> <p>:param bool collect_by_mro: Setting this to <code>True</code> fixes the way <code>attrs</code>    collects attributes from base classes.  The default behavior is    incorrect in certain cases of multiple inheritance.  It should be on by    default but is kept off for backward-compatability.</p> <p>See issue <code>#428 &lt;https://github.com/python-attrs/attrs/issues/428&gt;</code>_ for    more details.</p> <p>:param Optional[bool] getstate_setstate:    .. note::       This is usually only interesting for slotted classes and you should       probably just set auto_detect to <code>True</code>.</p> <p>If <code>True</code>, <code>__getstate__</code> and    <code>__setstate__</code> are generated and attached to the class. This is    necessary for slotted classes to be pickleable. If left <code>None</code>, it's    <code>True</code> by default for slotted classes and <code>False</code> for dict classes.</p> <p>If auto_detect is <code>True</code>, and getstate_setstate is left <code>None</code>,    and either <code>__getstate__</code> or <code>__setstate__</code> is detected directly    on the class (i.e. not inherited), it is set to <code>False</code> (this is usually    what you want).</p> <p>:param on_setattr: A callable that is run whenever the user attempts to set     an attribute (either by assignment like <code>i.x = 42</code> or by using     <code>setattr</code> like <code>setattr(i, \"x\", 42)</code>). It receives the same arguments     as validators: the instance, the attribute that is being modified, and     the new value.</p> <pre><code>If no exception is raised, the attribute is set to the return value of\nthe callable.\n\nIf a list of callables is passed, they're automatically wrapped in an\n`attr.setters.pipe`.\n</code></pre> <p>:param Optional[callable] field_transformer:     A function that is called with the original class object and all     fields right before <code>attrs</code> finalizes the class.  You can use     this, e.g., to automatically add converters or validators to     fields based on their types.  See <code>transform-fields</code> for more details.</p> <p>.. versionadded:: 16.0.0 slots .. versionadded:: 16.1.0 frozen .. versionadded:: 16.3.0 str .. versionadded:: 16.3.0 Support for <code>__attrs_post_init__</code>. .. versionchanged:: 17.1.0    hash supports <code>None</code> as value which is also the default now. .. versionadded:: 17.3.0 auto_attribs .. versionchanged:: 18.1.0    If these is passed, no attributes are deleted from the class body. .. versionchanged:: 18.1.0 If these is ordered, the order is retained. .. versionadded:: 18.2.0 weakref_slot .. deprecated:: 18.2.0    <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, and <code>__ge__</code> now raise a    <code>DeprecationWarning</code> if the classes compared are subclasses of    each other. <code>__eq</code> and <code>__ne__</code> never tried to compared subclasses    to each other. .. versionchanged:: 19.2.0    <code>__lt__</code>, <code>__le__</code>, <code>__gt__</code>, and <code>__ge__</code> now do not consider    subclasses comparable anymore. .. versionadded:: 18.2.0 kw_only .. versionadded:: 18.2.0 cache_hash .. versionadded:: 19.1.0 auto_exc .. deprecated:: 19.2.0 cmp Removal on or after 2021-06-01. .. versionadded:: 19.2.0 eq and order .. versionadded:: 20.1.0 auto_detect .. versionadded:: 20.1.0 collect_by_mro .. versionadded:: 20.1.0 getstate_setstate .. versionadded:: 20.1.0 on_setattr .. versionadded:: 20.3.0 field_transformer .. versionchanged:: 21.1.0    <code>init=False</code> injects <code>__attrs_init__</code> .. versionchanged:: 21.1.0 Support for <code>__attrs_pre_init__</code> .. versionchanged:: 21.1.0 cmp undeprecated</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def attrs(\n    maybe_cls=None,\n    these=None,\n    repr_ns=None,\n    repr=None,\n    cmp=None,\n    hash=None,\n    init=None,\n    slots=False,\n    frozen=False,\n    weakref_slot=True,\n    str=False,\n    auto_attribs=False,\n    kw_only=False,\n    cache_hash=False,\n    auto_exc=False,\n    eq=None,\n    order=None,\n    auto_detect=False,\n    collect_by_mro=False,\n    getstate_setstate=None,\n    on_setattr=None,\n    field_transformer=None,\n):\n    r\"\"\"\n    A class decorator that adds `dunder\n    &lt;https://wiki.python.org/moin/DunderAlias&gt;`_\\ -methods according to the\n    specified attributes using `attr.ib` or the *these* argument.\n\n    :param these: A dictionary of name to `attr.ib` mappings.  This is\n        useful to avoid the definition of your attributes within the class body\n        because you can't (e.g. if you want to add ``__repr__`` methods to\n        Django models) or don't want to.\n\n        If *these* is not ``None``, ``attrs`` will *not* search the class body\n        for attributes and will *not* remove any attributes from it.\n\n        If *these* is an ordered dict (`dict` on Python 3.6+,\n        `collections.OrderedDict` otherwise), the order is deduced from\n        the order of the attributes inside *these*.  Otherwise the order\n        of the definition of the attributes is used.\n\n    :type these: `dict` of `str` to `attr.ib`\n\n    :param str repr_ns: When using nested classes, there's no way in Python 2\n        to automatically detect that.  Therefore it's possible to set the\n        namespace explicitly for a more meaningful ``repr`` output.\n    :param bool auto_detect: Instead of setting the *init*, *repr*, *eq*,\n        *order*, and *hash* arguments explicitly, assume they are set to\n        ``True`` **unless any** of the involved methods for one of the\n        arguments is implemented in the *current* class (i.e. it is *not*\n        inherited from some base class).\n\n        So for example by implementing ``__eq__`` on a class yourself,\n        ``attrs`` will deduce ``eq=False`` and will create *neither*\n        ``__eq__`` *nor* ``__ne__`` (but Python classes come with a sensible\n        ``__ne__`` by default, so it *should* be enough to only implement\n        ``__eq__`` in most cases).\n\n        .. warning::\n\n           If you prevent ``attrs`` from creating the ordering methods for you\n           (``order=False``, e.g. by implementing ``__le__``), it becomes\n           *your* responsibility to make sure its ordering is sound. The best\n           way is to use the `functools.total_ordering` decorator.\n\n\n        Passing ``True`` or ``False`` to *init*, *repr*, *eq*, *order*,\n        *cmp*, or *hash* overrides whatever *auto_detect* would determine.\n\n        *auto_detect* requires Python 3. Setting it ``True`` on Python 2 raises\n        a `PythonTooOldError`.\n\n    :param bool repr: Create a ``__repr__`` method with a human readable\n        representation of ``attrs`` attributes..\n    :param bool str: Create a ``__str__`` method that is identical to\n        ``__repr__``.  This is usually not necessary except for\n        `Exception`\\ s.\n    :param Optional[bool] eq: If ``True`` or ``None`` (default), add ``__eq__``\n        and ``__ne__`` methods that check two instances for equality.\n\n        They compare the instances as if they were tuples of their ``attrs``\n        attributes if and only if the types of both classes are *identical*!\n    :param Optional[bool] order: If ``True``, add ``__lt__``, ``__le__``,\n        ``__gt__``, and ``__ge__`` methods that behave like *eq* above and\n        allow instances to be ordered. If ``None`` (default) mirror value of\n        *eq*.\n    :param Optional[bool] cmp: Setting *cmp* is equivalent to setting *eq*\n        and *order* to the same value. Must not be mixed with *eq* or *order*.\n    :param Optional[bool] hash: If ``None`` (default), the ``__hash__`` method\n        is generated according how *eq* and *frozen* are set.\n\n        1. If *both* are True, ``attrs`` will generate a ``__hash__`` for you.\n        2. If *eq* is True and *frozen* is False, ``__hash__`` will be set to\n           None, marking it unhashable (which it is).\n        3. If *eq* is False, ``__hash__`` will be left untouched meaning the\n           ``__hash__`` method of the base class will be used (if base class is\n           ``object``, this means it will fall back to id-based hashing.).\n\n        Although not recommended, you can decide for yourself and force\n        ``attrs`` to create one (e.g. if the class is immutable even though you\n        didn't freeze it programmatically) by passing ``True`` or not.  Both of\n        these cases are rather special and should be used carefully.\n\n        See our documentation on `hashing`, Python's documentation on\n        `object.__hash__`, and the `GitHub issue that led to the default \\\n        behavior &lt;https://github.com/python-attrs/attrs/issues/136&gt;`_ for more\n        details.\n    :param bool init: Create a ``__init__`` method that initializes the\n        ``attrs`` attributes. Leading underscores are stripped for the argument\n        name. If a ``__attrs_pre_init__`` method exists on the class, it will\n        be called before the class is initialized. If a ``__attrs_post_init__``\n        method exists on the class, it will be called after the class is fully\n        initialized.\n\n        If ``init`` is ``False``, an ``__attrs_init__`` method will be\n        injected instead. This allows you to define a custom ``__init__``\n        method that can do pre-init work such as ``super().__init__()``,\n        and then call ``__attrs_init__()`` and ``__attrs_post_init__()``.\n    :param bool slots: Create a `slotted class &lt;slotted classes&gt;` that's more\n        memory-efficient. Slotted classes are generally superior to the default\n        dict classes, but have some gotchas you should know about, so we\n        encourage you to read the `glossary entry &lt;slotted classes&gt;`.\n    :param bool frozen: Make instances immutable after initialization.  If\n        someone attempts to modify a frozen instance,\n        `attr.exceptions.FrozenInstanceError` is raised.\n\n        .. note::\n\n            1. This is achieved by installing a custom ``__setattr__`` method\n               on your class, so you can't implement your own.\n\n            2. True immutability is impossible in Python.\n\n            3. This *does* have a minor a runtime performance `impact\n               &lt;how-frozen&gt;` when initializing new instances.  In other words:\n               ``__init__`` is slightly slower with ``frozen=True``.\n\n            4. If a class is frozen, you cannot modify ``self`` in\n               ``__attrs_post_init__`` or a self-written ``__init__``. You can\n               circumvent that limitation by using\n               ``object.__setattr__(self, \"attribute_name\", value)``.\n\n            5. Subclasses of a frozen class are frozen too.\n\n    :param bool weakref_slot: Make instances weak-referenceable.  This has no\n        effect unless ``slots`` is also enabled.\n    :param bool auto_attribs: If ``True``, collect `PEP 526`_-annotated\n        attributes (Python 3.6 and later only) from the class body.\n\n        In this case, you **must** annotate every field.  If ``attrs``\n        encounters a field that is set to an `attr.ib` but lacks a type\n        annotation, an `attr.exceptions.UnannotatedAttributeError` is\n        raised.  Use ``field_name: typing.Any = attr.ib(...)`` if you don't\n        want to set a type.\n\n        If you assign a value to those attributes (e.g. ``x: int = 42``), that\n        value becomes the default value like if it were passed using\n        ``attr.ib(default=42)``.  Passing an instance of `Factory` also\n        works as expected in most cases (see warning below).\n\n        Attributes annotated as `typing.ClassVar`, and attributes that are\n        neither annotated nor set to an `attr.ib` are **ignored**.\n\n        .. warning::\n           For features that use the attribute name to create decorators (e.g.\n           `validators &lt;validators&gt;`), you still *must* assign `attr.ib` to\n           them. Otherwise Python will either not find the name or try to use\n           the default value to call e.g. ``validator`` on it.\n\n           These errors can be quite confusing and probably the most common bug\n           report on our bug tracker.\n\n        .. _`PEP 526`: https://www.python.org/dev/peps/pep-0526/\n    :param bool kw_only: Make all attributes keyword-only (Python 3+)\n        in the generated ``__init__`` (if ``init`` is ``False``, this\n        parameter is ignored).\n    :param bool cache_hash: Ensure that the object's hash code is computed\n        only once and stored on the object.  If this is set to ``True``,\n        hashing must be either explicitly or implicitly enabled for this\n        class.  If the hash code is cached, avoid any reassignments of\n        fields involved in hash code computation or mutations of the objects\n        those fields point to after object creation.  If such changes occur,\n        the behavior of the object's hash code is undefined.\n    :param bool auto_exc: If the class subclasses `BaseException`\n        (which implicitly includes any subclass of any exception), the\n        following happens to behave like a well-behaved Python exceptions\n        class:\n\n        - the values for *eq*, *order*, and *hash* are ignored and the\n          instances compare and hash by the instance's ids (N.B. ``attrs`` will\n          *not* remove existing implementations of ``__hash__`` or the equality\n          methods. It just won't add own ones.),\n        - all attributes that are either passed into ``__init__`` or have a\n          default value are additionally available as a tuple in the ``args``\n          attribute,\n        - the value of *str* is ignored leaving ``__str__`` to base classes.\n    :param bool collect_by_mro: Setting this to `True` fixes the way ``attrs``\n       collects attributes from base classes.  The default behavior is\n       incorrect in certain cases of multiple inheritance.  It should be on by\n       default but is kept off for backward-compatability.\n\n       See issue `#428 &lt;https://github.com/python-attrs/attrs/issues/428&gt;`_ for\n       more details.\n\n    :param Optional[bool] getstate_setstate:\n       .. note::\n          This is usually only interesting for slotted classes and you should\n          probably just set *auto_detect* to `True`.\n\n       If `True`, ``__getstate__`` and\n       ``__setstate__`` are generated and attached to the class. This is\n       necessary for slotted classes to be pickleable. If left `None`, it's\n       `True` by default for slotted classes and ``False`` for dict classes.\n\n       If *auto_detect* is `True`, and *getstate_setstate* is left `None`,\n       and **either** ``__getstate__`` or ``__setstate__`` is detected directly\n       on the class (i.e. not inherited), it is set to `False` (this is usually\n       what you want).\n\n    :param on_setattr: A callable that is run whenever the user attempts to set\n        an attribute (either by assignment like ``i.x = 42`` or by using\n        `setattr` like ``setattr(i, \"x\", 42)``). It receives the same arguments\n        as validators: the instance, the attribute that is being modified, and\n        the new value.\n\n        If no exception is raised, the attribute is set to the return value of\n        the callable.\n\n        If a list of callables is passed, they're automatically wrapped in an\n        `attr.setters.pipe`.\n\n    :param Optional[callable] field_transformer:\n        A function that is called with the original class object and all\n        fields right before ``attrs`` finalizes the class.  You can use\n        this, e.g., to automatically add converters or validators to\n        fields based on their types.  See `transform-fields` for more details.\n\n    .. versionadded:: 16.0.0 *slots*\n    .. versionadded:: 16.1.0 *frozen*\n    .. versionadded:: 16.3.0 *str*\n    .. versionadded:: 16.3.0 Support for ``__attrs_post_init__``.\n    .. versionchanged:: 17.1.0\n       *hash* supports ``None`` as value which is also the default now.\n    .. versionadded:: 17.3.0 *auto_attribs*\n    .. versionchanged:: 18.1.0\n       If *these* is passed, no attributes are deleted from the class body.\n    .. versionchanged:: 18.1.0 If *these* is ordered, the order is retained.\n    .. versionadded:: 18.2.0 *weakref_slot*\n    .. deprecated:: 18.2.0\n       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now raise a\n       `DeprecationWarning` if the classes compared are subclasses of\n       each other. ``__eq`` and ``__ne__`` never tried to compared subclasses\n       to each other.\n    .. versionchanged:: 19.2.0\n       ``__lt__``, ``__le__``, ``__gt__``, and ``__ge__`` now do not consider\n       subclasses comparable anymore.\n    .. versionadded:: 18.2.0 *kw_only*\n    .. versionadded:: 18.2.0 *cache_hash*\n    .. versionadded:: 19.1.0 *auto_exc*\n    .. deprecated:: 19.2.0 *cmp* Removal on or after 2021-06-01.\n    .. versionadded:: 19.2.0 *eq* and *order*\n    .. versionadded:: 20.1.0 *auto_detect*\n    .. versionadded:: 20.1.0 *collect_by_mro*\n    .. versionadded:: 20.1.0 *getstate_setstate*\n    .. versionadded:: 20.1.0 *on_setattr*\n    .. versionadded:: 20.3.0 *field_transformer*\n    .. versionchanged:: 21.1.0\n       ``init=False`` injects ``__attrs_init__``\n    .. versionchanged:: 21.1.0 Support for ``__attrs_pre_init__``\n    .. versionchanged:: 21.1.0 *cmp* undeprecated\n    \"\"\"\n    if auto_detect and PY2:\n        raise PythonTooOldError(\n            \"auto_detect only works on Python 3 and later.\"\n        )\n\n    eq_, order_ = _determine_attrs_eq_order(cmp, eq, order, None)\n    hash_ = hash  # work around the lack of nonlocal\n\n    if isinstance(on_setattr, (list, tuple)):\n        on_setattr = setters.pipe(*on_setattr)\n\n    def wrap(cls):\n\n        if getattr(cls, \"__class__\", None) is None:\n            raise TypeError(\"attrs only works with new-style classes.\")\n\n        is_frozen = frozen or _has_frozen_base_class(cls)\n        is_exc = auto_exc is True and issubclass(cls, BaseException)\n        has_own_setattr = auto_detect and _has_own_attribute(\n            cls, \"__setattr__\"\n        )\n\n        if has_own_setattr and is_frozen:\n            raise ValueError(\"Can't freeze a class with a custom __setattr__.\")\n\n        builder = _ClassBuilder(\n            cls,\n            these,\n            slots,\n            is_frozen,\n            weakref_slot,\n            _determine_whether_to_implement(\n                cls,\n                getstate_setstate,\n                auto_detect,\n                (\"__getstate__\", \"__setstate__\"),\n                default=slots,\n            ),\n            auto_attribs,\n            kw_only,\n            cache_hash,\n            is_exc,\n            collect_by_mro,\n            on_setattr,\n            has_own_setattr,\n            field_transformer,\n        )\n        if _determine_whether_to_implement(\n            cls, repr, auto_detect, (\"__repr__\",)\n        ):\n            builder.add_repr(repr_ns)\n        if str is True:\n            builder.add_str()\n\n        eq = _determine_whether_to_implement(\n            cls, eq_, auto_detect, (\"__eq__\", \"__ne__\")\n        )\n        if not is_exc and eq is True:\n            builder.add_eq()\n        if not is_exc and _determine_whether_to_implement(\n            cls, order_, auto_detect, (\"__lt__\", \"__le__\", \"__gt__\", \"__ge__\")\n        ):\n            builder.add_order()\n\n        builder.add_setattr()\n\n        if (\n            hash_ is None\n            and auto_detect is True\n            and _has_own_attribute(cls, \"__hash__\")\n        ):\n            hash = False\n        else:\n            hash = hash_\n        if hash is not True and hash is not False and hash is not None:\n            # Can't use `hash in` because 1 == True for example.\n            raise TypeError(\n                \"Invalid value for hash.  Must be True, False, or None.\"\n            )\n        elif hash is False or (hash is None and eq is False) or is_exc:\n            # Don't do anything. Should fall back to __object__'s __hash__\n            # which is by id.\n            if cache_hash:\n                raise TypeError(\n                    \"Invalid value for cache_hash.  To use hash caching,\"\n                    \" hashing must be either explicitly or implicitly \"\n                    \"enabled.\"\n                )\n        elif hash is True or (\n            hash is None and eq is True and is_frozen is True\n        ):\n            # Build a __hash__ if told so, or if it's safe.\n            builder.add_hash()\n        else:\n            # Raise TypeError on attempts to hash.\n            if cache_hash:\n                raise TypeError(\n                    \"Invalid value for cache_hash.  To use hash caching,\"\n                    \" hashing must be either explicitly or implicitly \"\n                    \"enabled.\"\n                )\n            builder.make_unhashable()\n\n        if _determine_whether_to_implement(\n            cls, init, auto_detect, (\"__init__\",)\n        ):\n            builder.add_init()\n        else:\n            builder.add_attrs_init()\n            if cache_hash:\n                raise TypeError(\n                    \"Invalid value for cache_hash.  To use hash caching,\"\n                    \" init must be True.\"\n                )\n\n        return builder.build_class()\n\n    # maybe_cls's type depends on the usage of the decorator.  It's a class\n    # if it's used as `@attrs` but ``None`` if used as `@attrs()`.\n    if maybe_cls is None:\n        return wrap\n    else:\n        return wrap(maybe_cls)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.fields","title":"<code>fields(cls)</code>","text":"<p>Return the tuple of <code>attrs</code> attributes for a class.</p> <p>The tuple also allows accessing the fields by their names (see below for examples).</p> <p>:param type cls: Class to introspect.</p> <p>:raise TypeError: If cls is not a class. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>:rtype: tuple (with name accessors) of <code>attr.Attribute</code></p> <p>..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields     by name.</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def fields(cls):\n    \"\"\"\n    Return the tuple of ``attrs`` attributes for a class.\n\n    The tuple also allows accessing the fields by their names (see below for\n    examples).\n\n    :param type cls: Class to introspect.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    :rtype: tuple (with name accessors) of `attr.Attribute`\n\n    ..  versionchanged:: 16.2.0 Returned tuple allows accessing the fields\n        by name.\n    \"\"\"\n    if not isclass(cls):\n        raise TypeError(\"Passed object must be a class.\")\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n    if attrs is None:\n        raise NotAnAttrsClassError(\n            \"{cls!r} is not an attrs-decorated class.\".format(cls=cls)\n        )\n    return attrs\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.fields_dict","title":"<code>fields_dict(cls)</code>","text":"<p>Return an ordered dictionary of <code>attrs</code> attributes for a class, whose keys are the attribute names.</p> <p>:param type cls: Class to introspect.</p> <p>:raise TypeError: If cls is not a class. :raise attr.exceptions.NotAnAttrsClassError: If cls is not an <code>attrs</code>     class.</p> <p>:rtype: an ordered dict where keys are attribute names and values are     <code>attr.Attribute</code>\\ s. This will be a <code>dict</code> if it's     naturally ordered like on Python 3.6+ or an     :class:<code>~collections.OrderedDict</code> otherwise.</p> <p>.. versionadded:: 18.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def fields_dict(cls):\n    \"\"\"\n    Return an ordered dictionary of ``attrs`` attributes for a class, whose\n    keys are the attribute names.\n\n    :param type cls: Class to introspect.\n\n    :raise TypeError: If *cls* is not a class.\n    :raise attr.exceptions.NotAnAttrsClassError: If *cls* is not an ``attrs``\n        class.\n\n    :rtype: an ordered dict where keys are attribute names and values are\n        `attr.Attribute`\\\\ s. This will be a `dict` if it's\n        naturally ordered like on Python 3.6+ or an\n        :class:`~collections.OrderedDict` otherwise.\n\n    .. versionadded:: 18.1.0\n    \"\"\"\n    if not isclass(cls):\n        raise TypeError(\"Passed object must be a class.\")\n    attrs = getattr(cls, \"__attrs_attrs__\", None)\n    if attrs is None:\n        raise NotAnAttrsClassError(\n            \"{cls!r} is not an attrs-decorated class.\".format(cls=cls)\n        )\n    return ordered_dict(((a.name, a) for a in attrs))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.make_class","title":"<code>make_class(name, attrs, bases=(object,), **attributes_arguments)</code>","text":"<p>A quick way to create a new class called name with attrs.</p> <p>:param str name: The name for the new class.</p> <p>:param attrs: A list of names or a dictionary of mappings of names to     attributes.</p> <pre><code>If *attrs* is a list or an ordered dict (`dict` on Python 3.6+,\n`collections.OrderedDict` otherwise), the order is deduced from\nthe order of the names or attributes inside *attrs*.  Otherwise the\norder of the definition of the attributes is used.\n</code></pre> <p>:type attrs: <code>list</code> or <code>dict</code></p> <p>:param tuple bases: Classes that the new class will subclass.</p> <p>:param attributes_arguments: Passed unmodified to <code>attr.s</code>.</p> <p>:return: A new class with attrs. :rtype: type</p> <p>.. versionadded:: 17.1.0 bases .. versionchanged:: 18.1.0 If attrs is ordered, the order is retained.</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def make_class(name, attrs, bases=(object,), **attributes_arguments):\n    \"\"\"\n    A quick way to create a new class called *name* with *attrs*.\n\n    :param str name: The name for the new class.\n\n    :param attrs: A list of names or a dictionary of mappings of names to\n        attributes.\n\n        If *attrs* is a list or an ordered dict (`dict` on Python 3.6+,\n        `collections.OrderedDict` otherwise), the order is deduced from\n        the order of the names or attributes inside *attrs*.  Otherwise the\n        order of the definition of the attributes is used.\n    :type attrs: `list` or `dict`\n\n    :param tuple bases: Classes that the new class will subclass.\n\n    :param attributes_arguments: Passed unmodified to `attr.s`.\n\n    :return: A new class with *attrs*.\n    :rtype: type\n\n    .. versionadded:: 17.1.0 *bases*\n    .. versionchanged:: 18.1.0 If *attrs* is ordered, the order is retained.\n    \"\"\"\n    if isinstance(attrs, dict):\n        cls_dict = attrs\n    elif isinstance(attrs, (list, tuple)):\n        cls_dict = dict((a, attrib()) for a in attrs)\n    else:\n        raise TypeError(\"attrs argument must be a dict or a list.\")\n\n    pre_init = cls_dict.pop(\"__attrs_pre_init__\", None)\n    post_init = cls_dict.pop(\"__attrs_post_init__\", None)\n    user_init = cls_dict.pop(\"__init__\", None)\n\n    body = {}\n    if pre_init is not None:\n        body[\"__attrs_pre_init__\"] = pre_init\n    if post_init is not None:\n        body[\"__attrs_post_init__\"] = post_init\n    if user_init is not None:\n        body[\"__init__\"] = user_init\n\n    type_ = new_class(name, bases, {}, lambda ns: ns.update(body))\n\n    # For pickling to work, the __module__ variable needs to be set to the\n    # frame where the class is created.  Bypass this step in environments where\n    # sys._getframe is not defined (Jython for example) or sys._getframe is not\n    # defined for arguments greater than 0 (IronPython).\n    try:\n        type_.__module__ = sys._getframe(1).f_globals.get(\n            \"__name__\", \"__main__\"\n        )\n    except (AttributeError, ValueError):\n        pass\n\n    # We do it here for proper warnings with meaningful stacklevel.\n    cmp = attributes_arguments.pop(\"cmp\", None)\n    (\n        attributes_arguments[\"eq\"],\n        attributes_arguments[\"order\"],\n    ) = _determine_attrs_eq_order(\n        cmp,\n        attributes_arguments.get(\"eq\"),\n        attributes_arguments.get(\"order\"),\n        True,\n    )\n\n    return _attrs(these=cls_dict, **attributes_arguments)(type_)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.pipe","title":"<code>pipe(*converters)</code>","text":"<p>A converter that composes multiple converters into one.</p> <p>When called on a value, it runs all wrapped converters, returning the last value.</p> <p>Type annotations will be inferred from the wrapped converters', if they have any.</p> <p>:param callables converters: Arbitrary number of converters.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def pipe(*converters):\n    \"\"\"\n    A converter that composes multiple converters into one.\n\n    When called on a value, it runs all wrapped converters, returning the\n    *last* value.\n\n    Type annotations will be inferred from the wrapped converters', if\n    they have any.\n\n    :param callables converters: Arbitrary number of converters.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    def pipe_converter(val):\n        for converter in converters:\n            val = converter(val)\n\n        return val\n\n    if not PY2:\n        if not converters:\n            # If the converter list is empty, pipe_converter is the identity.\n            A = typing.TypeVar(\"A\")\n            pipe_converter.__annotations__ = {\"val\": A, \"return\": A}\n        else:\n            # Get parameter type.\n            sig = None\n            try:\n                sig = inspect.signature(converters[0])\n            except (ValueError, TypeError):  # inspect failed\n                pass\n            if sig:\n                params = list(sig.parameters.values())\n                if (\n                    params\n                    and params[0].annotation is not inspect.Parameter.empty\n                ):\n                    pipe_converter.__annotations__[\"val\"] = params[\n                        0\n                    ].annotation\n            # Get return type.\n            sig = None\n            try:\n                sig = inspect.signature(converters[-1])\n            except (ValueError, TypeError):  # inspect failed\n                pass\n            if sig and sig.return_annotation is not inspect.Signature().empty:\n                pipe_converter.__annotations__[\n                    \"return\"\n                ] = sig.return_annotation\n\n    return pipe_converter\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_make.html#client.ayon_fusion.vendor.attr._make.validate","title":"<code>validate(inst)</code>","text":"<p>Validate all attributes on inst that have a validator.</p> <p>Leaves all exceptions through.</p> <p>:param inst: Instance of a class with <code>attrs</code> attributes.</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def validate(inst):\n    \"\"\"\n    Validate all attributes on *inst* that have a validator.\n\n    Leaves all exceptions through.\n\n    :param inst: Instance of a class with ``attrs`` attributes.\n    \"\"\"\n    if _config._run_validators is False:\n        return\n\n    for a in fields(inst.__class__):\n        v = a.validator\n        if v is not None:\n            v(inst, a, getattr(inst, a.name))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_next_gen.html","title":"_next_gen","text":"<p>These are Python 3.6+-only and keyword-only APIs that call <code>attr.s</code> and <code>attr.ib</code> with different default values.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_next_gen.html#client.ayon_fusion.vendor.attr._next_gen.define","title":"<code>define(maybe_cls=None, *, these=None, repr=None, hash=None, init=None, slots=True, frozen=False, weakref_slot=True, str=False, auto_attribs=None, kw_only=False, cache_hash=False, auto_exc=True, eq=None, order=False, auto_detect=True, getstate_setstate=None, on_setattr=None, field_transformer=None)</code>","text":"<p>The only behavioral differences are the handling of the auto_attribs option:</p> <p>:param Optional[bool] auto_attribs: If set to <code>True</code> or <code>False</code>, it behaves    exactly like <code>attr.s</code>. If left <code>None</code>, <code>attr.s</code> will try to guess:</p> <ol> <li>If any attributes are annotated and no unannotated <code>attr.ib</code>\\ s       are found, it assumes auto_attribs=True.</li> <li>Otherwise it assumes auto_attribs=False and tries to collect       <code>attr.ib</code>\\ s.</li> </ol> <p>and that mutable classes (<code>frozen=False</code>) validate on <code>__setattr__</code>.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_next_gen.py</code> <pre><code>def define(\n    maybe_cls=None,\n    *,\n    these=None,\n    repr=None,\n    hash=None,\n    init=None,\n    slots=True,\n    frozen=False,\n    weakref_slot=True,\n    str=False,\n    auto_attribs=None,\n    kw_only=False,\n    cache_hash=False,\n    auto_exc=True,\n    eq=None,\n    order=False,\n    auto_detect=True,\n    getstate_setstate=None,\n    on_setattr=None,\n    field_transformer=None,\n):\n    r\"\"\"\n    The only behavioral differences are the handling of the *auto_attribs*\n    option:\n\n    :param Optional[bool] auto_attribs: If set to `True` or `False`, it behaves\n       exactly like `attr.s`. If left `None`, `attr.s` will try to guess:\n\n       1. If any attributes are annotated and no unannotated `attr.ib`\\ s\n          are found, it assumes *auto_attribs=True*.\n       2. Otherwise it assumes *auto_attribs=False* and tries to collect\n          `attr.ib`\\ s.\n\n    and that mutable classes (``frozen=False``) validate on ``__setattr__``.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    def do_it(cls, auto_attribs):\n        return attrs(\n            maybe_cls=cls,\n            these=these,\n            repr=repr,\n            hash=hash,\n            init=init,\n            slots=slots,\n            frozen=frozen,\n            weakref_slot=weakref_slot,\n            str=str,\n            auto_attribs=auto_attribs,\n            kw_only=kw_only,\n            cache_hash=cache_hash,\n            auto_exc=auto_exc,\n            eq=eq,\n            order=order,\n            auto_detect=auto_detect,\n            collect_by_mro=True,\n            getstate_setstate=getstate_setstate,\n            on_setattr=on_setattr,\n            field_transformer=field_transformer,\n        )\n\n    def wrap(cls):\n        \"\"\"\n        Making this a wrapper ensures this code runs during class creation.\n\n        We also ensure that frozen-ness of classes is inherited.\n        \"\"\"\n        nonlocal frozen, on_setattr\n\n        had_on_setattr = on_setattr not in (None, setters.NO_OP)\n\n        # By default, mutable classes validate on setattr.\n        if frozen is False and on_setattr is None:\n            on_setattr = setters.validate\n\n        # However, if we subclass a frozen class, we inherit the immutability\n        # and disable on_setattr.\n        for base_cls in cls.__bases__:\n            if base_cls.__setattr__ is _frozen_setattrs:\n                if had_on_setattr:\n                    raise ValueError(\n                        \"Frozen classes can't use on_setattr \"\n                        \"(frozen-ness was inherited).\"\n                    )\n\n                on_setattr = setters.NO_OP\n                break\n\n        if auto_attribs is not None:\n            return do_it(cls, auto_attribs)\n\n        try:\n            return do_it(cls, True)\n        except UnannotatedAttributeError:\n            return do_it(cls, False)\n\n    # maybe_cls's type depends on the usage of the decorator.  It's a class\n    # if it's used as `@attrs` but ``None`` if used as `@attrs()`.\n    if maybe_cls is None:\n        return wrap\n    else:\n        return wrap(maybe_cls)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_next_gen.html#client.ayon_fusion.vendor.attr._next_gen.field","title":"<code>field(*, default=NOTHING, validator=None, repr=True, hash=None, init=True, metadata=None, converter=None, factory=None, kw_only=False, eq=None, order=None, on_setattr=None)</code>","text":"<p>Identical to <code>attr.ib</code>, except keyword-only and with some arguments removed.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_next_gen.py</code> <pre><code>def field(\n    *,\n    default=NOTHING,\n    validator=None,\n    repr=True,\n    hash=None,\n    init=True,\n    metadata=None,\n    converter=None,\n    factory=None,\n    kw_only=False,\n    eq=None,\n    order=None,\n    on_setattr=None,\n):\n    \"\"\"\n    Identical to `attr.ib`, except keyword-only and with some arguments\n    removed.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    return attrib(\n        default=default,\n        validator=validator,\n        repr=repr,\n        hash=hash,\n        init=init,\n        metadata=metadata,\n        converter=converter,\n        factory=factory,\n        kw_only=kw_only,\n        eq=eq,\n        order=order,\n        on_setattr=on_setattr,\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/_version_info.html","title":"_version_info","text":""},{"location":"autoapi/client/ayon_fusion/vendor/attr/_version_info.html#client.ayon_fusion.vendor.attr._version_info.VersionInfo","title":"<code>VersionInfo</code>","text":"<p>               Bases: <code>object</code></p> <p>A version object that can be compared to tuple of length 1--4:</p> <p>attr.VersionInfo(19, 1, 0, \"final\")  &lt;= (19, 2) True attr.VersionInfo(19, 1, 0, \"final\") &lt; (19, 1, 1) True vi = attr.VersionInfo(19, 2, 0, \"final\") vi &lt; (19, 1, 1) False vi &lt; (19,) False vi == (19, 2,) True vi == (19, 2, 1) False</p> <p>.. versionadded:: 19.2</p> Source code in <code>client/ayon_fusion/vendor/attr/_version_info.py</code> <pre><code>@total_ordering\n@attrs(eq=False, order=False, slots=True, frozen=True)\nclass VersionInfo(object):\n    \"\"\"\n    A version object that can be compared to tuple of length 1--4:\n\n    &gt;&gt;&gt; attr.VersionInfo(19, 1, 0, \"final\")  &lt;= (19, 2)\n    True\n    &gt;&gt;&gt; attr.VersionInfo(19, 1, 0, \"final\") &lt; (19, 1, 1)\n    True\n    &gt;&gt;&gt; vi = attr.VersionInfo(19, 2, 0, \"final\")\n    &gt;&gt;&gt; vi &lt; (19, 1, 1)\n    False\n    &gt;&gt;&gt; vi &lt; (19,)\n    False\n    &gt;&gt;&gt; vi == (19, 2,)\n    True\n    &gt;&gt;&gt; vi == (19, 2, 1)\n    False\n\n    .. versionadded:: 19.2\n    \"\"\"\n\n    year = attrib(type=int)\n    minor = attrib(type=int)\n    micro = attrib(type=int)\n    releaselevel = attrib(type=str)\n\n    @classmethod\n    def _from_version_string(cls, s):\n        \"\"\"\n        Parse *s* and return a _VersionInfo.\n        \"\"\"\n        v = s.split(\".\")\n        if len(v) == 3:\n            v.append(\"final\")\n\n        return cls(\n            year=int(v[0]), minor=int(v[1]), micro=int(v[2]), releaselevel=v[3]\n        )\n\n    def _ensure_tuple(self, other):\n        \"\"\"\n        Ensure *other* is a tuple of a valid length.\n\n        Returns a possibly transformed *other* and ourselves as a tuple of\n        the same length as *other*.\n        \"\"\"\n\n        if self.__class__ is other.__class__:\n            other = astuple(other)\n\n        if not isinstance(other, tuple):\n            raise NotImplementedError\n\n        if not (1 &lt;= len(other) &lt;= 4):\n            raise NotImplementedError\n\n        return astuple(self)[: len(other)], other\n\n    def __eq__(self, other):\n        try:\n            us, them = self._ensure_tuple(other)\n        except NotImplementedError:\n            return NotImplemented\n\n        return us == them\n\n    def __lt__(self, other):\n        try:\n            us, them = self._ensure_tuple(other)\n        except NotImplementedError:\n            return NotImplemented\n\n        # Since alphabetically \"dev0\" &lt; \"final\" &lt; \"post1\" &lt; \"post2\", we don't\n        # have to do anything special with releaselevel for now.\n        return us &lt; them\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/converters.html","title":"converters","text":"<p>Commonly useful converters.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/converters.html#client.ayon_fusion.vendor.attr.converters.default_if_none","title":"<code>default_if_none(default=NOTHING, factory=None)</code>","text":"<pre><code>default_if_none(default: _T) -&gt; _ConverterType\n</code></pre><pre><code>default_if_none(*, factory: Callable[[], _T]) -&gt; _ConverterType\n</code></pre> <p>A converter that allows to replace <code>None</code> values by default or the result of factory.</p> <p>:param default: Value to be used if <code>None</code> is passed. Passing an instance    of <code>attr.Factory</code> is supported, however the <code>takes_self</code> option    is not. :param callable factory: A callable that takes no parameters whose result    is used if <code>None</code> is passed.</p> <p>:raises TypeError: If neither default or factory is passed. :raises TypeError: If both default and factory are passed. :raises ValueError: If an instance of <code>attr.Factory</code> is passed with    <code>takes_self=True</code>.</p> <p>.. versionadded:: 18.2.0</p> Source code in <code>client/ayon_fusion/vendor/attr/converters.py</code> <pre><code>def default_if_none(default=NOTHING, factory=None):\n    \"\"\"\n    A converter that allows to replace ``None`` values by *default* or the\n    result of *factory*.\n\n    :param default: Value to be used if ``None`` is passed. Passing an instance\n       of `attr.Factory` is supported, however the ``takes_self`` option\n       is *not*.\n    :param callable factory: A callable that takes no parameters whose result\n       is used if ``None`` is passed.\n\n    :raises TypeError: If **neither** *default* or *factory* is passed.\n    :raises TypeError: If **both** *default* and *factory* are passed.\n    :raises ValueError: If an instance of `attr.Factory` is passed with\n       ``takes_self=True``.\n\n    .. versionadded:: 18.2.0\n    \"\"\"\n    if default is NOTHING and factory is None:\n        raise TypeError(\"Must pass either `default` or `factory`.\")\n\n    if default is not NOTHING and factory is not None:\n        raise TypeError(\n            \"Must pass either `default` or `factory` but not both.\"\n        )\n\n    if factory is not None:\n        default = Factory(factory)\n\n    if isinstance(default, Factory):\n        if default.takes_self:\n            raise ValueError(\n                \"`takes_self` is not supported by default_if_none.\"\n            )\n\n        def default_if_none_converter(val):\n            if val is not None:\n                return val\n\n            return default.factory()\n\n    else:\n\n        def default_if_none_converter(val):\n            if val is not None:\n                return val\n\n            return default\n\n    return default_if_none_converter\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/converters.html#client.ayon_fusion.vendor.attr.converters.optional","title":"<code>optional(converter)</code>","text":"<p>A converter that allows an attribute to be optional. An optional attribute is one which can be set to <code>None</code>.</p> <p>Type annotations will be inferred from the wrapped converter's, if it has any.</p> <p>:param callable converter: the converter that is used for non-<code>None</code>     values.</p> <p>.. versionadded:: 17.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/converters.py</code> <pre><code>def optional(converter):\n    \"\"\"\n    A converter that allows an attribute to be optional. An optional attribute\n    is one which can be set to ``None``.\n\n    Type annotations will be inferred from the wrapped converter's, if it\n    has any.\n\n    :param callable converter: the converter that is used for non-``None``\n        values.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n\n    def optional_converter(val):\n        if val is None:\n            return None\n        return converter(val)\n\n    if not PY2:\n        sig = None\n        try:\n            sig = inspect.signature(converter)\n        except (ValueError, TypeError):  # inspect failed\n            pass\n        if sig:\n            params = list(sig.parameters.values())\n            if params and params[0].annotation is not inspect.Parameter.empty:\n                optional_converter.__annotations__[\"val\"] = typing.Optional[\n                    params[0].annotation\n                ]\n            if sig.return_annotation is not inspect.Signature.empty:\n                optional_converter.__annotations__[\"return\"] = typing.Optional[\n                    sig.return_annotation\n                ]\n\n    return optional_converter\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/converters.html#client.ayon_fusion.vendor.attr.converters.pipe","title":"<code>pipe(*converters)</code>","text":"<p>A converter that composes multiple converters into one.</p> <p>When called on a value, it runs all wrapped converters, returning the last value.</p> <p>Type annotations will be inferred from the wrapped converters', if they have any.</p> <p>:param callables converters: Arbitrary number of converters.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def pipe(*converters):\n    \"\"\"\n    A converter that composes multiple converters into one.\n\n    When called on a value, it runs all wrapped converters, returning the\n    *last* value.\n\n    Type annotations will be inferred from the wrapped converters', if\n    they have any.\n\n    :param callables converters: Arbitrary number of converters.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    def pipe_converter(val):\n        for converter in converters:\n            val = converter(val)\n\n        return val\n\n    if not PY2:\n        if not converters:\n            # If the converter list is empty, pipe_converter is the identity.\n            A = typing.TypeVar(\"A\")\n            pipe_converter.__annotations__ = {\"val\": A, \"return\": A}\n        else:\n            # Get parameter type.\n            sig = None\n            try:\n                sig = inspect.signature(converters[0])\n            except (ValueError, TypeError):  # inspect failed\n                pass\n            if sig:\n                params = list(sig.parameters.values())\n                if (\n                    params\n                    and params[0].annotation is not inspect.Parameter.empty\n                ):\n                    pipe_converter.__annotations__[\"val\"] = params[\n                        0\n                    ].annotation\n            # Get return type.\n            sig = None\n            try:\n                sig = inspect.signature(converters[-1])\n            except (ValueError, TypeError):  # inspect failed\n                pass\n            if sig and sig.return_annotation is not inspect.Signature().empty:\n                pipe_converter.__annotations__[\n                    \"return\"\n                ] = sig.return_annotation\n\n    return pipe_converter\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html","title":"exceptions","text":""},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html#client.ayon_fusion.vendor.attr.exceptions.AttrsAttributeNotFoundError","title":"<code>AttrsAttributeNotFoundError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>An <code>attrs</code> function couldn't find an attribute that the user asked for.</p> <p>.. versionadded:: 16.2.0</p> Source code in <code>client/ayon_fusion/vendor/attr/exceptions.py</code> <pre><code>class AttrsAttributeNotFoundError(ValueError):\n    \"\"\"\n    An ``attrs`` function couldn't find an attribute that the user asked for.\n\n    .. versionadded:: 16.2.0\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html#client.ayon_fusion.vendor.attr.exceptions.DefaultAlreadySetError","title":"<code>DefaultAlreadySetError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>A default has been set using <code>attr.ib()</code> and is attempted to be reset using the decorator.</p> <p>.. versionadded:: 17.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/exceptions.py</code> <pre><code>class DefaultAlreadySetError(RuntimeError):\n    \"\"\"\n    A default has been set using ``attr.ib()`` and is attempted to be reset\n    using the decorator.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html#client.ayon_fusion.vendor.attr.exceptions.FrozenAttributeError","title":"<code>FrozenAttributeError</code>","text":"<p>               Bases: <code>FrozenError</code></p> <p>A frozen attribute has been attempted to be modified.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/exceptions.py</code> <pre><code>class FrozenAttributeError(FrozenError):\n    \"\"\"\n    A frozen attribute has been attempted to be modified.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html#client.ayon_fusion.vendor.attr.exceptions.FrozenError","title":"<code>FrozenError</code>","text":"<p>               Bases: <code>AttributeError</code></p> <p>A frozen/immutable instance or attribute have been attempted to be modified.</p> <p>It mirrors the behavior of <code>namedtuples</code> by using the same error message and subclassing <code>AttributeError</code>.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/exceptions.py</code> <pre><code>class FrozenError(AttributeError):\n    \"\"\"\n    A frozen/immutable instance or attribute have been attempted to be\n    modified.\n\n    It mirrors the behavior of ``namedtuples`` by using the same error message\n    and subclassing `AttributeError`.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    msg = \"can't set attribute\"\n    args = [msg]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html#client.ayon_fusion.vendor.attr.exceptions.FrozenInstanceError","title":"<code>FrozenInstanceError</code>","text":"<p>               Bases: <code>FrozenError</code></p> <p>A frozen instance has been attempted to be modified.</p> <p>.. versionadded:: 16.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/exceptions.py</code> <pre><code>class FrozenInstanceError(FrozenError):\n    \"\"\"\n    A frozen instance has been attempted to be modified.\n\n    .. versionadded:: 16.1.0\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html#client.ayon_fusion.vendor.attr.exceptions.NotAnAttrsClassError","title":"<code>NotAnAttrsClassError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>A non-<code>attrs</code> class has been passed into an <code>attrs</code> function.</p> <p>.. versionadded:: 16.2.0</p> Source code in <code>client/ayon_fusion/vendor/attr/exceptions.py</code> <pre><code>class NotAnAttrsClassError(ValueError):\n    \"\"\"\n    A non-``attrs`` class has been passed into an ``attrs`` function.\n\n    .. versionadded:: 16.2.0\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html#client.ayon_fusion.vendor.attr.exceptions.NotCallableError","title":"<code>NotCallableError</code>","text":"<p>               Bases: <code>TypeError</code></p> <p>A <code>attr.ib()</code> requiring a callable has been set with a value that is not callable.</p> <p>.. versionadded:: 19.2.0</p> Source code in <code>client/ayon_fusion/vendor/attr/exceptions.py</code> <pre><code>class NotCallableError(TypeError):\n    \"\"\"\n    A ``attr.ib()`` requiring a callable has been set with a value\n    that is not callable.\n\n    .. versionadded:: 19.2.0\n    \"\"\"\n\n    def __init__(self, msg, value):\n        super(TypeError, self).__init__(msg, value)\n        self.msg = msg\n        self.value = value\n\n    def __str__(self):\n        return str(self.msg)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html#client.ayon_fusion.vendor.attr.exceptions.PythonTooOldError","title":"<code>PythonTooOldError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>It was attempted to use an <code>attrs</code> feature that requires a newer Python version.</p> <p>.. versionadded:: 18.2.0</p> Source code in <code>client/ayon_fusion/vendor/attr/exceptions.py</code> <pre><code>class PythonTooOldError(RuntimeError):\n    \"\"\"\n    It was attempted to use an ``attrs`` feature that requires a newer Python\n    version.\n\n    .. versionadded:: 18.2.0\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/exceptions.html#client.ayon_fusion.vendor.attr.exceptions.UnannotatedAttributeError","title":"<code>UnannotatedAttributeError</code>","text":"<p>               Bases: <code>RuntimeError</code></p> <p>A class with <code>auto_attribs=True</code> has an <code>attr.ib()</code> without a type annotation.</p> <p>.. versionadded:: 17.3.0</p> Source code in <code>client/ayon_fusion/vendor/attr/exceptions.py</code> <pre><code>class UnannotatedAttributeError(RuntimeError):\n    \"\"\"\n    A class with ``auto_attribs=True`` has an ``attr.ib()`` without a type\n    annotation.\n\n    .. versionadded:: 17.3.0\n    \"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/filters.html","title":"filters","text":"<p>Commonly useful filters for <code>attr.asdict</code>.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/filters.html#client.ayon_fusion.vendor.attr.filters.exclude","title":"<code>exclude(*what)</code>","text":"<p>Blacklist what.</p> <p>:param what: What to blacklist. :type what: <code>list</code> of classes or <code>attr.Attribute</code>\\ s.</p> <p>:rtype: <code>callable</code></p> Source code in <code>client/ayon_fusion/vendor/attr/filters.py</code> <pre><code>def exclude(*what):\n    \"\"\"\n    Blacklist *what*.\n\n    :param what: What to blacklist.\n    :type what: `list` of classes or `attr.Attribute`\\\\ s.\n\n    :rtype: `callable`\n    \"\"\"\n    cls, attrs = _split_what(what)\n\n    def exclude_(attribute, value):\n        return value.__class__ not in cls and attribute not in attrs\n\n    return exclude_\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/filters.html#client.ayon_fusion.vendor.attr.filters.include","title":"<code>include(*what)</code>","text":"<p>Whitelist what.</p> <p>:param what: What to whitelist. :type what: <code>list</code> of <code>type</code> or <code>attr.Attribute</code>\\ s</p> <p>:rtype: <code>callable</code></p> Source code in <code>client/ayon_fusion/vendor/attr/filters.py</code> <pre><code>def include(*what):\n    \"\"\"\n    Whitelist *what*.\n\n    :param what: What to whitelist.\n    :type what: `list` of `type` or `attr.Attribute`\\\\ s\n\n    :rtype: `callable`\n    \"\"\"\n    cls, attrs = _split_what(what)\n\n    def include_(attribute, value):\n        return value.__class__ in cls or attribute in attrs\n\n    return include_\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/setters.html","title":"setters","text":"<p>Commonly used hooks for on_setattr.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/setters.html#client.ayon_fusion.vendor.attr.setters.NO_OP","title":"<code>NO_OP = object()</code>  <code>module-attribute</code>","text":"<p>Sentinel for disabling class-wide on_setattr hooks for certain attributes.</p> <p>Does not work in <code>pipe</code> or within lists.</p> <p>.. versionadded:: 20.1.0</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/setters.html#client.ayon_fusion.vendor.attr.setters.convert","title":"<code>convert(instance, attrib, new_value)</code>","text":"<p>Run attrib's converter -- if it has one --  on new_value and return the result.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/setters.py</code> <pre><code>def convert(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s converter -- if it has one --  on *new_value* and return the\n    result.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    c = attrib.converter\n    if c:\n        return c(new_value)\n\n    return new_value\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/setters.html#client.ayon_fusion.vendor.attr.setters.frozen","title":"<code>frozen(_, __, ___)</code>","text":"<p>Prevent an attribute to be modified.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/setters.py</code> <pre><code>def frozen(_, __, ___):\n    \"\"\"\n    Prevent an attribute to be modified.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    raise FrozenAttributeError()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/setters.html#client.ayon_fusion.vendor.attr.setters.pipe","title":"<code>pipe(*setters)</code>","text":"<p>Run all setters and return the return value of the last one.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/setters.py</code> <pre><code>def pipe(*setters):\n    \"\"\"\n    Run all *setters* and return the return value of the last one.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n\n    def wrapped_pipe(instance, attrib, new_value):\n        rv = new_value\n\n        for setter in setters:\n            rv = setter(instance, attrib, rv)\n\n        return rv\n\n    return wrapped_pipe\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/setters.html#client.ayon_fusion.vendor.attr.setters.validate","title":"<code>validate(instance, attrib, new_value)</code>","text":"<p>Run attrib's validator on new_value if it has one.</p> <p>.. versionadded:: 20.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/setters.py</code> <pre><code>def validate(instance, attrib, new_value):\n    \"\"\"\n    Run *attrib*'s validator on *new_value* if it has one.\n\n    .. versionadded:: 20.1.0\n    \"\"\"\n    if _config._run_validators is False:\n        return new_value\n\n    v = attrib.validator\n    if not v:\n        return new_value\n\n    v(instance, attrib, new_value)\n\n    return new_value\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html","title":"validators","text":"<p>Commonly useful validators.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html#client.ayon_fusion.vendor.attr.validators.and_","title":"<code>and_(*validators)</code>","text":"<p>A validator that composes multiple validators into one.</p> <p>When called on a value, it runs all wrapped validators.</p> <p>:param callables validators: Arbitrary number of validators.</p> <p>.. versionadded:: 17.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/_make.py</code> <pre><code>def and_(*validators):\n    \"\"\"\n    A validator that composes multiple validators into one.\n\n    When called on a value, it runs all wrapped validators.\n\n    :param callables validators: Arbitrary number of validators.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n    vals = []\n    for validator in validators:\n        vals.extend(\n            validator._validators\n            if isinstance(validator, _AndValidator)\n            else [validator]\n        )\n\n    return _AndValidator(tuple(vals))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html#client.ayon_fusion.vendor.attr.validators.deep_iterable","title":"<code>deep_iterable(member_validator, iterable_validator=None)</code>","text":"<p>A validator that performs deep validation of an iterable.</p> <p>:param member_validator: Validator to apply to iterable members :param iterable_validator: Validator to apply to iterable itself     (optional)</p> <p>.. versionadded:: 19.1.0</p> <p>:raises TypeError: if any sub-validators fail</p> Source code in <code>client/ayon_fusion/vendor/attr/validators.py</code> <pre><code>def deep_iterable(member_validator, iterable_validator=None):\n    \"\"\"\n    A validator that performs deep validation of an iterable.\n\n    :param member_validator: Validator to apply to iterable members\n    :param iterable_validator: Validator to apply to iterable itself\n        (optional)\n\n    .. versionadded:: 19.1.0\n\n    :raises TypeError: if any sub-validators fail\n    \"\"\"\n    return _DeepIterable(member_validator, iterable_validator)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html#client.ayon_fusion.vendor.attr.validators.deep_mapping","title":"<code>deep_mapping(key_validator, value_validator, mapping_validator=None)</code>","text":"<p>A validator that performs deep validation of a dictionary.</p> <p>:param key_validator: Validator to apply to dictionary keys :param value_validator: Validator to apply to dictionary values :param mapping_validator: Validator to apply to top-level mapping     attribute (optional)</p> <p>.. versionadded:: 19.1.0</p> <p>:raises TypeError: if any sub-validators fail</p> Source code in <code>client/ayon_fusion/vendor/attr/validators.py</code> <pre><code>def deep_mapping(key_validator, value_validator, mapping_validator=None):\n    \"\"\"\n    A validator that performs deep validation of a dictionary.\n\n    :param key_validator: Validator to apply to dictionary keys\n    :param value_validator: Validator to apply to dictionary values\n    :param mapping_validator: Validator to apply to top-level mapping\n        attribute (optional)\n\n    .. versionadded:: 19.1.0\n\n    :raises TypeError: if any sub-validators fail\n    \"\"\"\n    return _DeepMapping(key_validator, value_validator, mapping_validator)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html#client.ayon_fusion.vendor.attr.validators.in_","title":"<code>in_(options)</code>","text":"<p>A validator that raises a <code>ValueError</code> if the initializer is called with a value that does not belong in the options provided.  The check is performed using <code>value in options</code>.</p> <p>:param options: Allowed options. :type options: list, tuple, <code>enum.Enum</code>, ...</p> <p>:raises ValueError: With a human readable error message, the attribute (of    type <code>attr.Attribute</code>), the expected options, and the value it    got.</p> <p>.. versionadded:: 17.1.0</p> Source code in <code>client/ayon_fusion/vendor/attr/validators.py</code> <pre><code>def in_(options):\n    \"\"\"\n    A validator that raises a `ValueError` if the initializer is called\n    with a value that does not belong in the options provided.  The check is\n    performed using ``value in options``.\n\n    :param options: Allowed options.\n    :type options: list, tuple, `enum.Enum`, ...\n\n    :raises ValueError: With a human readable error message, the attribute (of\n       type `attr.Attribute`), the expected options, and the value it\n       got.\n\n    .. versionadded:: 17.1.0\n    \"\"\"\n    return _InValidator(options)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html#client.ayon_fusion.vendor.attr.validators.instance_of","title":"<code>instance_of(type)</code>","text":"<pre><code>instance_of(type: Type[_T]) -&gt; _ValidatorType[_T]\n</code></pre><pre><code>instance_of(type: Tuple[Type[_T]]) -&gt; _ValidatorType[_T]\n</code></pre><pre><code>instance_of(type: Tuple[Type[_T1], Type[_T2]]) -&gt; _ValidatorType[Union[_T1, _T2]]\n</code></pre><pre><code>instance_of(type: Tuple[Type[_T1], Type[_T2], Type[_T3]]) -&gt; _ValidatorType[Union[_T1, _T2, _T3]]\n</code></pre><pre><code>instance_of(type: Tuple[type, ...]) -&gt; _ValidatorType[Any]\n</code></pre> <p>A validator that raises a <code>TypeError</code> if the initializer is called with a wrong type for this particular attribute (checks are performed using <code>isinstance</code> therefore it's also valid to pass a tuple of types).</p> <p>:param type: The type to check for. :type type: type or tuple of types</p> <p>:raises TypeError: With a human readable error message, the attribute     (of type <code>attr.Attribute</code>), the expected type, and the value it     got.</p> Source code in <code>client/ayon_fusion/vendor/attr/validators.py</code> <pre><code>def instance_of(type):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called\n    with a wrong type for this particular attribute (checks are performed using\n    `isinstance` therefore it's also valid to pass a tuple of types).\n\n    :param type: The type to check for.\n    :type type: type or tuple of types\n\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attr.Attribute`), the expected type, and the value it\n        got.\n    \"\"\"\n    return _InstanceOfValidator(type)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html#client.ayon_fusion.vendor.attr.validators.is_callable","title":"<code>is_callable()</code>","text":"<p>A validator that raises a <code>attr.exceptions.NotCallableError</code> if the initializer is called with a value for this particular attribute that is not callable.</p> <p>.. versionadded:: 19.1.0</p> <p>:raises <code>attr.exceptions.NotCallableError</code>: With a human readable error     message containing the attribute (<code>attr.Attribute</code>) name,     and the value it got.</p> Source code in <code>client/ayon_fusion/vendor/attr/validators.py</code> <pre><code>def is_callable():\n    \"\"\"\n    A validator that raises a `attr.exceptions.NotCallableError` if the\n    initializer is called with a value for this particular attribute\n    that is not callable.\n\n    .. versionadded:: 19.1.0\n\n    :raises `attr.exceptions.NotCallableError`: With a human readable error\n        message containing the attribute (`attr.Attribute`) name,\n        and the value it got.\n    \"\"\"\n    return _IsCallableValidator()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html#client.ayon_fusion.vendor.attr.validators.matches_re","title":"<code>matches_re(regex, flags=0, func=None)</code>","text":"<p>A validator that raises <code>ValueError</code> if the initializer is called with a string that doesn't match regex.</p> <p>:param str regex: a regex string to match against :param int flags: flags that will be passed to the underlying re function     (default 0) :param callable func: which underlying <code>re</code> function to call (options     are <code>re.fullmatch</code>, <code>re.search</code>, <code>re.match</code>, default     is <code>None</code> which means either <code>re.fullmatch</code> or an emulation of     it on Python 2). For performance reasons, they won't be used directly     but on a pre-<code>re.compile</code>\\ ed pattern.</p> <p>.. versionadded:: 19.2.0</p> Source code in <code>client/ayon_fusion/vendor/attr/validators.py</code> <pre><code>def matches_re(regex, flags=0, func=None):\n    r\"\"\"\n    A validator that raises `ValueError` if the initializer is called\n    with a string that doesn't match *regex*.\n\n    :param str regex: a regex string to match against\n    :param int flags: flags that will be passed to the underlying re function\n        (default 0)\n    :param callable func: which underlying `re` function to call (options\n        are `re.fullmatch`, `re.search`, `re.match`, default\n        is ``None`` which means either `re.fullmatch` or an emulation of\n        it on Python 2). For performance reasons, they won't be used directly\n        but on a pre-`re.compile`\\ ed pattern.\n\n    .. versionadded:: 19.2.0\n    \"\"\"\n    fullmatch = getattr(re, \"fullmatch\", None)\n    valid_funcs = (fullmatch, None, re.search, re.match)\n    if func not in valid_funcs:\n        raise ValueError(\n            \"'func' must be one of %s.\"\n            % (\n                \", \".join(\n                    sorted(\n                        e and e.__name__ or \"None\" for e in set(valid_funcs)\n                    )\n                ),\n            )\n        )\n\n    pattern = re.compile(regex, flags)\n    if func is re.match:\n        match_func = pattern.match\n    elif func is re.search:\n        match_func = pattern.search\n    else:\n        if fullmatch:\n            match_func = pattern.fullmatch\n        else:\n            pattern = re.compile(r\"(?:{})\\Z\".format(regex), flags)\n            match_func = pattern.match\n\n    return _MatchesReValidator(pattern, flags, match_func)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html#client.ayon_fusion.vendor.attr.validators.optional","title":"<code>optional(validator)</code>","text":"<p>A validator that makes an attribute optional.  An optional attribute is one which can be set to <code>None</code> in addition to satisfying the requirements of the sub-validator.</p> <p>:param validator: A validator (or a list of validators) that is used for     non-<code>None</code> values. :type validator: callable or <code>list</code> of callables.</p> <p>.. versionadded:: 15.1.0 .. versionchanged:: 17.1.0 validator can be a list of validators.</p> Source code in <code>client/ayon_fusion/vendor/attr/validators.py</code> <pre><code>def optional(validator):\n    \"\"\"\n    A validator that makes an attribute optional.  An optional attribute is one\n    which can be set to ``None`` in addition to satisfying the requirements of\n    the sub-validator.\n\n    :param validator: A validator (or a list of validators) that is used for\n        non-``None`` values.\n    :type validator: callable or `list` of callables.\n\n    .. versionadded:: 15.1.0\n    .. versionchanged:: 17.1.0 *validator* can be a list of validators.\n    \"\"\"\n    if isinstance(validator, list):\n        return _OptionalValidator(_AndValidator(validator))\n    return _OptionalValidator(validator)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/attr/validators.html#client.ayon_fusion.vendor.attr.validators.provides","title":"<code>provides(interface)</code>","text":"<p>A validator that raises a <code>TypeError</code> if the initializer is called with an object that does not provide the requested interface (checks are performed using <code>interface.providedBy(value)</code> (see <code>zope.interface &lt;https://zopeinterface.readthedocs.io/en/latest/&gt;</code>_).</p> <p>:param interface: The interface to check for. :type interface: <code>zope.interface.Interface</code></p> <p>:raises TypeError: With a human readable error message, the attribute     (of type <code>attr.Attribute</code>), the expected interface, and the     value it got.</p> Source code in <code>client/ayon_fusion/vendor/attr/validators.py</code> <pre><code>def provides(interface):\n    \"\"\"\n    A validator that raises a `TypeError` if the initializer is called\n    with an object that does not provide the requested *interface* (checks are\n    performed using ``interface.providedBy(value)`` (see `zope.interface\n    &lt;https://zopeinterface.readthedocs.io/en/latest/&gt;`_).\n\n    :param interface: The interface to check for.\n    :type interface: ``zope.interface.Interface``\n\n    :raises TypeError: With a human readable error message, the attribute\n        (of type `attr.Attribute`), the expected interface, and the\n        value it got.\n    \"\"\"\n    return _ProvidesValidator(interface)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html","title":"urllib3","text":"<p>Python HTTP library with thread-safe connection pooling, file post support, user friendly, and more</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPConnectionPool","title":"<code>HTTPConnectionPool</code>","text":"<p>               Bases: <code>ConnectionPool</code>, <code>RequestMethods</code></p> <p>Thread-safe connection pool for one host.</p> <p>:param host:     Host used for this HTTP Connection (e.g. \"localhost\"), passed into     :class:<code>http.client.HTTPConnection</code>.</p> <p>:param port:     Port used for this HTTP Connection (None is equivalent to 80), passed     into :class:<code>http.client.HTTPConnection</code>.</p> <p>:param strict:     Causes BadStatusLine to be raised if the status line can't be parsed     as a valid HTTP/1.0 or 1.1 status line, passed into     :class:<code>http.client.HTTPConnection</code>.</p> <pre><code>.. note::\n   Only works in Python 2. This parameter is ignored in Python 3.\n</code></pre> <p>:param timeout:     Socket timeout in seconds for each individual connection. This can     be a float or integer, which sets the timeout for the HTTP request,     or an instance of :class:<code>urllib3.util.Timeout</code> which gives you more     fine-grained control over request timeouts. After the constructor has     been parsed, this is always a <code>urllib3.util.Timeout</code> object.</p> <p>:param maxsize:     Number of connections to save that can be reused. More than 1 is useful     in multithreaded situations. If <code>block</code> is set to False, more     connections will be created but they will not be saved once they've     been used.</p> <p>:param block:     If set to True, no more than <code>maxsize</code> connections will be used at     a time. When no free connections are available, the call will block     until a connection has been released. This is a useful side effect for     particular multithreaded situations where one does not want to use more     than maxsize connections per host to prevent flooding.</p> <p>:param headers:     Headers to include with all requests, unless other headers are given     explicitly.</p> <p>:param retries:     Retry configuration to use by default with requests in this pool.</p> <p>:param _proxy:     Parsed proxy URL, should not be used directly, instead, see     :class:<code>urllib3.ProxyManager</code></p> <p>:param _proxy_headers:     A dictionary with proxy headers, should not be used directly,     instead, see :class:<code>urllib3.ProxyManager</code></p> <p>:param **conn_kw:     Additional parameters are used to create fresh :class:<code>urllib3.connection.HTTPConnection</code>,     :class:<code>urllib3.connection.HTTPSConnection</code> instances.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>class HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.\n\n    :param strict:\n        Causes BadStatusLine to be raised if the status line can't be parsed\n        as a valid HTTP/1.0 or 1.1 status line, passed into\n        :class:`http.client.HTTPConnection`.\n\n        .. note::\n           Only works in Python 2. This parameter is ignored in Python 3.\n\n    :param timeout:\n        Socket timeout in seconds for each individual connection. This can\n        be a float or integer, which sets the timeout for the HTTP request,\n        or an instance of :class:`urllib3.util.Timeout` which gives you more\n        fine-grained control over request timeouts. After the constructor has\n        been parsed, this is always a `urllib3.util.Timeout` object.\n\n    :param maxsize:\n        Number of connections to save that can be reused. More than 1 is useful\n        in multithreaded situations. If ``block`` is set to False, more\n        connections will be created but they will not be saved once they've\n        been used.\n\n    :param block:\n        If set to True, no more than ``maxsize`` connections will be used at\n        a time. When no free connections are available, the call will block\n        until a connection has been released. This is a useful side effect for\n        particular multithreaded situations where one does not want to use more\n        than maxsize connections per host to prevent flooding.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param retries:\n        Retry configuration to use by default with requests in this pool.\n\n    :param _proxy:\n        Parsed proxy URL, should not be used directly, instead, see\n        :class:`urllib3.ProxyManager`\n\n    :param _proxy_headers:\n        A dictionary with proxy headers, should not be used directly,\n        instead, see :class:`urllib3.ProxyManager`\n\n    :param \\\\**conn_kw:\n        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,\n        :class:`urllib3.connection.HTTPSConnection` instances.\n    \"\"\"\n\n    scheme = \"http\"\n    ConnectionCls = HTTPConnection\n    ResponseCls = HTTPResponse\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        strict=False,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        _proxy_config=None,\n        **conn_kw\n    ):\n        ConnectionPool.__init__(self, host, port)\n        RequestMethods.__init__(self, headers)\n\n        self.strict = strict\n\n        if not isinstance(timeout, Timeout):\n            timeout = Timeout.from_float(timeout)\n\n        if retries is None:\n            retries = Retry.DEFAULT\n\n        self.timeout = timeout\n        self.retries = retries\n\n        self.pool = self.QueueCls(maxsize)\n        self.block = block\n\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.proxy_config = _proxy_config\n\n        # Fill the queue up so that doing get() on it will block properly\n        for _ in xrange(maxsize):\n            self.pool.put(None)\n\n        # These are mostly for testing and debugging purposes.\n        self.num_connections = 0\n        self.num_requests = 0\n        self.conn_kw = conn_kw\n\n        if self.proxy:\n            # Enable Nagle's algorithm for proxies, to avoid packet fragmentation.\n            # We cannot know if the user has added default socket options, so we cannot replace the\n            # list.\n            self.conn_kw.setdefault(\"socket_options\", [])\n\n            self.conn_kw[\"proxy\"] = self.proxy\n            self.conn_kw[\"proxy_config\"] = self.proxy_config\n\n    def _new_conn(self):\n        \"\"\"\n        Return a fresh :class:`HTTPConnection`.\n        \"\"\"\n        self.num_connections += 1\n        log.debug(\n            \"Starting new HTTP connection (%d): %s:%s\",\n            self.num_connections,\n            self.host,\n            self.port or \"80\",\n        )\n\n        conn = self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            strict=self.strict,\n            **self.conn_kw\n        )\n        return conn\n\n    def _get_conn(self, timeout=None):\n        \"\"\"\n        Get a connection. Will return a pooled connection if one is available.\n\n        If no connections are available and :prop:`.block` is ``False``, then a\n        fresh connection is returned.\n\n        :param timeout:\n            Seconds to wait before giving up and raising\n            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and\n            :prop:`.block` is ``True``.\n        \"\"\"\n        conn = None\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n\n        except AttributeError:  # self.pool is None\n            raise ClosedPoolError(self, \"Pool is closed.\")\n\n        except queue.Empty:\n            if self.block:\n                raise EmptyPoolError(\n                    self,\n                    \"Pool reached maximum size and no more connections are allowed.\",\n                )\n            pass  # Oh well, we'll create a new connection then\n\n        # If this is a persistent connection, check if it got disconnected\n        if conn and is_connection_dropped(conn):\n            log.debug(\"Resetting dropped connection: %s\", self.host)\n            conn.close()\n            if getattr(conn, \"auto_open\", 1) == 0:\n                # This is a proxied connection that has been mutated by\n                # http.client._tunnel() and cannot be reused (since it would\n                # attempt to bypass the proxy)\n                conn = None\n\n        return conn or self._new_conn()\n\n    def _put_conn(self, conn):\n        \"\"\"\n        Put a connection back into the pool.\n\n        :param conn:\n            Connection object for the current host and port as returned by\n            :meth:`._new_conn` or :meth:`._get_conn`.\n\n        If the pool is already full, the connection is closed and discarded\n        because we exceeded maxsize. If connections are discarded frequently,\n        then maxsize should be increased.\n\n        If the pool is closed, then the connection will be closed and discarded.\n        \"\"\"\n        try:\n            self.pool.put(conn, block=False)\n            return  # Everything is dandy, done.\n        except AttributeError:\n            # self.pool is None.\n            pass\n        except queue.Full:\n            # This should never happen if self.block == True\n            log.warning(\"Connection pool is full, discarding connection: %s\", self.host)\n\n        # Connection never got put back into the pool, close it.\n        if conn:\n            conn.close()\n\n    def _validate_conn(self, conn):\n        \"\"\"\n        Called right before a request is made, after the socket is created.\n        \"\"\"\n        pass\n\n    def _prepare_proxy(self, conn):\n        # Nothing to do for HTTP connections.\n        pass\n\n    def _get_timeout(self, timeout):\n        \"\"\"Helper that always returns a :class:`urllib3.util.Timeout`\"\"\"\n        if timeout is _Default:\n            return self.timeout.clone()\n\n        if isinstance(timeout, Timeout):\n            return timeout.clone()\n        else:\n            # User passed us an int/float. This is for backwards compatibility,\n            # can be removed later\n            return Timeout.from_float(timeout)\n\n    def _raise_timeout(self, err, url, timeout_value):\n        \"\"\"Is the error actually a timeout? Will raise a ReadTimeout or pass\"\"\"\n\n        if isinstance(err, SocketTimeout):\n            raise ReadTimeoutError(\n                self, url, \"Read timed out. (read timeout=%s)\" % timeout_value\n            )\n\n        # See the above comment about EAGAIN in Python 3. In Python 2 we have\n        # to specifically catch it and throw the timeout error\n        if hasattr(err, \"errno\") and err.errno in _blocking_errnos:\n            raise ReadTimeoutError(\n                self, url, \"Read timed out. (read timeout=%s)\" % timeout_value\n            )\n\n        # Catch possible read timeouts thrown as SSL errors. If not the\n        # case, rethrow the original. We need to do this because of:\n        # http://bugs.python.org/issue10272\n        if \"timed out\" in str(err) or \"did not complete (read)\" in str(\n            err\n        ):  # Python &lt; 2.7.4\n            raise ReadTimeoutError(\n                self, url, \"Read timed out. (read timeout=%s)\" % timeout_value\n            )\n\n    def _make_request(\n        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw\n    ):\n        \"\"\"\n        Perform a request on a given urllib connection object taken from our\n        pool.\n\n        :param conn:\n            a connection from one of our connection pools\n\n        :param timeout:\n            Socket timeout in seconds for the request. This can be a\n            float or integer, which will set the same timeout value for\n            the socket connect and the socket read, or an instance of\n            :class:`urllib3.util.Timeout`, which gives you more fine-grained\n            control over your timeouts.\n        \"\"\"\n        self.num_requests += 1\n\n        timeout_obj = self._get_timeout(timeout)\n        timeout_obj.start_connect()\n        conn.timeout = timeout_obj.connect_timeout\n\n        # Trigger any extra validation we need to do.\n        try:\n            self._validate_conn(conn)\n        except (SocketTimeout, BaseSSLError) as e:\n            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.\n            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n            raise\n\n        # conn.request() calls http.client.*.request, not the method in\n        # urllib3.request. It also calls makefile (recv) on the socket.\n        try:\n            if chunked:\n                conn.request_chunked(method, url, **httplib_request_kw)\n            else:\n                conn.request(method, url, **httplib_request_kw)\n\n        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is\n        # legitimately able to close the connection after sending a valid response.\n        # With this behaviour, the received response is still readable.\n        except BrokenPipeError:\n            # Python 3\n            pass\n        except IOError as e:\n            # Python 2 and macOS/Linux\n            # EPIPE and ESHUTDOWN are BrokenPipeError on Python 2, and EPROTOTYPE is needed on macOS\n            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/\n            if e.errno not in {\n                errno.EPIPE,\n                errno.ESHUTDOWN,\n                errno.EPROTOTYPE,\n            }:\n                raise\n\n        # Reset the timeout for the recv() on the socket\n        read_timeout = timeout_obj.read_timeout\n\n        # App Engine doesn't have a sock attr\n        if getattr(conn, \"sock\", None):\n            # In Python 3 socket.py will catch EAGAIN and return None when you\n            # try and read into the file pointer created by http.client, which\n            # instead raises a BadStatusLine exception. Instead of catching\n            # the exception and assuming all BadStatusLine exceptions are read\n            # timeouts, check for a zero timeout before making the request.\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, \"Read timed out. (read timeout=%s)\" % read_timeout\n                )\n            if read_timeout is Timeout.DEFAULT_TIMEOUT:\n                conn.sock.settimeout(socket.getdefaulttimeout())\n            else:  # None or a value\n                conn.sock.settimeout(read_timeout)\n\n        # Receive the response from the server\n        try:\n            try:\n                # Python 2.7, use buffering of HTTP responses\n                httplib_response = conn.getresponse(buffering=True)\n            except TypeError:\n                # Python 3\n                try:\n                    httplib_response = conn.getresponse()\n                except BaseException as e:\n                    # Remove the TypeError from the exception chain in\n                    # Python 3 (including for exceptions like SystemExit).\n                    # Otherwise it looks like a bug in the code.\n                    six.raise_from(e, None)\n        except (SocketTimeout, BaseSSLError, SocketError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n            raise\n\n        # AppEngine doesn't have a version attr.\n        http_version = getattr(conn, \"_http_vsn_str\", \"HTTP/?\")\n        log.debug(\n            '%s://%s:%s \"%s %s %s\" %s %s',\n            self.scheme,\n            self.host,\n            self.port,\n            method,\n            url,\n            http_version,\n            httplib_response.status,\n            httplib_response.length,\n        )\n\n        try:\n            assert_header_parsing(httplib_response.msg)\n        except (HeaderParsingError, TypeError) as hpe:  # Platform-specific: Python 3\n            log.warning(\n                \"Failed to parse headers (url=%s): %s\",\n                self._absolute_url(url),\n                hpe,\n                exc_info=True,\n            )\n\n        return httplib_response\n\n    def _absolute_url(self, path):\n        return Url(scheme=self.scheme, host=self.host, port=self.port, path=path).url\n\n    def close(self):\n        \"\"\"\n        Close all pooled connections and disable the pool.\n        \"\"\"\n        if self.pool is None:\n            return\n        # Disable access to the pool\n        old_pool, self.pool = self.pool, None\n\n        try:\n            while True:\n                conn = old_pool.get(block=False)\n                if conn:\n                    conn.close()\n\n        except queue.Empty:\n            pass  # Done.\n\n    def is_same_host(self, url):\n        \"\"\"\n        Check if the given ``url`` is a member of the same host as this\n        connection pool.\n        \"\"\"\n        if url.startswith(\"/\"):\n            return True\n\n        # TODO: Add optional support for socket.gethostbyname checking.\n        scheme, host, port = get_host(url)\n        if host is not None:\n            host = _normalize_host(host, scheme=scheme)\n\n        # Use explicit default port for comparison when none is given\n        if self.port and not port:\n            port = port_by_scheme.get(scheme)\n        elif not self.port and port == port_by_scheme.get(scheme):\n            port = None\n\n        return (scheme, host, port) == (self.scheme, self.host, self.port)\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n\n        .. note::\n\n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n\n        .. note::\n\n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n\n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n\n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n\n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n\n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n\n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n\n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n\n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n\n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n\n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n\n        if headers is None:\n            headers = self.headers\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n\n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n\n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n\n        conn = None\n\n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\n        release_this_conn = release_conn\n\n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n\n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n\n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n\n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n\n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n\n            conn.timeout = timeout_obj.connect_timeout\n\n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n\n            # Make the request on the httplib connection object.\n            httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n            # If we're going to release the connection in ``finally:``, then\n            # the response doesn't need to know about the connection. Otherwise\n            # it will also try to release it and we'll have a double-release\n            # mess.\n            response_conn = conn if not release_conn else None\n\n            # Pass method to Response for length checking\n            response_kw[\"request_method\"] = method\n\n            # Import httplib's response into our own wrapper object\n            response = self.ResponseCls.from_httplib(\n                httplib_response,\n                pool=self,\n                connection=response_conn,\n                retries=retries,\n                **response_kw\n            )\n\n            # Everything went great!\n            clean_exit = True\n\n        except EmptyPoolError:\n            # Didn't get a connection from the pool, no need to clean up\n            clean_exit = True\n            release_this_conn = False\n            raise\n\n        except (\n            TimeoutError,\n            HTTPException,\n            SocketError,\n            ProtocolError,\n            BaseSSLError,\n            SSLError,\n            CertificateError,\n        ) as e:\n            # Discard the connection for these exceptions. It will be\n            # replaced during the next _get_conn() call.\n            clean_exit = False\n            if isinstance(e, (BaseSSLError, CertificateError)):\n                e = SSLError(e)\n            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:\n                e = ProxyError(\"Cannot connect to proxy.\", e)\n            elif isinstance(e, (SocketError, HTTPException)):\n                e = ProtocolError(\"Connection aborted.\", e)\n\n            retries = retries.increment(\n                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]\n            )\n            retries.sleep()\n\n            # Keep track of the error for the retry warning.\n            err = e\n\n        finally:\n            if not clean_exit:\n                # We hit some kind of exception, handled or otherwise. We need\n                # to throw the connection away unless explicitly told not to.\n                # Close the connection, set the variable to None, and make sure\n                # we put the None back in the pool to avoid leaking it.\n                conn = conn and conn.close()\n                release_this_conn = True\n\n            if release_this_conn:\n                # Put the connection back to be reused. If the connection is\n                # expired then it will be None, which will get replaced with a\n                # fresh connection during _get_conn.\n                self._put_conn(conn)\n\n        if not conn:\n            # Try again\n            log.warning(\n                \"Retrying (%r) after connection broken by '%r': %s\", retries, err, url\n            )\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries,\n                redirect,\n                assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                **response_kw\n            )\n\n        # Handle redirect?\n        redirect_location = redirect and response.get_redirect_location()\n        if redirect_location:\n            if response.status == 303:\n                method = \"GET\"\n\n            try:\n                retries = retries.increment(method, url, response=response, _pool=self)\n            except MaxRetryError:\n                if retries.raise_on_redirect:\n                    response.drain_conn()\n                    raise\n                return response\n\n            response.drain_conn()\n            retries.sleep_for_retry(response)\n            log.debug(\"Redirecting %s -&gt; %s\", url, redirect_location)\n            return self.urlopen(\n                method,\n                redirect_location,\n                body,\n                headers,\n                retries=retries,\n                redirect=redirect,\n                assert_same_host=assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                **response_kw\n            )\n\n        # Check if we should retry the HTTP response.\n        has_retry_after = bool(response.getheader(\"Retry-After\"))\n        if retries.is_retry(method, response.status, has_retry_after):\n            try:\n                retries = retries.increment(method, url, response=response, _pool=self)\n            except MaxRetryError:\n                if retries.raise_on_status:\n                    response.drain_conn()\n                    raise\n                return response\n\n            response.drain_conn()\n            retries.sleep(response)\n            log.debug(\"Retry: %s\", url)\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries=retries,\n                redirect=redirect,\n                assert_same_host=assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                **response_kw\n            )\n\n        return response\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPConnectionPool.close","title":"<code>close()</code>","text":"<p>Close all pooled connections and disable the pool.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close all pooled connections and disable the pool.\n    \"\"\"\n    if self.pool is None:\n        return\n    # Disable access to the pool\n    old_pool, self.pool = self.pool, None\n\n    try:\n        while True:\n            conn = old_pool.get(block=False)\n            if conn:\n                conn.close()\n\n    except queue.Empty:\n        pass  # Done.\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPConnectionPool.is_same_host","title":"<code>is_same_host(url)</code>","text":"<p>Check if the given <code>url</code> is a member of the same host as this connection pool.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>def is_same_host(self, url):\n    \"\"\"\n    Check if the given ``url`` is a member of the same host as this\n    connection pool.\n    \"\"\"\n    if url.startswith(\"/\"):\n        return True\n\n    # TODO: Add optional support for socket.gethostbyname checking.\n    scheme, host, port = get_host(url)\n    if host is not None:\n        host = _normalize_host(host, scheme=scheme)\n\n    # Use explicit default port for comparison when none is given\n    if self.port and not port:\n        port = port_by_scheme.get(scheme)\n    elif not self.port and port == port_by_scheme.get(scheme):\n        port = None\n\n    return (scheme, host, port) == (self.scheme, self.host, self.port)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPConnectionPool.urlopen","title":"<code>urlopen(method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, release_conn=None, chunked=False, body_pos=None, **response_kw)</code>","text":"<p>Get a connection from the pool and perform an HTTP request. This is the lowest level call for making a request, so you'll need to specify all the raw details.</p> <p>.. note::</p> <p>More commonly, it's appropriate to use a convenience method provided    by :class:<code>.RequestMethods</code>, such as :meth:<code>request</code>.</p> <p>.. note::</p> <p><code>release_conn</code> will only behave as expected if    <code>preload_content=False</code> because we want to make    <code>preload_content=False</code> the default behaviour someday soon without    breaking backwards compatibility.</p> <p>:param method:     HTTP request method (such as GET, POST, PUT, etc.)</p> <p>:param url:     The URL to perform the request on.</p> <p>:param body:     Data to send in the request body, either :class:<code>str</code>, :class:<code>bytes</code>,     an iterable of :class:<code>str</code>/:class:<code>bytes</code>, or a file-like object.</p> <p>:param headers:     Dictionary of custom headers to send, such as User-Agent,     If-None-Match, etc. If None, pool headers are used. If provided,     these headers completely replace any pool-specific headers.</p> <p>:param retries:     Configure the number of retries to allow before raising a     :class:<code>~urllib3.exceptions.MaxRetryError</code> exception.</p> <pre><code>Pass ``None`` to retry until you receive a response. Pass a\n:class:`~urllib3.util.retry.Retry` object for fine-grained control\nover different types of retries.\nPass an integer number to retry connection errors that many times,\nbut no other types of errors. Pass zero to never retry.\n\nIf ``False``, then retries are disabled and any exception is raised\nimmediately. Also, instead of raising a MaxRetryError on redirects,\nthe redirect response will be returned.\n</code></pre> <p>:type retries: :class:<code>~urllib3.util.retry.Retry</code>, False, or an int.</p> <p>:param redirect:     If True, automatically handle redirects (status codes 301, 302,     303, 307, 308). Each redirect counts as a retry. Disabling retries     will disable redirect, too.</p> <p>:param assert_same_host:     If <code>True</code>, will make sure that the host of the pool requests is     consistent else will raise HostChangedError. When <code>False</code>, you can     use the pool on an HTTP proxy and request foreign hosts.</p> <p>:param timeout:     If specified, overrides the default timeout for this one     request. It may be a float (in seconds) or an instance of     :class:<code>urllib3.util.Timeout</code>.</p> <p>:param pool_timeout:     If set and the pool is set to block=True, then this method will     block for <code>pool_timeout</code> seconds and raise EmptyPoolError if no     connection is available within the time period.</p> <p>:param release_conn:     If False, then the urlopen call will not release the connection     back into the pool once a response is received (but will release if     you read the entire contents of the response such as when     <code>preload_content=True</code>). This is useful if you're not preloading     the response's content immediately. You will need to call     <code>r.release_conn()</code> on the response <code>r</code> to return the connection     back into the pool. If None, it takes the value of     <code>response_kw.get('preload_content', True)</code>.</p> <p>:param chunked:     If True, urllib3 will send the body using chunked transfer     encoding. Otherwise, urllib3 will send the body using the standard     content-length form. Defaults to False.</p> <p>:param int body_pos:     Position to seek to in file-like body in the event of a retry or     redirect. Typically this won't need to be set because urllib3 will     auto-populate the value when needed.</p> <p>:param **response_kw:     Additional parameters are passed to     :meth:<code>urllib3.response.HTTPResponse.from_httplib</code></p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>def urlopen(\n    self,\n    method,\n    url,\n    body=None,\n    headers=None,\n    retries=None,\n    redirect=True,\n    assert_same_host=True,\n    timeout=_Default,\n    pool_timeout=None,\n    release_conn=None,\n    chunked=False,\n    body_pos=None,\n    **response_kw\n):\n    \"\"\"\n    Get a connection from the pool and perform an HTTP request. This is the\n    lowest level call for making a request, so you'll need to specify all\n    the raw details.\n\n    .. note::\n\n       More commonly, it's appropriate to use a convenience method provided\n       by :class:`.RequestMethods`, such as :meth:`request`.\n\n    .. note::\n\n       `release_conn` will only behave as expected if\n       `preload_content=False` because we want to make\n       `preload_content=False` the default behaviour someday soon without\n       breaking backwards compatibility.\n\n    :param method:\n        HTTP request method (such as GET, POST, PUT, etc.)\n\n    :param url:\n        The URL to perform the request on.\n\n    :param body:\n        Data to send in the request body, either :class:`str`, :class:`bytes`,\n        an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n    :param headers:\n        Dictionary of custom headers to send, such as User-Agent,\n        If-None-Match, etc. If None, pool headers are used. If provided,\n        these headers completely replace any pool-specific headers.\n\n    :param retries:\n        Configure the number of retries to allow before raising a\n        :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n        Pass ``None`` to retry until you receive a response. Pass a\n        :class:`~urllib3.util.retry.Retry` object for fine-grained control\n        over different types of retries.\n        Pass an integer number to retry connection errors that many times,\n        but no other types of errors. Pass zero to never retry.\n\n        If ``False``, then retries are disabled and any exception is raised\n        immediately. Also, instead of raising a MaxRetryError on redirects,\n        the redirect response will be returned.\n\n    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n    :param redirect:\n        If True, automatically handle redirects (status codes 301, 302,\n        303, 307, 308). Each redirect counts as a retry. Disabling retries\n        will disable redirect, too.\n\n    :param assert_same_host:\n        If ``True``, will make sure that the host of the pool requests is\n        consistent else will raise HostChangedError. When ``False``, you can\n        use the pool on an HTTP proxy and request foreign hosts.\n\n    :param timeout:\n        If specified, overrides the default timeout for this one\n        request. It may be a float (in seconds) or an instance of\n        :class:`urllib3.util.Timeout`.\n\n    :param pool_timeout:\n        If set and the pool is set to block=True, then this method will\n        block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n        connection is available within the time period.\n\n    :param release_conn:\n        If False, then the urlopen call will not release the connection\n        back into the pool once a response is received (but will release if\n        you read the entire contents of the response such as when\n        `preload_content=True`). This is useful if you're not preloading\n        the response's content immediately. You will need to call\n        ``r.release_conn()`` on the response ``r`` to return the connection\n        back into the pool. If None, it takes the value of\n        ``response_kw.get('preload_content', True)``.\n\n    :param chunked:\n        If True, urllib3 will send the body using chunked transfer\n        encoding. Otherwise, urllib3 will send the body using the standard\n        content-length form. Defaults to False.\n\n    :param int body_pos:\n        Position to seek to in file-like body in the event of a retry or\n        redirect. Typically this won't need to be set because urllib3 will\n        auto-populate the value when needed.\n\n    :param \\\\**response_kw:\n        Additional parameters are passed to\n        :meth:`urllib3.response.HTTPResponse.from_httplib`\n    \"\"\"\n\n    parsed_url = parse_url(url)\n    destination_scheme = parsed_url.scheme\n\n    if headers is None:\n        headers = self.headers\n\n    if not isinstance(retries, Retry):\n        retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n    if release_conn is None:\n        release_conn = response_kw.get(\"preload_content\", True)\n\n    # Check host\n    if assert_same_host and not self.is_same_host(url):\n        raise HostChangedError(self, url, retries)\n\n    # Ensure that the URL we're connecting to is properly encoded\n    if url.startswith(\"/\"):\n        url = six.ensure_str(_encode_target(url))\n    else:\n        url = six.ensure_str(parsed_url.url)\n\n    conn = None\n\n    # Track whether `conn` needs to be released before\n    # returning/raising/recursing. Update this variable if necessary, and\n    # leave `release_conn` constant throughout the function. That way, if\n    # the function recurses, the original value of `release_conn` will be\n    # passed down into the recursive call, and its value will be respected.\n    #\n    # See issue #651 [1] for details.\n    #\n    # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\n    release_this_conn = release_conn\n\n    http_tunnel_required = connection_requires_http_tunnel(\n        self.proxy, self.proxy_config, destination_scheme\n    )\n\n    # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n    # have to copy the headers dict so we can safely change it without those\n    # changes being reflected in anyone else's copy.\n    if not http_tunnel_required:\n        headers = headers.copy()\n        headers.update(self.proxy_headers)\n\n    # Must keep the exception bound to a separate variable or else Python 3\n    # complains about UnboundLocalError.\n    err = None\n\n    # Keep track of whether we cleanly exited the except block. This\n    # ensures we do proper cleanup in finally.\n    clean_exit = False\n\n    # Rewind body position, if needed. Record current position\n    # for future rewinds in the event of a redirect/retry.\n    body_pos = set_file_position(body, body_pos)\n\n    try:\n        # Request a connection from the queue.\n        timeout_obj = self._get_timeout(timeout)\n        conn = self._get_conn(timeout=pool_timeout)\n\n        conn.timeout = timeout_obj.connect_timeout\n\n        is_new_proxy_conn = self.proxy is not None and not getattr(\n            conn, \"sock\", None\n        )\n        if is_new_proxy_conn and http_tunnel_required:\n            self._prepare_proxy(conn)\n\n        # Make the request on the httplib connection object.\n        httplib_response = self._make_request(\n            conn,\n            method,\n            url,\n            timeout=timeout_obj,\n            body=body,\n            headers=headers,\n            chunked=chunked,\n        )\n\n        # If we're going to release the connection in ``finally:``, then\n        # the response doesn't need to know about the connection. Otherwise\n        # it will also try to release it and we'll have a double-release\n        # mess.\n        response_conn = conn if not release_conn else None\n\n        # Pass method to Response for length checking\n        response_kw[\"request_method\"] = method\n\n        # Import httplib's response into our own wrapper object\n        response = self.ResponseCls.from_httplib(\n            httplib_response,\n            pool=self,\n            connection=response_conn,\n            retries=retries,\n            **response_kw\n        )\n\n        # Everything went great!\n        clean_exit = True\n\n    except EmptyPoolError:\n        # Didn't get a connection from the pool, no need to clean up\n        clean_exit = True\n        release_this_conn = False\n        raise\n\n    except (\n        TimeoutError,\n        HTTPException,\n        SocketError,\n        ProtocolError,\n        BaseSSLError,\n        SSLError,\n        CertificateError,\n    ) as e:\n        # Discard the connection for these exceptions. It will be\n        # replaced during the next _get_conn() call.\n        clean_exit = False\n        if isinstance(e, (BaseSSLError, CertificateError)):\n            e = SSLError(e)\n        elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:\n            e = ProxyError(\"Cannot connect to proxy.\", e)\n        elif isinstance(e, (SocketError, HTTPException)):\n            e = ProtocolError(\"Connection aborted.\", e)\n\n        retries = retries.increment(\n            method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]\n        )\n        retries.sleep()\n\n        # Keep track of the error for the retry warning.\n        err = e\n\n    finally:\n        if not clean_exit:\n            # We hit some kind of exception, handled or otherwise. We need\n            # to throw the connection away unless explicitly told not to.\n            # Close the connection, set the variable to None, and make sure\n            # we put the None back in the pool to avoid leaking it.\n            conn = conn and conn.close()\n            release_this_conn = True\n\n        if release_this_conn:\n            # Put the connection back to be reused. If the connection is\n            # expired then it will be None, which will get replaced with a\n            # fresh connection during _get_conn.\n            self._put_conn(conn)\n\n    if not conn:\n        # Try again\n        log.warning(\n            \"Retrying (%r) after connection broken by '%r': %s\", retries, err, url\n        )\n        return self.urlopen(\n            method,\n            url,\n            body,\n            headers,\n            retries,\n            redirect,\n            assert_same_host,\n            timeout=timeout,\n            pool_timeout=pool_timeout,\n            release_conn=release_conn,\n            chunked=chunked,\n            body_pos=body_pos,\n            **response_kw\n        )\n\n    # Handle redirect?\n    redirect_location = redirect and response.get_redirect_location()\n    if redirect_location:\n        if response.status == 303:\n            method = \"GET\"\n\n        try:\n            retries = retries.increment(method, url, response=response, _pool=self)\n        except MaxRetryError:\n            if retries.raise_on_redirect:\n                response.drain_conn()\n                raise\n            return response\n\n        response.drain_conn()\n        retries.sleep_for_retry(response)\n        log.debug(\"Redirecting %s -&gt; %s\", url, redirect_location)\n        return self.urlopen(\n            method,\n            redirect_location,\n            body,\n            headers,\n            retries=retries,\n            redirect=redirect,\n            assert_same_host=assert_same_host,\n            timeout=timeout,\n            pool_timeout=pool_timeout,\n            release_conn=release_conn,\n            chunked=chunked,\n            body_pos=body_pos,\n            **response_kw\n        )\n\n    # Check if we should retry the HTTP response.\n    has_retry_after = bool(response.getheader(\"Retry-After\"))\n    if retries.is_retry(method, response.status, has_retry_after):\n        try:\n            retries = retries.increment(method, url, response=response, _pool=self)\n        except MaxRetryError:\n            if retries.raise_on_status:\n                response.drain_conn()\n                raise\n            return response\n\n        response.drain_conn()\n        retries.sleep(response)\n        log.debug(\"Retry: %s\", url)\n        return self.urlopen(\n            method,\n            url,\n            body,\n            headers,\n            retries=retries,\n            redirect=redirect,\n            assert_same_host=assert_same_host,\n            timeout=timeout,\n            pool_timeout=pool_timeout,\n            release_conn=release_conn,\n            chunked=chunked,\n            body_pos=body_pos,\n            **response_kw\n        )\n\n    return response\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse","title":"<code>HTTPResponse</code>","text":"<p>               Bases: <code>IOBase</code></p> <p>HTTP Response container.</p> <p>Backwards-compatible with :class:<code>http.client.HTTPResponse</code> but the response <code>body</code> is loaded and decoded on-demand when the <code>data</code> property is accessed.  This class is also compatible with the Python standard library's :mod:<code>io</code> module, and can hence be treated as a readable object in the context of that framework.</p> <p>Extra parameters for behaviour not present in :class:<code>http.client.HTTPResponse</code>:</p> <p>:param preload_content:     If True, the response's body will be preloaded during construction.</p> <p>:param decode_content:     If True, will attempt to decode the body based on the     'content-encoding' header.</p> <p>:param original_response:     When this HTTPResponse wrapper is generated from an :class:<code>http.client.HTTPResponse</code>     object, it's convenient to include the original for debug purposes. It's     otherwise unused.</p> <p>:param retries:     The retries contains the last :class:<code>~urllib3.util.retry.Retry</code> that     was used during the request.</p> <p>:param enforce_content_length:     Enforce content length checking. Body returned by server must match     value of Content-Length header, if present. Otherwise, raise error.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>class HTTPResponse(io.IOBase):\n    \"\"\"\n    HTTP Response container.\n\n    Backwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is\n    loaded and decoded on-demand when the ``data`` property is accessed.  This\n    class is also compatible with the Python standard library's :mod:`io`\n    module, and can hence be treated as a readable object in the context of that\n    framework.\n\n    Extra parameters for behaviour not present in :class:`http.client.HTTPResponse`:\n\n    :param preload_content:\n        If True, the response's body will be preloaded during construction.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n\n    :param original_response:\n        When this HTTPResponse wrapper is generated from an :class:`http.client.HTTPResponse`\n        object, it's convenient to include the original for debug purposes. It's\n        otherwise unused.\n\n    :param retries:\n        The retries contains the last :class:`~urllib3.util.retry.Retry` that\n        was used during the request.\n\n    :param enforce_content_length:\n        Enforce content length checking. Body returned by server must match\n        value of Content-Length header, if present. Otherwise, raise error.\n    \"\"\"\n\n    CONTENT_DECODERS = [\"gzip\", \"deflate\"]\n    if brotli is not None:\n        CONTENT_DECODERS += [\"br\"]\n    REDIRECT_STATUSES = [301, 302, 303, 307, 308]\n\n    def __init__(\n        self,\n        body=\"\",\n        headers=None,\n        status=0,\n        version=0,\n        reason=None,\n        strict=0,\n        preload_content=True,\n        decode_content=True,\n        original_response=None,\n        pool=None,\n        connection=None,\n        msg=None,\n        retries=None,\n        enforce_content_length=False,\n        request_method=None,\n        request_url=None,\n        auto_close=True,\n    ):\n\n        if isinstance(headers, HTTPHeaderDict):\n            self.headers = headers\n        else:\n            self.headers = HTTPHeaderDict(headers)\n        self.status = status\n        self.version = version\n        self.reason = reason\n        self.strict = strict\n        self.decode_content = decode_content\n        self.retries = retries\n        self.enforce_content_length = enforce_content_length\n        self.auto_close = auto_close\n\n        self._decoder = None\n        self._body = None\n        self._fp = None\n        self._original_response = original_response\n        self._fp_bytes_read = 0\n        self.msg = msg\n        self._request_url = request_url\n\n        if body and isinstance(body, (six.string_types, bytes)):\n            self._body = body\n\n        self._pool = pool\n        self._connection = connection\n\n        if hasattr(body, \"read\"):\n            self._fp = body\n\n        # Are we using the chunked-style of transfer encoding?\n        self.chunked = False\n        self.chunk_left = None\n        tr_enc = self.headers.get(\"transfer-encoding\", \"\").lower()\n        # Don't incur the penalty of creating a list and then discarding it\n        encodings = (enc.strip() for enc in tr_enc.split(\",\"))\n        if \"chunked\" in encodings:\n            self.chunked = True\n\n        # Determine length of response\n        self.length_remaining = self._init_length(request_method)\n\n        # If requested, preload the body.\n        if preload_content and not self._body:\n            self._body = self.read(decode_content=decode_content)\n\n    def get_redirect_location(self):\n        \"\"\"\n        Should we redirect and where to?\n\n        :returns: Truthy redirect location string if we got a redirect status\n            code and valid location. ``None`` if redirect status and no\n            location. ``False`` if not a redirect status code.\n        \"\"\"\n        if self.status in self.REDIRECT_STATUSES:\n            return self.headers.get(\"location\")\n\n        return False\n\n    def release_conn(self):\n        if not self._pool or not self._connection:\n            return\n\n        self._pool._put_conn(self._connection)\n        self._connection = None\n\n    def drain_conn(self):\n        \"\"\"\n        Read and discard any remaining HTTP response data in the response connection.\n\n        Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.\n        \"\"\"\n        try:\n            self.read()\n        except (HTTPError, SocketError, BaseSSLError, HTTPException):\n            pass\n\n    @property\n    def data(self):\n        # For backwards-compat with earlier urllib3 0.4 and earlier.\n        if self._body:\n            return self._body\n\n        if self._fp:\n            return self.read(cache_content=True)\n\n    @property\n    def connection(self):\n        return self._connection\n\n    def isclosed(self):\n        return is_fp_closed(self._fp)\n\n    def tell(self):\n        \"\"\"\n        Obtain the number of bytes pulled over the wire so far. May differ from\n        the amount of content returned by :meth:``urllib3.response.HTTPResponse.read``\n        if bytes are encoded on the wire (e.g, compressed).\n        \"\"\"\n        return self._fp_bytes_read\n\n    def _init_length(self, request_method):\n        \"\"\"\n        Set initial length value for Response content if available.\n        \"\"\"\n        length = self.headers.get(\"content-length\")\n\n        if length is not None:\n            if self.chunked:\n                # This Response will fail with an IncompleteRead if it can't be\n                # received as chunked. This method falls back to attempt reading\n                # the response before raising an exception.\n                log.warning(\n                    \"Received response with both Content-Length and \"\n                    \"Transfer-Encoding set. This is expressly forbidden \"\n                    \"by RFC 7230 sec 3.3.2. Ignoring Content-Length and \"\n                    \"attempting to process response as Transfer-Encoding: \"\n                    \"chunked.\"\n                )\n                return None\n\n            try:\n                # RFC 7230 section 3.3.2 specifies multiple content lengths can\n                # be sent in a single Content-Length header\n                # (e.g. Content-Length: 42, 42). This line ensures the values\n                # are all valid ints and that as long as the `set` length is 1,\n                # all values are the same. Otherwise, the header is invalid.\n                lengths = set([int(val) for val in length.split(\",\")])\n                if len(lengths) &gt; 1:\n                    raise InvalidHeader(\n                        \"Content-Length contained multiple \"\n                        \"unmatching values (%s)\" % length\n                    )\n                length = lengths.pop()\n            except ValueError:\n                length = None\n            else:\n                if length &lt; 0:\n                    length = None\n\n        # Convert status to int for comparison\n        # In some cases, httplib returns a status of \"_UNKNOWN\"\n        try:\n            status = int(self.status)\n        except ValueError:\n            status = 0\n\n        # Check for responses that shouldn't include a body\n        if status in (204, 304) or 100 &lt;= status &lt; 200 or request_method == \"HEAD\":\n            length = 0\n\n        return length\n\n    def _init_decoder(self):\n        \"\"\"\n        Set-up the _decoder attribute if necessary.\n        \"\"\"\n        # Note: content-encoding value should be case-insensitive, per RFC 7230\n        # Section 3.2\n        content_encoding = self.headers.get(\"content-encoding\", \"\").lower()\n        if self._decoder is None:\n            if content_encoding in self.CONTENT_DECODERS:\n                self._decoder = _get_decoder(content_encoding)\n            elif \",\" in content_encoding:\n                encodings = [\n                    e.strip()\n                    for e in content_encoding.split(\",\")\n                    if e.strip() in self.CONTENT_DECODERS\n                ]\n                if len(encodings):\n                    self._decoder = _get_decoder(content_encoding)\n\n    DECODER_ERROR_CLASSES = (IOError, zlib.error)\n    if brotli is not None:\n        DECODER_ERROR_CLASSES += (brotli.error,)\n\n    def _decode(self, data, decode_content, flush_decoder):\n        \"\"\"\n        Decode the data passed in and potentially flush the decoder.\n        \"\"\"\n        if not decode_content:\n            return data\n\n        try:\n            if self._decoder:\n                data = self._decoder.decompress(data)\n        except self.DECODER_ERROR_CLASSES as e:\n            content_encoding = self.headers.get(\"content-encoding\", \"\").lower()\n            raise DecodeError(\n                \"Received response with content-encoding: %s, but \"\n                \"failed to decode it.\" % content_encoding,\n                e,\n            )\n        if flush_decoder:\n            data += self._flush_decoder()\n\n        return data\n\n    def _flush_decoder(self):\n        \"\"\"\n        Flushes the decoder. Should only be called if the decoder is actually\n        being used.\n        \"\"\"\n        if self._decoder:\n            buf = self._decoder.decompress(b\"\")\n            return buf + self._decoder.flush()\n\n        return b\"\"\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n\n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n\n        try:\n            try:\n                yield\n\n            except SocketTimeout:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n\n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e)\n\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n\n            except (HTTPException, SocketError) as e:\n                # This includes IncompleteRead.\n                raise ProtocolError(\"Connection broken: %r\" % e, e)\n\n            # If no exception is thrown, we should avoid cleaning up\n            # unnecessarily.\n            clean_exit = True\n        finally:\n            # If we didn't terminate cleanly, we need to throw away our\n            # connection.\n            if not clean_exit:\n                # The response may not be closed but we're not going to use it\n                # anymore so close it now to ensure that the connection is\n                # released back to the pool.\n                if self._original_response:\n                    self._original_response.close()\n\n                # Closing the response may not actually be sufficient to close\n                # everything, so if we have a hold of the connection close that\n                # too.\n                if self._connection:\n                    self._connection.close()\n\n            # If we hold the original response but it's closed now, we should\n            # return the connection back to the pool.\n            if self._original_response and self._original_response.isclosed():\n                self.release_conn()\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n\n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n\n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n\n        if self._fp is None:\n            return\n\n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n\n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n                data = self._fp.read(amt) if not fp_closed else b\"\"\n                if (\n                    amt != 0 and not data\n                ):  # Platform-specific: Buggy versions of Python.\n                    # Close the connection when no data is returned\n                    #\n                    # This is redundant to what httplib/http.client _should_\n                    # already do.  However, versions of python released before\n                    # December 15, 2012 (http://bugs.python.org/issue16298) do\n                    # not properly close the connection in all cases. There is\n                    # no harm in redundantly calling close.\n                    self._fp.close()\n                    flush_decoder = True\n                    if self.enforce_content_length and self.length_remaining not in (\n                        0,\n                        None,\n                    ):\n                        # This is an edge case that httplib failed to cover due\n                        # to concerns of backward compatibility. We're\n                        # addressing it here to make sure IncompleteRead is\n                        # raised during streaming, so all calls with incorrect\n                        # Content-Length are caught.\n                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n\n        if data:\n            self._fp_bytes_read += len(data)\n            if self.length_remaining is not None:\n                self.length_remaining -= len(data)\n\n            data = self._decode(data, decode_content, flush_decoder)\n\n            if cache_content:\n                self._body = data\n\n        return data\n\n    def stream(self, amt=2 ** 16, decode_content=None):\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n\n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if self.chunked and self.supports_chunked_reads():\n            for line in self.read_chunked(amt, decode_content=decode_content):\n                yield line\n        else:\n            while not is_fp_closed(self._fp):\n                data = self.read(amt=amt, decode_content=decode_content)\n\n                if data:\n                    yield data\n\n    @classmethod\n    def from_httplib(ResponseCls, r, **response_kw):\n        \"\"\"\n        Given an :class:`http.client.HTTPResponse` instance ``r``, return a\n        corresponding :class:`urllib3.response.HTTPResponse` object.\n\n        Remaining parameters are passed to the HTTPResponse constructor, along\n        with ``original_response=r``.\n        \"\"\"\n        headers = r.msg\n\n        if not isinstance(headers, HTTPHeaderDict):\n            if six.PY2:\n                # Python 2.7\n                headers = HTTPHeaderDict.from_httplib(headers)\n            else:\n                headers = HTTPHeaderDict(headers.items())\n\n        # HTTPResponse objects in Python 3 don't have a .strict attribute\n        strict = getattr(r, \"strict\", 0)\n        resp = ResponseCls(\n            body=r,\n            headers=headers,\n            status=r.status,\n            version=r.version,\n            reason=r.reason,\n            strict=strict,\n            original_response=r,\n            **response_kw\n        )\n        return resp\n\n    # Backwards-compatibility methods for http.client.HTTPResponse\n    def getheaders(self):\n        return self.headers\n\n    def getheader(self, name, default=None):\n        return self.headers.get(name, default)\n\n    # Backwards compatibility for http.cookiejar\n    def info(self):\n        return self.headers\n\n    # Overrides from io.IOBase\n    def close(self):\n        if not self.closed:\n            self._fp.close()\n\n        if self._connection:\n            self._connection.close()\n\n        if not self.auto_close:\n            io.IOBase.close(self)\n\n    @property\n    def closed(self):\n        if not self.auto_close:\n            return io.IOBase.closed.__get__(self)\n        elif self._fp is None:\n            return True\n        elif hasattr(self._fp, \"isclosed\"):\n            return self._fp.isclosed()\n        elif hasattr(self._fp, \"closed\"):\n            return self._fp.closed\n        else:\n            return True\n\n    def fileno(self):\n        if self._fp is None:\n            raise IOError(\"HTTPResponse has no file to get a fileno from\")\n        elif hasattr(self._fp, \"fileno\"):\n            return self._fp.fileno()\n        else:\n            raise IOError(\n                \"The file-like object this HTTPResponse is wrapped \"\n                \"around has no file descriptor\"\n            )\n\n    def flush(self):\n        if (\n            self._fp is not None\n            and hasattr(self._fp, \"flush\")\n            and not getattr(self._fp, \"closed\", False)\n        ):\n            return self._fp.flush()\n\n    def readable(self):\n        # This method is required for `io` module compatibility.\n        return True\n\n    def readinto(self, b):\n        # This method is required for `io` module compatibility.\n        temp = self.read(len(b))\n        if len(temp) == 0:\n            return 0\n        else:\n            b[: len(temp)] = temp\n            return len(temp)\n\n    def supports_chunked_reads(self):\n        \"\"\"\n        Checks if the underlying file-like object looks like a\n        :class:`http.client.HTTPResponse` object. We do this by testing for\n        the fp attribute. If it is present we assume it returns raw chunks as\n        processed by read_chunked().\n        \"\"\"\n        return hasattr(self._fp, \"fp\")\n\n    def _update_chunk_length(self):\n        # First, we'll figure out length of a chunk and then\n        # we'll try to read it from socket.\n        if self.chunk_left is not None:\n            return\n        line = self._fp.fp.readline()\n        line = line.split(b\";\", 1)[0]\n        try:\n            self.chunk_left = int(line, 16)\n        except ValueError:\n            # Invalid chunked protocol response, abort.\n            self.close()\n            raise InvalidChunkLength(self, line)\n\n    def _handle_chunk(self, amt):\n        returned_chunk = None\n        if amt is None:\n            chunk = self._fp._safe_read(self.chunk_left)\n            returned_chunk = chunk\n            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n        elif amt &lt; self.chunk_left:\n            value = self._fp._safe_read(amt)\n            self.chunk_left = self.chunk_left - amt\n            returned_chunk = value\n        elif amt == self.chunk_left:\n            value = self._fp._safe_read(amt)\n            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n            returned_chunk = value\n        else:  # amt &gt; self.chunk_left\n            returned_chunk = self._fp._safe_read(self.chunk_left)\n            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n        return returned_chunk\n\n    def read_chunked(self, amt=None, decode_content=None):\n        \"\"\"\n        Similar to :meth:`HTTPResponse.read`, but with an additional\n        parameter: ``decode_content``.\n\n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        self._init_decoder()\n        # FIXME: Rewrite this method and make it a class with a better structured logic.\n        if not self.chunked:\n            raise ResponseNotChunked(\n                \"Response is not chunked. \"\n                \"Header 'transfer-encoding: chunked' is missing.\"\n            )\n        if not self.supports_chunked_reads():\n            raise BodyNotHttplibCompatible(\n                \"Body should be http.client.HTTPResponse like. \"\n                \"It should have have an fp attribute which returns raw chunks.\"\n            )\n\n        with self._error_catcher():\n            # Don't bother reading the body of a HEAD request.\n            if self._original_response and is_response_to_head(self._original_response):\n                self._original_response.close()\n                return\n\n            # If a response is already read and closed\n            # then return immediately.\n            if self._fp.fp is None:\n                return\n\n            while True:\n                self._update_chunk_length()\n                if self.chunk_left == 0:\n                    break\n                chunk = self._handle_chunk(amt)\n                decoded = self._decode(\n                    chunk, decode_content=decode_content, flush_decoder=False\n                )\n                if decoded:\n                    yield decoded\n\n            if decode_content:\n                # On CPython and PyPy, we should never need to flush the\n                # decoder. However, on Jython we *might* need to, so\n                # lets defensively do it anyway.\n                decoded = self._flush_decoder()\n                if decoded:  # Platform-specific: Jython.\n                    yield decoded\n\n            # Chunk content ends with \\r\\n: discard it.\n            while True:\n                line = self._fp.fp.readline()\n                if not line:\n                    # Some sites may not end with '\\r\\n'.\n                    break\n                if line == b\"\\r\\n\":\n                    break\n\n            # We read everything; close the \"file\".\n            if self._original_response:\n                self._original_response.close()\n\n    def geturl(self):\n        \"\"\"\n        Returns the URL that was the source of this response.\n        If the request that generated this response redirected, this method\n        will return the final redirect location.\n        \"\"\"\n        if self.retries is not None and len(self.retries.history):\n            return self.retries.history[-1].redirect_location\n        else:\n            return self._request_url\n\n    def __iter__(self):\n        buffer = []\n        for chunk in self.stream(decode_content=True):\n            if b\"\\n\" in chunk:\n                chunk = chunk.split(b\"\\n\")\n                yield b\"\".join(buffer) + chunk[0] + b\"\\n\"\n                for x in chunk[1:-1]:\n                    yield x + b\"\\n\"\n                if chunk[-1]:\n                    buffer = [chunk[-1]]\n                else:\n                    buffer = []\n            else:\n                buffer.append(chunk)\n        if buffer:\n            yield b\"\".join(buffer)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse.drain_conn","title":"<code>drain_conn()</code>","text":"<p>Read and discard any remaining HTTP response data in the response connection.</p> <p>Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def drain_conn(self):\n    \"\"\"\n    Read and discard any remaining HTTP response data in the response connection.\n\n    Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.\n    \"\"\"\n    try:\n        self.read()\n    except (HTTPError, SocketError, BaseSSLError, HTTPException):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse.from_httplib","title":"<code>from_httplib(ResponseCls, r, **response_kw)</code>  <code>classmethod</code>","text":"<p>Given an :class:<code>http.client.HTTPResponse</code> instance <code>r</code>, return a corresponding :class:<code>urllib3.response.HTTPResponse</code> object.</p> <p>Remaining parameters are passed to the HTTPResponse constructor, along with <code>original_response=r</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>@classmethod\ndef from_httplib(ResponseCls, r, **response_kw):\n    \"\"\"\n    Given an :class:`http.client.HTTPResponse` instance ``r``, return a\n    corresponding :class:`urllib3.response.HTTPResponse` object.\n\n    Remaining parameters are passed to the HTTPResponse constructor, along\n    with ``original_response=r``.\n    \"\"\"\n    headers = r.msg\n\n    if not isinstance(headers, HTTPHeaderDict):\n        if six.PY2:\n            # Python 2.7\n            headers = HTTPHeaderDict.from_httplib(headers)\n        else:\n            headers = HTTPHeaderDict(headers.items())\n\n    # HTTPResponse objects in Python 3 don't have a .strict attribute\n    strict = getattr(r, \"strict\", 0)\n    resp = ResponseCls(\n        body=r,\n        headers=headers,\n        status=r.status,\n        version=r.version,\n        reason=r.reason,\n        strict=strict,\n        original_response=r,\n        **response_kw\n    )\n    return resp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse.get_redirect_location","title":"<code>get_redirect_location()</code>","text":"<p>Should we redirect and where to?</p> <p>:returns: Truthy redirect location string if we got a redirect status     code and valid location. <code>None</code> if redirect status and no     location. <code>False</code> if not a redirect status code.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def get_redirect_location(self):\n    \"\"\"\n    Should we redirect and where to?\n\n    :returns: Truthy redirect location string if we got a redirect status\n        code and valid location. ``None`` if redirect status and no\n        location. ``False`` if not a redirect status code.\n    \"\"\"\n    if self.status in self.REDIRECT_STATUSES:\n        return self.headers.get(\"location\")\n\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse.geturl","title":"<code>geturl()</code>","text":"<p>Returns the URL that was the source of this response. If the request that generated this response redirected, this method will return the final redirect location.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def geturl(self):\n    \"\"\"\n    Returns the URL that was the source of this response.\n    If the request that generated this response redirected, this method\n    will return the final redirect location.\n    \"\"\"\n    if self.retries is not None and len(self.retries.history):\n        return self.retries.history[-1].redirect_location\n    else:\n        return self._request_url\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse.read","title":"<code>read(amt=None, decode_content=None, cache_content=False)</code>","text":"<p>Similar to :meth:<code>http.client.HTTPResponse.read</code>, but with two additional parameters: <code>decode_content</code> and <code>cache_content</code>.</p> <p>:param amt:     How much of the content to read. If specified, caching is skipped     because it doesn't make sense to cache partial content as the full     response.</p> <p>:param decode_content:     If True, will attempt to decode the body based on the     'content-encoding' header.</p> <p>:param cache_content:     If True, will save the returned data such that the same result is     returned despite of the state of the underlying file object. This     is useful if you want the <code>.data</code> property to continue working     after having <code>.read()</code> the file object. (Overridden if <code>amt</code> is     set.)</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def read(self, amt=None, decode_content=None, cache_content=False):\n    \"\"\"\n    Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n    parameters: ``decode_content`` and ``cache_content``.\n\n    :param amt:\n        How much of the content to read. If specified, caching is skipped\n        because it doesn't make sense to cache partial content as the full\n        response.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n\n    :param cache_content:\n        If True, will save the returned data such that the same result is\n        returned despite of the state of the underlying file object. This\n        is useful if you want the ``.data`` property to continue working\n        after having ``.read()`` the file object. (Overridden if ``amt`` is\n        set.)\n    \"\"\"\n    self._init_decoder()\n    if decode_content is None:\n        decode_content = self.decode_content\n\n    if self._fp is None:\n        return\n\n    flush_decoder = False\n    fp_closed = getattr(self._fp, \"closed\", False)\n\n    with self._error_catcher():\n        if amt is None:\n            # cStringIO doesn't like amt=None\n            data = self._fp.read() if not fp_closed else b\"\"\n            flush_decoder = True\n        else:\n            cache_content = False\n            data = self._fp.read(amt) if not fp_closed else b\"\"\n            if (\n                amt != 0 and not data\n            ):  # Platform-specific: Buggy versions of Python.\n                # Close the connection when no data is returned\n                #\n                # This is redundant to what httplib/http.client _should_\n                # already do.  However, versions of python released before\n                # December 15, 2012 (http://bugs.python.org/issue16298) do\n                # not properly close the connection in all cases. There is\n                # no harm in redundantly calling close.\n                self._fp.close()\n                flush_decoder = True\n                if self.enforce_content_length and self.length_remaining not in (\n                    0,\n                    None,\n                ):\n                    # This is an edge case that httplib failed to cover due\n                    # to concerns of backward compatibility. We're\n                    # addressing it here to make sure IncompleteRead is\n                    # raised during streaming, so all calls with incorrect\n                    # Content-Length are caught.\n                    raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n\n    if data:\n        self._fp_bytes_read += len(data)\n        if self.length_remaining is not None:\n            self.length_remaining -= len(data)\n\n        data = self._decode(data, decode_content, flush_decoder)\n\n        if cache_content:\n            self._body = data\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse.read_chunked","title":"<code>read_chunked(amt=None, decode_content=None)</code>","text":"<p>Similar to :meth:<code>HTTPResponse.read</code>, but with an additional parameter: <code>decode_content</code>.</p> <p>:param amt:     How much of the content to read. If specified, caching is skipped     because it doesn't make sense to cache partial content as the full     response.</p> <p>:param decode_content:     If True, will attempt to decode the body based on the     'content-encoding' header.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def read_chunked(self, amt=None, decode_content=None):\n    \"\"\"\n    Similar to :meth:`HTTPResponse.read`, but with an additional\n    parameter: ``decode_content``.\n\n    :param amt:\n        How much of the content to read. If specified, caching is skipped\n        because it doesn't make sense to cache partial content as the full\n        response.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n    \"\"\"\n    self._init_decoder()\n    # FIXME: Rewrite this method and make it a class with a better structured logic.\n    if not self.chunked:\n        raise ResponseNotChunked(\n            \"Response is not chunked. \"\n            \"Header 'transfer-encoding: chunked' is missing.\"\n        )\n    if not self.supports_chunked_reads():\n        raise BodyNotHttplibCompatible(\n            \"Body should be http.client.HTTPResponse like. \"\n            \"It should have have an fp attribute which returns raw chunks.\"\n        )\n\n    with self._error_catcher():\n        # Don't bother reading the body of a HEAD request.\n        if self._original_response and is_response_to_head(self._original_response):\n            self._original_response.close()\n            return\n\n        # If a response is already read and closed\n        # then return immediately.\n        if self._fp.fp is None:\n            return\n\n        while True:\n            self._update_chunk_length()\n            if self.chunk_left == 0:\n                break\n            chunk = self._handle_chunk(amt)\n            decoded = self._decode(\n                chunk, decode_content=decode_content, flush_decoder=False\n            )\n            if decoded:\n                yield decoded\n\n        if decode_content:\n            # On CPython and PyPy, we should never need to flush the\n            # decoder. However, on Jython we *might* need to, so\n            # lets defensively do it anyway.\n            decoded = self._flush_decoder()\n            if decoded:  # Platform-specific: Jython.\n                yield decoded\n\n        # Chunk content ends with \\r\\n: discard it.\n        while True:\n            line = self._fp.fp.readline()\n            if not line:\n                # Some sites may not end with '\\r\\n'.\n                break\n            if line == b\"\\r\\n\":\n                break\n\n        # We read everything; close the \"file\".\n        if self._original_response:\n            self._original_response.close()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse.stream","title":"<code>stream(amt=2 ** 16, decode_content=None)</code>","text":"<p>A generator wrapper for the read() method. A call will block until <code>amt</code> bytes have been read from the connection or until the connection is closed.</p> <p>:param amt:     How much of the content to read. The generator will return up to     much data per iteration, but may return less. This is particularly     likely when using compressed data. However, the empty string will     never be returned.</p> <p>:param decode_content:     If True, will attempt to decode the body based on the     'content-encoding' header.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def stream(self, amt=2 ** 16, decode_content=None):\n    \"\"\"\n    A generator wrapper for the read() method. A call will block until\n    ``amt`` bytes have been read from the connection or until the\n    connection is closed.\n\n    :param amt:\n        How much of the content to read. The generator will return up to\n        much data per iteration, but may return less. This is particularly\n        likely when using compressed data. However, the empty string will\n        never be returned.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n    \"\"\"\n    if self.chunked and self.supports_chunked_reads():\n        for line in self.read_chunked(amt, decode_content=decode_content):\n            yield line\n    else:\n        while not is_fp_closed(self._fp):\n            data = self.read(amt=amt, decode_content=decode_content)\n\n            if data:\n                yield data\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse.supports_chunked_reads","title":"<code>supports_chunked_reads()</code>","text":"<p>Checks if the underlying file-like object looks like a :class:<code>http.client.HTTPResponse</code> object. We do this by testing for the fp attribute. If it is present we assume it returns raw chunks as processed by read_chunked().</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def supports_chunked_reads(self):\n    \"\"\"\n    Checks if the underlying file-like object looks like a\n    :class:`http.client.HTTPResponse` object. We do this by testing for\n    the fp attribute. If it is present we assume it returns raw chunks as\n    processed by read_chunked().\n    \"\"\"\n    return hasattr(self._fp, \"fp\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPResponse.tell","title":"<code>tell()</code>","text":"<p>Obtain the number of bytes pulled over the wire so far. May differ from the amount of content returned by :meth:<code>urllib3.response.HTTPResponse.read</code> if bytes are encoded on the wire (e.g, compressed).</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def tell(self):\n    \"\"\"\n    Obtain the number of bytes pulled over the wire so far. May differ from\n    the amount of content returned by :meth:``urllib3.response.HTTPResponse.read``\n    if bytes are encoded on the wire (e.g, compressed).\n    \"\"\"\n    return self._fp_bytes_read\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.HTTPSConnectionPool","title":"<code>HTTPSConnectionPool</code>","text":"<p>               Bases: <code>HTTPConnectionPool</code></p> <p>Same as :class:<code>.HTTPConnectionPool</code>, but HTTPS.</p> <p>:class:<code>.HTTPSConnection</code> uses one of <code>assert_fingerprint</code>, <code>assert_hostname</code> and <code>host</code> in this order to verify connections. If <code>assert_hostname</code> is False, no verification is done.</p> <p>The <code>key_file</code>, <code>cert_file</code>, <code>cert_reqs</code>, <code>ca_certs</code>, <code>ca_cert_dir</code>, <code>ssl_version</code>, <code>key_password</code> are only used if :mod:<code>ssl</code> is available and are fed into :meth:<code>urllib3.util.ssl_wrap_socket</code> to upgrade the connection socket into an SSL socket.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>class HTTPSConnectionPool(HTTPConnectionPool):\n    \"\"\"\n    Same as :class:`.HTTPConnectionPool`, but HTTPS.\n\n    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,\n    ``assert_hostname`` and ``host`` in this order to verify connections.\n    If ``assert_hostname`` is False, no verification is done.\n\n    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,\n    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`\n    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade\n    the connection socket into an SSL socket.\n    \"\"\"\n\n    scheme = \"https\"\n    ConnectionCls = HTTPSConnection\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        strict=False,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        key_file=None,\n        cert_file=None,\n        cert_reqs=None,\n        key_password=None,\n        ca_certs=None,\n        ssl_version=None,\n        assert_hostname=None,\n        assert_fingerprint=None,\n        ca_cert_dir=None,\n        **conn_kw\n    ):\n\n        HTTPConnectionPool.__init__(\n            self,\n            host,\n            port,\n            strict,\n            timeout,\n            maxsize,\n            block,\n            headers,\n            retries,\n            _proxy,\n            _proxy_headers,\n            **conn_kw\n        )\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.key_password = key_password\n        self.ca_certs = ca_certs\n        self.ca_cert_dir = ca_cert_dir\n        self.ssl_version = ssl_version\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n\n    def _prepare_conn(self, conn):\n        \"\"\"\n        Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket`\n        and establish the tunnel if proxy is used.\n        \"\"\"\n\n        if isinstance(conn, VerifiedHTTPSConnection):\n            conn.set_cert(\n                key_file=self.key_file,\n                key_password=self.key_password,\n                cert_file=self.cert_file,\n                cert_reqs=self.cert_reqs,\n                ca_certs=self.ca_certs,\n                ca_cert_dir=self.ca_cert_dir,\n                assert_hostname=self.assert_hostname,\n                assert_fingerprint=self.assert_fingerprint,\n            )\n            conn.ssl_version = self.ssl_version\n        return conn\n\n    def _prepare_proxy(self, conn):\n        \"\"\"\n        Establishes a tunnel connection through HTTP CONNECT.\n\n        Tunnel connection is established early because otherwise httplib would\n        improperly set Host: header to proxy's IP:port.\n        \"\"\"\n\n        conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers)\n\n        if self.proxy.scheme == \"https\":\n            conn.tls_in_tls_required = True\n\n        conn.connect()\n\n    def _new_conn(self):\n        \"\"\"\n        Return a fresh :class:`http.client.HTTPSConnection`.\n        \"\"\"\n        self.num_connections += 1\n        log.debug(\n            \"Starting new HTTPS connection (%d): %s:%s\",\n            self.num_connections,\n            self.host,\n            self.port or \"443\",\n        )\n\n        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:\n            raise SSLError(\n                \"Can't connect to HTTPS URL because the SSL module is not available.\"\n            )\n\n        actual_host = self.host\n        actual_port = self.port\n        if self.proxy is not None:\n            actual_host = self.proxy.host\n            actual_port = self.proxy.port\n\n        conn = self.ConnectionCls(\n            host=actual_host,\n            port=actual_port,\n            timeout=self.timeout.connect_timeout,\n            strict=self.strict,\n            cert_file=self.cert_file,\n            key_file=self.key_file,\n            key_password=self.key_password,\n            **self.conn_kw\n        )\n\n        return self._prepare_conn(conn)\n\n    def _validate_conn(self, conn):\n        \"\"\"\n        Called right before a request is made, after the socket is created.\n        \"\"\"\n        super(HTTPSConnectionPool, self)._validate_conn(conn)\n\n        # Force connect early to allow us to validate the connection.\n        if not getattr(conn, \"sock\", None):  # AppEngine might not have  `.sock`\n            conn.connect()\n\n        if not conn.is_verified:\n            warnings.warn(\n                (\n                    \"Unverified HTTPS request is being made to host '%s'. \"\n                    \"Adding certificate verification is strongly advised. See: \"\n                    \"https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html\"\n                    \"#ssl-warnings\" % conn.host\n                ),\n                InsecureRequestWarning,\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.PoolManager","title":"<code>PoolManager</code>","text":"<p>               Bases: <code>RequestMethods</code></p> <p>Allows for arbitrary requests while transparently keeping track of necessary connection pools for you.</p> <p>:param num_pools:     Number of connection pools to cache before discarding the least     recently used pool.</p> <p>:param headers:     Headers to include with all requests, unless other headers are given     explicitly.</p> <p>:param **connection_pool_kw:     Additional parameters are used to create fresh     :class:<code>urllib3.connectionpool.ConnectionPool</code> instances.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; manager = PoolManager(num_pools=2)\n&gt;&gt;&gt; r = manager.request('GET', 'http://google.com/')\n&gt;&gt;&gt; r = manager.request('GET', 'http://google.com/mail')\n&gt;&gt;&gt; r = manager.request('GET', 'http://yahoo.com/')\n&gt;&gt;&gt; len(manager.pools)\n2\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>class PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param \\\\**connection_pool_kw:\n        Additional parameters are used to create fresh\n        :class:`urllib3.connectionpool.ConnectionPool` instances.\n\n    Example::\n\n        &gt;&gt;&gt; manager = PoolManager(num_pools=2)\n        &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/')\n        &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/mail')\n        &gt;&gt;&gt; r = manager.request('GET', 'http://yahoo.com/')\n        &gt;&gt;&gt; len(manager.pools)\n        2\n\n    \"\"\"\n\n    proxy = None\n    proxy_config = None\n\n    def __init__(self, num_pools=10, headers=None, **connection_pool_kw):\n        RequestMethods.__init__(self, headers)\n        self.connection_pool_kw = connection_pool_kw\n        self.pools = RecentlyUsedContainer(num_pools, dispose_func=lambda p: p.close())\n\n        # Locally set the pool classes and keys so other PoolManagers can\n        # override them.\n        self.pool_classes_by_scheme = pool_classes_by_scheme\n        self.key_fn_by_scheme = key_fn_by_scheme.copy()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.clear()\n        # Return False to re-raise any potential exceptions\n        return False\n\n    def _new_pool(self, scheme, host, port, request_context=None):\n        \"\"\"\n        Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and\n        any additional pool keyword arguments.\n\n        If ``request_context`` is provided, it is provided as keyword arguments\n        to the pool class used. This method is used to actually create the\n        connection pools handed out by :meth:`connection_from_url` and\n        companion methods. It is intended to be overridden for customization.\n        \"\"\"\n        pool_cls = self.pool_classes_by_scheme[scheme]\n        if request_context is None:\n            request_context = self.connection_pool_kw.copy()\n\n        # Although the context has everything necessary to create the pool,\n        # this function has historically only used the scheme, host, and port\n        # in the positional args. When an API change is acceptable these can\n        # be removed.\n        for key in (\"scheme\", \"host\", \"port\"):\n            request_context.pop(key, None)\n\n        if scheme == \"http\":\n            for kw in SSL_KEYWORDS:\n                request_context.pop(kw, None)\n\n        return pool_cls(host, port, **request_context)\n\n    def clear(self):\n        \"\"\"\n        Empty our store of pools and direct them all to close.\n\n        This will not affect in-flight connections, but they will not be\n        re-used after completion.\n        \"\"\"\n        self.pools.clear()\n\n    def connection_from_host(self, host, port=None, scheme=\"http\", pool_kwargs=None):\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\n        If ``port`` isn't given, it will be derived from the ``scheme`` using\n        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is\n        provided, it is merged with the instance's ``connection_pool_kw``\n        variable and used to create the new connection pool, if one is\n        needed.\n        \"\"\"\n\n        if not host:\n            raise LocationValueError(\"No host specified.\")\n\n        request_context = self._merge_pool_kwargs(pool_kwargs)\n        request_context[\"scheme\"] = scheme or \"http\"\n        if not port:\n            port = port_by_scheme.get(request_context[\"scheme\"].lower(), 80)\n        request_context[\"port\"] = port\n        request_context[\"host\"] = host\n\n        return self.connection_from_context(request_context)\n\n    def connection_from_context(self, request_context):\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n        ``request_context`` must at least contain the ``scheme`` key and its\n        value must be a key in ``key_fn_by_scheme`` instance variable.\n        \"\"\"\n        scheme = request_context[\"scheme\"].lower()\n        pool_key_constructor = self.key_fn_by_scheme.get(scheme)\n        if not pool_key_constructor:\n            raise URLSchemeUnknown(scheme)\n        pool_key = pool_key_constructor(request_context)\n\n        return self.connection_from_pool_key(pool_key, request_context=request_context)\n\n    def connection_from_pool_key(self, pool_key, request_context=None):\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n        ``pool_key`` should be a namedtuple that only contains immutable\n        objects. At a minimum it must have the ``scheme``, ``host``, and\n        ``port`` fields.\n        \"\"\"\n        with self.pools.lock:\n            # If the scheme, host, or port doesn't match existing open\n            # connections, open a new ConnectionPool.\n            pool = self.pools.get(pool_key)\n            if pool:\n                return pool\n\n            # Make a fresh ConnectionPool of the desired type\n            scheme = request_context[\"scheme\"]\n            host = request_context[\"host\"]\n            port = request_context[\"port\"]\n            pool = self._new_pool(scheme, host, port, request_context=request_context)\n            self.pools[pool_key] = pool\n\n        return pool\n\n    def connection_from_url(self, url, pool_kwargs=None):\n        \"\"\"\n        Similar to :func:`urllib3.connectionpool.connection_from_url`.\n\n        If ``pool_kwargs`` is not provided and a new pool needs to be\n        constructed, ``self.connection_pool_kw`` is used to initialize\n        the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``\n        is provided, it is used instead. Note that if a new pool does not\n        need to be created for the request, the provided ``pool_kwargs`` are\n        not used.\n        \"\"\"\n        u = parse_url(url)\n        return self.connection_from_host(\n            u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs\n        )\n\n    def _merge_pool_kwargs(self, override):\n        \"\"\"\n        Merge a dictionary of override values for self.connection_pool_kw.\n\n        This does not modify self.connection_pool_kw and returns a new dict.\n        Any keys in the override dictionary with a value of ``None`` are\n        removed from the merged dictionary.\n        \"\"\"\n        base_pool_kwargs = self.connection_pool_kw.copy()\n        if override:\n            for key, value in override.items():\n                if value is None:\n                    try:\n                        del base_pool_kwargs[key]\n                    except KeyError:\n                        pass\n                else:\n                    base_pool_kwargs[key] = value\n        return base_pool_kwargs\n\n    def _proxy_requires_url_absolute_form(self, parsed_url):\n        \"\"\"\n        Indicates if the proxy requires the complete destination URL in the\n        request.  Normally this is only needed when not using an HTTP CONNECT\n        tunnel.\n        \"\"\"\n        if self.proxy is None:\n            return False\n\n        return not connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, parsed_url.scheme\n        )\n\n    def _validate_proxy_scheme_url_selection(self, url_scheme):\n        \"\"\"\n        Validates that were not attempting to do TLS in TLS connections on\n        Python2 or with unsupported SSL implementations.\n        \"\"\"\n        if self.proxy is None or url_scheme != \"https\":\n            return\n\n        if self.proxy.scheme != \"https\":\n            return\n\n        if six.PY2 and not self.proxy_config.use_forwarding_for_https:\n            raise ProxySchemeUnsupported(\n                \"Contacting HTTPS destinations through HTTPS proxies \"\n                \"'via CONNECT tunnels' is not supported in Python 2\"\n            )\n\n    def urlopen(self, method, url, redirect=True, **kw):\n        \"\"\"\n        Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\n        with custom cross-host redirect logic and only sends the request-uri\n        portion of the ``url``.\n\n        The given ``url`` parameter must be absolute, such that an appropriate\n        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n        \"\"\"\n        u = parse_url(url)\n        self._validate_proxy_scheme_url_selection(u.scheme)\n\n        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)\n\n        kw[\"assert_same_host\"] = False\n        kw[\"redirect\"] = False\n\n        if \"headers\" not in kw:\n            kw[\"headers\"] = self.headers.copy()\n\n        if self._proxy_requires_url_absolute_form(u):\n            response = conn.urlopen(method, url, **kw)\n        else:\n            response = conn.urlopen(method, u.request_uri, **kw)\n\n        redirect_location = redirect and response.get_redirect_location()\n        if not redirect_location:\n            return response\n\n        # Support relative URLs for redirecting.\n        redirect_location = urljoin(url, redirect_location)\n\n        # RFC 7231, Section 6.4.4\n        if response.status == 303:\n            method = \"GET\"\n\n        retries = kw.get(\"retries\")\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect)\n\n        # Strip headers marked as unsafe to forward to the redirected location.\n        # Check remove_headers_on_redirect to avoid a potential network call within\n        # conn.is_same_host() which may use socket.gethostbyname() in the future.\n        if retries.remove_headers_on_redirect and not conn.is_same_host(\n            redirect_location\n        ):\n            headers = list(six.iterkeys(kw[\"headers\"]))\n            for header in headers:\n                if header.lower() in retries.remove_headers_on_redirect:\n                    kw[\"headers\"].pop(header, None)\n\n        try:\n            retries = retries.increment(method, url, response=response, _pool=conn)\n        except MaxRetryError:\n            if retries.raise_on_redirect:\n                response.drain_conn()\n                raise\n            return response\n\n        kw[\"retries\"] = retries\n        kw[\"redirect\"] = redirect\n\n        log.info(\"Redirecting %s -&gt; %s\", url, redirect_location)\n\n        response.drain_conn()\n        return self.urlopen(method, redirect_location, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.PoolManager.clear","title":"<code>clear()</code>","text":"<p>Empty our store of pools and direct them all to close.</p> <p>This will not affect in-flight connections, but they will not be re-used after completion.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Empty our store of pools and direct them all to close.\n\n    This will not affect in-flight connections, but they will not be\n    re-used after completion.\n    \"\"\"\n    self.pools.clear()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.PoolManager.connection_from_context","title":"<code>connection_from_context(request_context)</code>","text":"<p>Get a :class:<code>urllib3.connectionpool.ConnectionPool</code> based on the request context.</p> <p><code>request_context</code> must at least contain the <code>scheme</code> key and its value must be a key in <code>key_fn_by_scheme</code> instance variable.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def connection_from_context(self, request_context):\n    \"\"\"\n    Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n    ``request_context`` must at least contain the ``scheme`` key and its\n    value must be a key in ``key_fn_by_scheme`` instance variable.\n    \"\"\"\n    scheme = request_context[\"scheme\"].lower()\n    pool_key_constructor = self.key_fn_by_scheme.get(scheme)\n    if not pool_key_constructor:\n        raise URLSchemeUnknown(scheme)\n    pool_key = pool_key_constructor(request_context)\n\n    return self.connection_from_pool_key(pool_key, request_context=request_context)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.PoolManager.connection_from_host","title":"<code>connection_from_host(host, port=None, scheme='http', pool_kwargs=None)</code>","text":"<p>Get a :class:<code>urllib3.connectionpool.ConnectionPool</code> based on the host, port, and scheme.</p> <p>If <code>port</code> isn't given, it will be derived from the <code>scheme</code> using <code>urllib3.connectionpool.port_by_scheme</code>. If <code>pool_kwargs</code> is provided, it is merged with the instance's <code>connection_pool_kw</code> variable and used to create the new connection pool, if one is needed.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def connection_from_host(self, host, port=None, scheme=\"http\", pool_kwargs=None):\n    \"\"\"\n    Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\n    If ``port`` isn't given, it will be derived from the ``scheme`` using\n    ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is\n    provided, it is merged with the instance's ``connection_pool_kw``\n    variable and used to create the new connection pool, if one is\n    needed.\n    \"\"\"\n\n    if not host:\n        raise LocationValueError(\"No host specified.\")\n\n    request_context = self._merge_pool_kwargs(pool_kwargs)\n    request_context[\"scheme\"] = scheme or \"http\"\n    if not port:\n        port = port_by_scheme.get(request_context[\"scheme\"].lower(), 80)\n    request_context[\"port\"] = port\n    request_context[\"host\"] = host\n\n    return self.connection_from_context(request_context)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.PoolManager.connection_from_pool_key","title":"<code>connection_from_pool_key(pool_key, request_context=None)</code>","text":"<p>Get a :class:<code>urllib3.connectionpool.ConnectionPool</code> based on the provided pool key.</p> <p><code>pool_key</code> should be a namedtuple that only contains immutable objects. At a minimum it must have the <code>scheme</code>, <code>host</code>, and <code>port</code> fields.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def connection_from_pool_key(self, pool_key, request_context=None):\n    \"\"\"\n    Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n    ``pool_key`` should be a namedtuple that only contains immutable\n    objects. At a minimum it must have the ``scheme``, ``host``, and\n    ``port`` fields.\n    \"\"\"\n    with self.pools.lock:\n        # If the scheme, host, or port doesn't match existing open\n        # connections, open a new ConnectionPool.\n        pool = self.pools.get(pool_key)\n        if pool:\n            return pool\n\n        # Make a fresh ConnectionPool of the desired type\n        scheme = request_context[\"scheme\"]\n        host = request_context[\"host\"]\n        port = request_context[\"port\"]\n        pool = self._new_pool(scheme, host, port, request_context=request_context)\n        self.pools[pool_key] = pool\n\n    return pool\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.PoolManager.connection_from_url","title":"<code>connection_from_url(url, pool_kwargs=None)</code>","text":"<p>Similar to :func:<code>urllib3.connectionpool.connection_from_url</code>.</p> <p>If <code>pool_kwargs</code> is not provided and a new pool needs to be constructed, <code>self.connection_pool_kw</code> is used to initialize the :class:<code>urllib3.connectionpool.ConnectionPool</code>. If <code>pool_kwargs</code> is provided, it is used instead. Note that if a new pool does not need to be created for the request, the provided <code>pool_kwargs</code> are not used.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def connection_from_url(self, url, pool_kwargs=None):\n    \"\"\"\n    Similar to :func:`urllib3.connectionpool.connection_from_url`.\n\n    If ``pool_kwargs`` is not provided and a new pool needs to be\n    constructed, ``self.connection_pool_kw`` is used to initialize\n    the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``\n    is provided, it is used instead. Note that if a new pool does not\n    need to be created for the request, the provided ``pool_kwargs`` are\n    not used.\n    \"\"\"\n    u = parse_url(url)\n    return self.connection_from_host(\n        u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.PoolManager.urlopen","title":"<code>urlopen(method, url, redirect=True, **kw)</code>","text":"<p>Same as :meth:<code>urllib3.HTTPConnectionPool.urlopen</code> with custom cross-host redirect logic and only sends the request-uri portion of the <code>url</code>.</p> <p>The given <code>url</code> parameter must be absolute, such that an appropriate :class:<code>urllib3.connectionpool.ConnectionPool</code> can be chosen for it.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def urlopen(self, method, url, redirect=True, **kw):\n    \"\"\"\n    Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\n    with custom cross-host redirect logic and only sends the request-uri\n    portion of the ``url``.\n\n    The given ``url`` parameter must be absolute, such that an appropriate\n    :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n    \"\"\"\n    u = parse_url(url)\n    self._validate_proxy_scheme_url_selection(u.scheme)\n\n    conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)\n\n    kw[\"assert_same_host\"] = False\n    kw[\"redirect\"] = False\n\n    if \"headers\" not in kw:\n        kw[\"headers\"] = self.headers.copy()\n\n    if self._proxy_requires_url_absolute_form(u):\n        response = conn.urlopen(method, url, **kw)\n    else:\n        response = conn.urlopen(method, u.request_uri, **kw)\n\n    redirect_location = redirect and response.get_redirect_location()\n    if not redirect_location:\n        return response\n\n    # Support relative URLs for redirecting.\n    redirect_location = urljoin(url, redirect_location)\n\n    # RFC 7231, Section 6.4.4\n    if response.status == 303:\n        method = \"GET\"\n\n    retries = kw.get(\"retries\")\n    if not isinstance(retries, Retry):\n        retries = Retry.from_int(retries, redirect=redirect)\n\n    # Strip headers marked as unsafe to forward to the redirected location.\n    # Check remove_headers_on_redirect to avoid a potential network call within\n    # conn.is_same_host() which may use socket.gethostbyname() in the future.\n    if retries.remove_headers_on_redirect and not conn.is_same_host(\n        redirect_location\n    ):\n        headers = list(six.iterkeys(kw[\"headers\"]))\n        for header in headers:\n            if header.lower() in retries.remove_headers_on_redirect:\n                kw[\"headers\"].pop(header, None)\n\n    try:\n        retries = retries.increment(method, url, response=response, _pool=conn)\n    except MaxRetryError:\n        if retries.raise_on_redirect:\n            response.drain_conn()\n            raise\n        return response\n\n    kw[\"retries\"] = retries\n    kw[\"redirect\"] = redirect\n\n    log.info(\"Redirecting %s -&gt; %s\", url, redirect_location)\n\n    response.drain_conn()\n    return self.urlopen(method, redirect_location, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.ProxyManager","title":"<code>ProxyManager</code>","text":"<p>               Bases: <code>PoolManager</code></p> <p>Behaves just like :class:<code>PoolManager</code>, but sends all requests through the defined proxy, using the CONNECT method for HTTPS URLs.</p> <p>:param proxy_url:     The URL of the proxy to be used.</p> <p>:param proxy_headers:     A dictionary containing headers that will be sent to the proxy. In case     of HTTP they are being sent with each request, while in the     HTTPS/CONNECT case they are sent only once. Could be used for proxy     authentication.</p> <p>:param proxy_ssl_context:     The proxy SSL context is used to establish the TLS connection to the     proxy when using HTTPS proxies.</p> <p>:param use_forwarding_for_https:     (Defaults to False) If set to True will forward requests to the HTTPS     proxy to be made on behalf of the client instead of creating a TLS     tunnel via the CONNECT method. Enabling this flag means that request     and response headers and content will be visible from the HTTPS proxy     whereas tunneling keeps request and response headers and content     private.  IP address, target hostname, SNI, and port are always visible     to an HTTPS proxy even when this flag is disabled.</p> Example <p>proxy = urllib3.ProxyManager('http://localhost:3128/') r1 = proxy.request('GET', 'http://google.com/') r2 = proxy.request('GET', 'http://httpbin.org/') len(proxy.pools) 1 r3 = proxy.request('GET', 'https://httpbin.org/') r4 = proxy.request('GET', 'https://twitter.com/') len(proxy.pools) 3</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>class ProxyManager(PoolManager):\n    \"\"\"\n    Behaves just like :class:`PoolManager`, but sends all requests through\n    the defined proxy, using the CONNECT method for HTTPS URLs.\n\n    :param proxy_url:\n        The URL of the proxy to be used.\n\n    :param proxy_headers:\n        A dictionary containing headers that will be sent to the proxy. In case\n        of HTTP they are being sent with each request, while in the\n        HTTPS/CONNECT case they are sent only once. Could be used for proxy\n        authentication.\n\n    :param proxy_ssl_context:\n        The proxy SSL context is used to establish the TLS connection to the\n        proxy when using HTTPS proxies.\n\n    :param use_forwarding_for_https:\n        (Defaults to False) If set to True will forward requests to the HTTPS\n        proxy to be made on behalf of the client instead of creating a TLS\n        tunnel via the CONNECT method. **Enabling this flag means that request\n        and response headers and content will be visible from the HTTPS proxy**\n        whereas tunneling keeps request and response headers and content\n        private.  IP address, target hostname, SNI, and port are always visible\n        to an HTTPS proxy even when this flag is disabled.\n\n    Example:\n        &gt;&gt;&gt; proxy = urllib3.ProxyManager('http://localhost:3128/')\n        &gt;&gt;&gt; r1 = proxy.request('GET', 'http://google.com/')\n        &gt;&gt;&gt; r2 = proxy.request('GET', 'http://httpbin.org/')\n        &gt;&gt;&gt; len(proxy.pools)\n        1\n        &gt;&gt;&gt; r3 = proxy.request('GET', 'https://httpbin.org/')\n        &gt;&gt;&gt; r4 = proxy.request('GET', 'https://twitter.com/')\n        &gt;&gt;&gt; len(proxy.pools)\n        3\n\n    \"\"\"\n\n    def __init__(\n        self,\n        proxy_url,\n        num_pools=10,\n        headers=None,\n        proxy_headers=None,\n        proxy_ssl_context=None,\n        use_forwarding_for_https=False,\n        **connection_pool_kw\n    ):\n\n        if isinstance(proxy_url, HTTPConnectionPool):\n            proxy_url = \"%s://%s:%i\" % (\n                proxy_url.scheme,\n                proxy_url.host,\n                proxy_url.port,\n            )\n        proxy = parse_url(proxy_url)\n\n        if proxy.scheme not in (\"http\", \"https\"):\n            raise ProxySchemeUnknown(proxy.scheme)\n\n        if not proxy.port:\n            port = port_by_scheme.get(proxy.scheme, 80)\n            proxy = proxy._replace(port=port)\n\n        self.proxy = proxy\n        self.proxy_headers = proxy_headers or {}\n        self.proxy_ssl_context = proxy_ssl_context\n        self.proxy_config = ProxyConfig(proxy_ssl_context, use_forwarding_for_https)\n\n        connection_pool_kw[\"_proxy\"] = self.proxy\n        connection_pool_kw[\"_proxy_headers\"] = self.proxy_headers\n        connection_pool_kw[\"_proxy_config\"] = self.proxy_config\n\n        super(ProxyManager, self).__init__(num_pools, headers, **connection_pool_kw)\n\n    def connection_from_host(self, host, port=None, scheme=\"http\", pool_kwargs=None):\n        if scheme == \"https\":\n            return super(ProxyManager, self).connection_from_host(\n                host, port, scheme, pool_kwargs=pool_kwargs\n            )\n\n        return super(ProxyManager, self).connection_from_host(\n            self.proxy.host, self.proxy.port, self.proxy.scheme, pool_kwargs=pool_kwargs\n        )\n\n    def _set_proxy_headers(self, url, headers=None):\n        \"\"\"\n        Sets headers needed by proxies: specifically, the Accept and Host\n        headers. Only sets headers not provided by the user.\n        \"\"\"\n        headers_ = {\"Accept\": \"*/*\"}\n\n        netloc = parse_url(url).netloc\n        if netloc:\n            headers_[\"Host\"] = netloc\n\n        if headers:\n            headers_.update(headers)\n        return headers_\n\n    def urlopen(self, method, url, redirect=True, **kw):\n        \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n        u = parse_url(url)\n        if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):\n            # For connections using HTTP CONNECT, httplib sets the necessary\n            # headers on the CONNECT to the proxy. If we're not using CONNECT,\n            # we'll definitely need to set 'Host' at the very least.\n            headers = kw.get(\"headers\", self.headers)\n            kw[\"headers\"] = self._set_proxy_headers(url, headers)\n\n        return super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.ProxyManager.urlopen","title":"<code>urlopen(method, url, redirect=True, **kw)</code>","text":"<p>Same as HTTP(S)ConnectionPool.urlopen, <code>url</code> must be absolute.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def urlopen(self, method, url, redirect=True, **kw):\n    \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n    u = parse_url(url)\n    if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):\n        # For connections using HTTP CONNECT, httplib sets the necessary\n        # headers on the CONNECT to the proxy. If we're not using CONNECT,\n        # we'll definitely need to set 'Host' at the very least.\n        headers = kw.get(\"headers\", self.headers)\n        kw[\"headers\"] = self._set_proxy_headers(url, headers)\n\n    return super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Retry","title":"<code>Retry</code>","text":"<p>               Bases: <code>object</code></p> <p>Retry configuration.</p> <p>Each retry attempt will create a new Retry object with updated values, so they can be safely reused.</p> <p>Retries can be defined as a default for a pool::</p> <pre><code>retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n</code></pre> <p>Or per-request (which overrides the default for the pool)::</p> <pre><code>response = http.request('GET', 'http://example.com/', retries=Retry(10))\n</code></pre> <p>Retries can be disabled by passing <code>False</code>::</p> <pre><code>response = http.request('GET', 'http://example.com/', retries=False)\n</code></pre> <p>Errors will be wrapped in :class:<code>~urllib3.exceptions.MaxRetryError</code> unless retries are disabled, in which case the causing exception will be raised.</p> <p>:param int total:     Total number of retries to allow. Takes precedence over other counts.</p> <pre><code>Set to ``None`` to remove this constraint and fall back on other\ncounts.\n\nSet to ``0`` to fail on the first retry.\n\nSet to ``False`` to disable and imply ``raise_on_redirect=False``.\n</code></pre> <p>:param int connect:     How many connection-related errors to retry on.</p> <pre><code>These are errors raised before the request is sent to the remote server,\nwhich we assume has not triggered the server to process the request.\n\nSet to ``0`` to fail on the first retry of this type.\n</code></pre> <p>:param int read:     How many times to retry on read errors.</p> <pre><code>These errors are raised after the request was sent to the server, so the\nrequest may have side-effects.\n\nSet to ``0`` to fail on the first retry of this type.\n</code></pre> <p>:param int redirect:     How many redirects to perform. Limit this to avoid infinite redirect     loops.</p> <pre><code>A redirect is a HTTP response with a status code 301, 302, 303, 307 or\n308.\n\nSet to ``0`` to fail on the first retry of this type.\n\nSet to ``False`` to disable and imply ``raise_on_redirect=False``.\n</code></pre> <p>:param int status:     How many times to retry on bad status codes.</p> <pre><code>These are retries made on responses, where status code matches\n``status_forcelist``.\n\nSet to ``0`` to fail on the first retry of this type.\n</code></pre> <p>:param int other:     How many times to retry on other errors.</p> <pre><code>Other errors are errors that are not connect, read, redirect or status errors.\nThese errors might be raised after the request was sent to the server, so the\nrequest might have side-effects.\n\nSet to ``0`` to fail on the first retry of this type.\n\nIf ``total`` is not set, it's a good idea to set this to 0 to account\nfor unexpected edge cases and avoid infinite retry loops.\n</code></pre> <p>:param iterable allowed_methods:     Set of uppercased HTTP method verbs that we should retry on.</p> <pre><code>By default, we only retry on methods which are considered to be\nidempotent (multiple requests with the same parameters end with the\nsame state). See :attr:`Retry.DEFAULT_ALLOWED_METHODS`.\n\nSet to a ``False`` value to retry on any verb.\n\n.. warning::\n\n    Previously this parameter was named ``method_whitelist``, that\n    usage is deprecated in v1.26.0 and will be removed in v2.0.\n</code></pre> <p>:param iterable status_forcelist:     A set of integer HTTP status codes that we should force a retry on.     A retry is initiated if the request method is in <code>allowed_methods</code>     and the response status code is in <code>status_forcelist</code>.</p> <pre><code>By default, this is disabled with ``None``.\n</code></pre> <p>:param float backoff_factor:     A backoff factor to apply between attempts after the second try     (most errors are resolved immediately by a second try without a     delay). urllib3 will sleep for::</p> <pre><code>    {backoff factor} * (2 ** ({number of total retries} - 1))\n\nseconds. If the backoff_factor is 0.1, then :func:`.sleep` will sleep\nfor [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer\nthan :attr:`Retry.BACKOFF_MAX`.\n\nBy default, backoff is disabled (set to 0).\n</code></pre> <p>:param bool raise_on_redirect: Whether, if the number of redirects is     exhausted, to raise a MaxRetryError, or to return a response with a     response code in the 3xx range.</p> <p>:param bool raise_on_status: Similar meaning to <code>raise_on_redirect</code>:     whether we should raise an exception, or return a response,     if status falls in <code>status_forcelist</code> range and retries have     been exhausted.</p> <p>:param tuple history: The history of the request encountered during     each call to :meth:<code>~Retry.increment</code>. The list is in the order     the requests occurred. Each list item is of class :class:<code>RequestHistory</code>.</p> <p>:param bool respect_retry_after_header:     Whether to respect Retry-After header on status codes defined as     :attr:<code>Retry.RETRY_AFTER_STATUS_CODES</code> or not.</p> <p>:param iterable remove_headers_on_redirect:     Sequence of headers to remove from the request when a response     indicating a redirect is returned before firing off the redirected     request.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>@six.add_metaclass(_RetryMeta)\nclass Retry(object):\n    \"\"\"Retry configuration.\n\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.\n\n    Retries can be defined as a default for a pool::\n\n        retries = Retry(connect=5, read=2, redirect=5)\n        http = PoolManager(retries=retries)\n        response = http.request('GET', 'http://example.com/')\n\n    Or per-request (which overrides the default for the pool)::\n\n        response = http.request('GET', 'http://example.com/', retries=Retry(10))\n\n    Retries can be disabled by passing ``False``::\n\n        response = http.request('GET', 'http://example.com/', retries=False)\n\n    Errors will be wrapped in :class:`~urllib3.exceptions.MaxRetryError` unless\n    retries are disabled, in which case the causing exception will be raised.\n\n    :param int total:\n        Total number of retries to allow. Takes precedence over other counts.\n\n        Set to ``None`` to remove this constraint and fall back on other\n        counts.\n\n        Set to ``0`` to fail on the first retry.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int connect:\n        How many connection-related errors to retry on.\n\n        These are errors raised before the request is sent to the remote server,\n        which we assume has not triggered the server to process the request.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int read:\n        How many times to retry on read errors.\n\n        These errors are raised after the request was sent to the server, so the\n        request may have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int redirect:\n        How many redirects to perform. Limit this to avoid infinite redirect\n        loops.\n\n        A redirect is a HTTP response with a status code 301, 302, 303, 307 or\n        308.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int status:\n        How many times to retry on bad status codes.\n\n        These are retries made on responses, where status code matches\n        ``status_forcelist``.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int other:\n        How many times to retry on other errors.\n\n        Other errors are errors that are not connect, read, redirect or status errors.\n        These errors might be raised after the request was sent to the server, so the\n        request might have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        If ``total`` is not set, it's a good idea to set this to 0 to account\n        for unexpected edge cases and avoid infinite retry loops.\n\n    :param iterable allowed_methods:\n        Set of uppercased HTTP method verbs that we should retry on.\n\n        By default, we only retry on methods which are considered to be\n        idempotent (multiple requests with the same parameters end with the\n        same state). See :attr:`Retry.DEFAULT_ALLOWED_METHODS`.\n\n        Set to a ``False`` value to retry on any verb.\n\n        .. warning::\n\n            Previously this parameter was named ``method_whitelist``, that\n            usage is deprecated in v1.26.0 and will be removed in v2.0.\n\n    :param iterable status_forcelist:\n        A set of integer HTTP status codes that we should force a retry on.\n        A retry is initiated if the request method is in ``allowed_methods``\n        and the response status code is in ``status_forcelist``.\n\n        By default, this is disabled with ``None``.\n\n    :param float backoff_factor:\n        A backoff factor to apply between attempts after the second try\n        (most errors are resolved immediately by a second try without a\n        delay). urllib3 will sleep for::\n\n            {backoff factor} * (2 ** ({number of total retries} - 1))\n\n        seconds. If the backoff_factor is 0.1, then :func:`.sleep` will sleep\n        for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer\n        than :attr:`Retry.BACKOFF_MAX`.\n\n        By default, backoff is disabled (set to 0).\n\n    :param bool raise_on_redirect: Whether, if the number of redirects is\n        exhausted, to raise a MaxRetryError, or to return a response with a\n        response code in the 3xx range.\n\n    :param bool raise_on_status: Similar meaning to ``raise_on_redirect``:\n        whether we should raise an exception, or return a response,\n        if status falls in ``status_forcelist`` range and retries have\n        been exhausted.\n\n    :param tuple history: The history of the request encountered during\n        each call to :meth:`~Retry.increment`. The list is in the order\n        the requests occurred. Each list item is of class :class:`RequestHistory`.\n\n    :param bool respect_retry_after_header:\n        Whether to respect Retry-After header on status codes defined as\n        :attr:`Retry.RETRY_AFTER_STATUS_CODES` or not.\n\n    :param iterable remove_headers_on_redirect:\n        Sequence of headers to remove from the request when a response\n        indicating a redirect is returned before firing off the redirected\n        request.\n    \"\"\"\n\n    #: Default methods to be used for ``allowed_methods``\n    DEFAULT_ALLOWED_METHODS = frozenset(\n        [\"HEAD\", \"GET\", \"PUT\", \"DELETE\", \"OPTIONS\", \"TRACE\"]\n    )\n\n    #: Default status codes to be used for ``status_forcelist``\n    RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])\n\n    #: Default headers to be used for ``remove_headers_on_redirect``\n    DEFAULT_REMOVE_HEADERS_ON_REDIRECT = frozenset([\"Authorization\"])\n\n    #: Maximum backoff time.\n    BACKOFF_MAX = 120\n\n    def __init__(\n        self,\n        total=10,\n        connect=None,\n        read=None,\n        redirect=None,\n        status=None,\n        other=None,\n        allowed_methods=_Default,\n        status_forcelist=None,\n        backoff_factor=0,\n        raise_on_redirect=True,\n        raise_on_status=True,\n        history=None,\n        respect_retry_after_header=True,\n        remove_headers_on_redirect=_Default,\n        # TODO: Deprecated, remove in v2.0\n        method_whitelist=_Default,\n    ):\n\n        if method_whitelist is not _Default:\n            if allowed_methods is not _Default:\n                raise ValueError(\n                    \"Using both 'allowed_methods' and \"\n                    \"'method_whitelist' together is not allowed. \"\n                    \"Instead only use 'allowed_methods'\"\n                )\n            warnings.warn(\n                \"Using 'method_whitelist' with Retry is deprecated and \"\n                \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            allowed_methods = method_whitelist\n        if allowed_methods is _Default:\n            allowed_methods = self.DEFAULT_ALLOWED_METHODS\n        if remove_headers_on_redirect is _Default:\n            remove_headers_on_redirect = self.DEFAULT_REMOVE_HEADERS_ON_REDIRECT\n\n        self.total = total\n        self.connect = connect\n        self.read = read\n        self.status = status\n        self.other = other\n\n        if redirect is False or total is False:\n            redirect = 0\n            raise_on_redirect = False\n\n        self.redirect = redirect\n        self.status_forcelist = status_forcelist or set()\n        self.allowed_methods = allowed_methods\n        self.backoff_factor = backoff_factor\n        self.raise_on_redirect = raise_on_redirect\n        self.raise_on_status = raise_on_status\n        self.history = history or tuple()\n        self.respect_retry_after_header = respect_retry_after_header\n        self.remove_headers_on_redirect = frozenset(\n            [h.lower() for h in remove_headers_on_redirect]\n        )\n\n    def new(self, **kw):\n        params = dict(\n            total=self.total,\n            connect=self.connect,\n            read=self.read,\n            redirect=self.redirect,\n            status=self.status,\n            other=self.other,\n            status_forcelist=self.status_forcelist,\n            backoff_factor=self.backoff_factor,\n            raise_on_redirect=self.raise_on_redirect,\n            raise_on_status=self.raise_on_status,\n            history=self.history,\n            remove_headers_on_redirect=self.remove_headers_on_redirect,\n            respect_retry_after_header=self.respect_retry_after_header,\n        )\n\n        # TODO: If already given in **kw we use what's given to us\n        # If not given we need to figure out what to pass. We decide\n        # based on whether our class has the 'method_whitelist' property\n        # and if so we pass the deprecated 'method_whitelist' otherwise\n        # we use 'allowed_methods'. Remove in v2.0\n        if \"method_whitelist\" not in kw and \"allowed_methods\" not in kw:\n            if \"method_whitelist\" in self.__dict__:\n                warnings.warn(\n                    \"Using 'method_whitelist' with Retry is deprecated and \"\n                    \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                    DeprecationWarning,\n                )\n                params[\"method_whitelist\"] = self.allowed_methods\n            else:\n                params[\"allowed_methods\"] = self.allowed_methods\n\n        params.update(kw)\n        return type(self)(**params)\n\n    @classmethod\n    def from_int(cls, retries, redirect=True, default=None):\n        \"\"\"Backwards-compatibility for the old retries format.\"\"\"\n        if retries is None:\n            retries = default if default is not None else cls.DEFAULT\n\n        if isinstance(retries, Retry):\n            return retries\n\n        redirect = bool(redirect) and None\n        new_retries = cls(retries, redirect=redirect)\n        log.debug(\"Converted retries value: %r -&gt; %r\", retries, new_retries)\n        return new_retries\n\n    def get_backoff_time(self):\n        \"\"\"Formula for computing the current backoff\n\n        :rtype: float\n        \"\"\"\n        # We want to consider only the last consecutive errors sequence (Ignore redirects).\n        consecutive_errors_len = len(\n            list(\n                takewhile(lambda x: x.redirect_location is None, reversed(self.history))\n            )\n        )\n        if consecutive_errors_len &lt;= 1:\n            return 0\n\n        backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))\n        return min(self.BACKOFF_MAX, backoff_value)\n\n    def parse_retry_after(self, retry_after):\n        # Whitespace: https://tools.ietf.org/html/rfc7230#section-3.2.4\n        if re.match(r\"^\\s*[0-9]+\\s*$\", retry_after):\n            seconds = int(retry_after)\n        else:\n            retry_date_tuple = email.utils.parsedate_tz(retry_after)\n            if retry_date_tuple is None:\n                raise InvalidHeader(\"Invalid Retry-After header: %s\" % retry_after)\n            if retry_date_tuple[9] is None:  # Python 2\n                # Assume UTC if no timezone was specified\n                # On Python2.7, parsedate_tz returns None for a timezone offset\n                # instead of 0 if no timezone is given, where mktime_tz treats\n                # a None timezone offset as local time.\n                retry_date_tuple = retry_date_tuple[:9] + (0,) + retry_date_tuple[10:]\n\n            retry_date = email.utils.mktime_tz(retry_date_tuple)\n            seconds = retry_date - time.time()\n\n        if seconds &lt; 0:\n            seconds = 0\n\n        return seconds\n\n    def get_retry_after(self, response):\n        \"\"\"Get the value of Retry-After in seconds.\"\"\"\n\n        retry_after = response.getheader(\"Retry-After\")\n\n        if retry_after is None:\n            return None\n\n        return self.parse_retry_after(retry_after)\n\n    def sleep_for_retry(self, response=None):\n        retry_after = self.get_retry_after(response)\n        if retry_after:\n            time.sleep(retry_after)\n            return True\n\n        return False\n\n    def _sleep_backoff(self):\n        backoff = self.get_backoff_time()\n        if backoff &lt;= 0:\n            return\n        time.sleep(backoff)\n\n    def sleep(self, response=None):\n        \"\"\"Sleep between retry attempts.\n\n        This method will respect a server's ``Retry-After`` response header\n        and sleep the duration of the time requested. If that is not present, it\n        will use an exponential backoff. By default, the backoff factor is 0 and\n        this method will return immediately.\n        \"\"\"\n\n        if self.respect_retry_after_header and response:\n            slept = self.sleep_for_retry(response)\n            if slept:\n                return\n\n        self._sleep_backoff()\n\n    def _is_connection_error(self, err):\n        \"\"\"Errors when we're fairly sure that the server did not receive the\n        request, so it should be safe to retry.\n        \"\"\"\n        if isinstance(err, ProxyError):\n            err = err.original_error\n        return isinstance(err, ConnectTimeoutError)\n\n    def _is_read_error(self, err):\n        \"\"\"Errors that occur after the request has been started, so we should\n        assume that the server began processing it.\n        \"\"\"\n        return isinstance(err, (ReadTimeoutError, ProtocolError))\n\n    def _is_method_retryable(self, method):\n        \"\"\"Checks if a given HTTP method should be retried upon, depending if\n        it is included in the allowed_methods\n        \"\"\"\n        # TODO: For now favor if the Retry implementation sets its own method_whitelist\n        # property outside of our constructor to avoid breaking custom implementations.\n        if \"method_whitelist\" in self.__dict__:\n            warnings.warn(\n                \"Using 'method_whitelist' with Retry is deprecated and \"\n                \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                DeprecationWarning,\n            )\n            allowed_methods = self.method_whitelist\n        else:\n            allowed_methods = self.allowed_methods\n\n        if allowed_methods and method.upper() not in allowed_methods:\n            return False\n        return True\n\n    def is_retry(self, method, status_code, has_retry_after=False):\n        \"\"\"Is this method/status code retryable? (Based on allowlists and control\n        variables such as the number of total retries to allow, whether to\n        respect the Retry-After header, whether this header is present, and\n        whether the returned status code is on the list of status codes to\n        be retried upon on the presence of the aforementioned header)\n        \"\"\"\n        if not self._is_method_retryable(method):\n            return False\n\n        if self.status_forcelist and status_code in self.status_forcelist:\n            return True\n\n        return (\n            self.total\n            and self.respect_retry_after_header\n            and has_retry_after\n            and (status_code in self.RETRY_AFTER_STATUS_CODES)\n        )\n\n    def is_exhausted(self):\n        \"\"\"Are we out of retries?\"\"\"\n        retry_counts = (\n            self.total,\n            self.connect,\n            self.read,\n            self.redirect,\n            self.status,\n            self.other,\n        )\n        retry_counts = list(filter(None, retry_counts))\n        if not retry_counts:\n            return False\n\n        return min(retry_counts) &lt; 0\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n\n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n\n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n\n        total = self.total\n        if total is not None:\n            total -= 1\n\n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n\n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n\n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n\n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n\n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n\n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n\n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n\n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n\n        if new_retry.is_exhausted():\n            raise MaxRetryError(_pool, url, error or ResponseError(cause))\n\n        log.debug(\"Incremented Retry for (url='%s'): %r\", url, new_retry)\n\n        return new_retry\n\n    def __repr__(self):\n        return (\n            \"{cls.__name__}(total={self.total}, connect={self.connect}, \"\n            \"read={self.read}, redirect={self.redirect}, status={self.status})\"\n        ).format(cls=type(self), self=self)\n\n    def __getattr__(self, item):\n        if item == \"method_whitelist\":\n            # TODO: Remove this deprecated alias in v2.0\n            warnings.warn(\n                \"Using 'method_whitelist' with Retry is deprecated and \"\n                \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                DeprecationWarning,\n            )\n            return self.allowed_methods\n        try:\n            return getattr(super(Retry, self), item)\n        except AttributeError:\n            return getattr(Retry, item)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Retry.from_int","title":"<code>from_int(retries, redirect=True, default=None)</code>  <code>classmethod</code>","text":"<p>Backwards-compatibility for the old retries format.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>@classmethod\ndef from_int(cls, retries, redirect=True, default=None):\n    \"\"\"Backwards-compatibility for the old retries format.\"\"\"\n    if retries is None:\n        retries = default if default is not None else cls.DEFAULT\n\n    if isinstance(retries, Retry):\n        return retries\n\n    redirect = bool(redirect) and None\n    new_retries = cls(retries, redirect=redirect)\n    log.debug(\"Converted retries value: %r -&gt; %r\", retries, new_retries)\n    return new_retries\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Retry.get_backoff_time","title":"<code>get_backoff_time()</code>","text":"<p>Formula for computing the current backoff</p> <p>:rtype: float</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def get_backoff_time(self):\n    \"\"\"Formula for computing the current backoff\n\n    :rtype: float\n    \"\"\"\n    # We want to consider only the last consecutive errors sequence (Ignore redirects).\n    consecutive_errors_len = len(\n        list(\n            takewhile(lambda x: x.redirect_location is None, reversed(self.history))\n        )\n    )\n    if consecutive_errors_len &lt;= 1:\n        return 0\n\n    backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))\n    return min(self.BACKOFF_MAX, backoff_value)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Retry.get_retry_after","title":"<code>get_retry_after(response)</code>","text":"<p>Get the value of Retry-After in seconds.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def get_retry_after(self, response):\n    \"\"\"Get the value of Retry-After in seconds.\"\"\"\n\n    retry_after = response.getheader(\"Retry-After\")\n\n    if retry_after is None:\n        return None\n\n    return self.parse_retry_after(retry_after)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Retry.increment","title":"<code>increment(method=None, url=None, response=None, error=None, _pool=None, _stacktrace=None)</code>","text":"<p>Return a new Retry object with incremented retry counters.</p> <p>:param response: A response object, or None, if the server did not     return a response. :type response: :class:<code>~urllib3.response.HTTPResponse</code> :param Exception error: An error encountered during the request, or     None if the response was received successfully.</p> <p>:return: A new <code>Retry</code> object.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def increment(\n    self,\n    method=None,\n    url=None,\n    response=None,\n    error=None,\n    _pool=None,\n    _stacktrace=None,\n):\n    \"\"\"Return a new Retry object with incremented retry counters.\n\n    :param response: A response object, or None, if the server did not\n        return a response.\n    :type response: :class:`~urllib3.response.HTTPResponse`\n    :param Exception error: An error encountered during the request, or\n        None if the response was received successfully.\n\n    :return: A new ``Retry`` object.\n    \"\"\"\n    if self.total is False and error:\n        # Disabled, indicate to re-raise the error.\n        raise six.reraise(type(error), error, _stacktrace)\n\n    total = self.total\n    if total is not None:\n        total -= 1\n\n    connect = self.connect\n    read = self.read\n    redirect = self.redirect\n    status_count = self.status\n    other = self.other\n    cause = \"unknown\"\n    status = None\n    redirect_location = None\n\n    if error and self._is_connection_error(error):\n        # Connect retry?\n        if connect is False:\n            raise six.reraise(type(error), error, _stacktrace)\n        elif connect is not None:\n            connect -= 1\n\n    elif error and self._is_read_error(error):\n        # Read retry?\n        if read is False or not self._is_method_retryable(method):\n            raise six.reraise(type(error), error, _stacktrace)\n        elif read is not None:\n            read -= 1\n\n    elif error:\n        # Other retry?\n        if other is not None:\n            other -= 1\n\n    elif response and response.get_redirect_location():\n        # Redirect retry?\n        if redirect is not None:\n            redirect -= 1\n        cause = \"too many redirects\"\n        redirect_location = response.get_redirect_location()\n        status = response.status\n\n    else:\n        # Incrementing because of a server error like a 500 in\n        # status_forcelist and the given method is in the allowed_methods\n        cause = ResponseError.GENERIC_ERROR\n        if response and response.status:\n            if status_count is not None:\n                status_count -= 1\n            cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n            status = response.status\n\n    history = self.history + (\n        RequestHistory(method, url, error, status, redirect_location),\n    )\n\n    new_retry = self.new(\n        total=total,\n        connect=connect,\n        read=read,\n        redirect=redirect,\n        status=status_count,\n        other=other,\n        history=history,\n    )\n\n    if new_retry.is_exhausted():\n        raise MaxRetryError(_pool, url, error or ResponseError(cause))\n\n    log.debug(\"Incremented Retry for (url='%s'): %r\", url, new_retry)\n\n    return new_retry\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Retry.is_exhausted","title":"<code>is_exhausted()</code>","text":"<p>Are we out of retries?</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def is_exhausted(self):\n    \"\"\"Are we out of retries?\"\"\"\n    retry_counts = (\n        self.total,\n        self.connect,\n        self.read,\n        self.redirect,\n        self.status,\n        self.other,\n    )\n    retry_counts = list(filter(None, retry_counts))\n    if not retry_counts:\n        return False\n\n    return min(retry_counts) &lt; 0\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Retry.is_retry","title":"<code>is_retry(method, status_code, has_retry_after=False)</code>","text":"<p>Is this method/status code retryable? (Based on allowlists and control variables such as the number of total retries to allow, whether to respect the Retry-After header, whether this header is present, and whether the returned status code is on the list of status codes to be retried upon on the presence of the aforementioned header)</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def is_retry(self, method, status_code, has_retry_after=False):\n    \"\"\"Is this method/status code retryable? (Based on allowlists and control\n    variables such as the number of total retries to allow, whether to\n    respect the Retry-After header, whether this header is present, and\n    whether the returned status code is on the list of status codes to\n    be retried upon on the presence of the aforementioned header)\n    \"\"\"\n    if not self._is_method_retryable(method):\n        return False\n\n    if self.status_forcelist and status_code in self.status_forcelist:\n        return True\n\n    return (\n        self.total\n        and self.respect_retry_after_header\n        and has_retry_after\n        and (status_code in self.RETRY_AFTER_STATUS_CODES)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Retry.sleep","title":"<code>sleep(response=None)</code>","text":"<p>Sleep between retry attempts.</p> <p>This method will respect a server's <code>Retry-After</code> response header and sleep the duration of the time requested. If that is not present, it will use an exponential backoff. By default, the backoff factor is 0 and this method will return immediately.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def sleep(self, response=None):\n    \"\"\"Sleep between retry attempts.\n\n    This method will respect a server's ``Retry-After`` response header\n    and sleep the duration of the time requested. If that is not present, it\n    will use an exponential backoff. By default, the backoff factor is 0 and\n    this method will return immediately.\n    \"\"\"\n\n    if self.respect_retry_after_header and response:\n        slept = self.sleep_for_retry(response)\n        if slept:\n            return\n\n    self._sleep_backoff()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Timeout","title":"<code>Timeout</code>","text":"<p>               Bases: <code>object</code></p> <p>Timeout configuration.</p> <p>Timeouts can be defined as a default for a pool:</p> <p>.. code-block:: python</p> <p>timeout = Timeout(connect=2.0, read=7.0)    http = PoolManager(timeout=timeout)    response = http.request('GET', 'http://example.com/')</p> <p>Or per-request (which overrides the default for the pool):</p> <p>.. code-block:: python</p> <p>response = http.request('GET', 'http://example.com/', timeout=Timeout(10))</p> <p>Timeouts can be disabled by setting all the parameters to <code>None</code>:</p> <p>.. code-block:: python</p> <p>no_timeout = Timeout(connect=None, read=None)    response = http.request('GET', 'http://example.com/, timeout=no_timeout)</p> <p>:param total:     This combines the connect and read timeouts into one; the read timeout     will be set to the time leftover from the connect attempt. In the     event that both a connect timeout and a total are specified, or a read     timeout and a total are specified, the shorter timeout will be applied.</p> <pre><code>Defaults to None.\n</code></pre> <p>:type total: int, float, or None</p> <p>:param connect:     The maximum amount of time (in seconds) to wait for a connection     attempt to a server to succeed. Omitting the parameter will default the     connect timeout to the system default, probably <code>the global default     timeout in socket.py     &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;</code>_.     None will set an infinite timeout for connection attempts.</p> <p>:type connect: int, float, or None</p> <p>:param read:     The maximum amount of time (in seconds) to wait between consecutive     read operations for a response from the server. Omitting the parameter     will default the read timeout to the system default, probably <code>the     global default timeout in socket.py     &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;</code>_.     None will set an infinite timeout.</p> <p>:type read: int, float, or None</p> <p>.. note::</p> <pre><code>Many factors can affect the total amount of time for urllib3 to return\nan HTTP response.\n\nFor example, Python's DNS resolver does not obey the timeout specified\non the socket. Other factors that can affect total request time include\nhigh CPU load, high swap, the program running at a low priority level,\nor other behaviors.\n\nIn addition, the read and total timeouts only measure the time between\nread operations on the socket connecting the client and the server,\nnot the total amount of time for the request to return a complete\nresponse. For most requests, the timeout is raised because the server\nhas not sent the first byte in the specified time. This is not always\nthe case; if a server streams one byte every fifteen seconds, a timeout\nof 20 seconds will not trigger, even though the request will take\nseveral minutes to complete.\n\nIf your goal is to cut off any request after a set amount of wall clock\ntime, consider having a second \"watcher\" thread to cut off a slow\nrequest.\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>class Timeout(object):\n    \"\"\"Timeout configuration.\n\n    Timeouts can be defined as a default for a pool:\n\n    .. code-block:: python\n\n       timeout = Timeout(connect=2.0, read=7.0)\n       http = PoolManager(timeout=timeout)\n       response = http.request('GET', 'http://example.com/')\n\n    Or per-request (which overrides the default for the pool):\n\n    .. code-block:: python\n\n       response = http.request('GET', 'http://example.com/', timeout=Timeout(10))\n\n    Timeouts can be disabled by setting all the parameters to ``None``:\n\n    .. code-block:: python\n\n       no_timeout = Timeout(connect=None, read=None)\n       response = http.request('GET', 'http://example.com/, timeout=no_timeout)\n\n\n    :param total:\n        This combines the connect and read timeouts into one; the read timeout\n        will be set to the time leftover from the connect attempt. In the\n        event that both a connect timeout and a total are specified, or a read\n        timeout and a total are specified, the shorter timeout will be applied.\n\n        Defaults to None.\n\n    :type total: int, float, or None\n\n    :param connect:\n        The maximum amount of time (in seconds) to wait for a connection\n        attempt to a server to succeed. Omitting the parameter will default the\n        connect timeout to the system default, probably `the global default\n        timeout in socket.py\n        &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;`_.\n        None will set an infinite timeout for connection attempts.\n\n    :type connect: int, float, or None\n\n    :param read:\n        The maximum amount of time (in seconds) to wait between consecutive\n        read operations for a response from the server. Omitting the parameter\n        will default the read timeout to the system default, probably `the\n        global default timeout in socket.py\n        &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;`_.\n        None will set an infinite timeout.\n\n    :type read: int, float, or None\n\n    .. note::\n\n        Many factors can affect the total amount of time for urllib3 to return\n        an HTTP response.\n\n        For example, Python's DNS resolver does not obey the timeout specified\n        on the socket. Other factors that can affect total request time include\n        high CPU load, high swap, the program running at a low priority level,\n        or other behaviors.\n\n        In addition, the read and total timeouts only measure the time between\n        read operations on the socket connecting the client and the server,\n        not the total amount of time for the request to return a complete\n        response. For most requests, the timeout is raised because the server\n        has not sent the first byte in the specified time. This is not always\n        the case; if a server streams one byte every fifteen seconds, a timeout\n        of 20 seconds will not trigger, even though the request will take\n        several minutes to complete.\n\n        If your goal is to cut off any request after a set amount of wall clock\n        time, consider having a second \"watcher\" thread to cut off a slow\n        request.\n    \"\"\"\n\n    #: A sentinel object representing the default timeout value\n    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT\n\n    def __init__(self, total=None, connect=_Default, read=_Default):\n        self._connect = self._validate_timeout(connect, \"connect\")\n        self._read = self._validate_timeout(read, \"read\")\n        self.total = self._validate_timeout(total, \"total\")\n        self._start_connect = None\n\n    def __repr__(self):\n        return \"%s(connect=%r, read=%r, total=%r)\" % (\n            type(self).__name__,\n            self._connect,\n            self._read,\n            self.total,\n        )\n\n    # __str__ provided for backwards compatibility\n    __str__ = __repr__\n\n    @classmethod\n    def _validate_timeout(cls, value, name):\n        \"\"\"Check that a timeout attribute is valid.\n\n        :param value: The timeout value to validate\n        :param name: The name of the timeout attribute to validate. This is\n            used to specify in error messages.\n        :return: The validated and casted version of the given value.\n        :raises ValueError: If it is a numeric value less than or equal to\n            zero, or the type is not an integer, float, or None.\n        \"\"\"\n        if value is _Default:\n            return cls.DEFAULT_TIMEOUT\n\n        if value is None or value is cls.DEFAULT_TIMEOUT:\n            return value\n\n        if isinstance(value, bool):\n            raise ValueError(\n                \"Timeout cannot be a boolean value. It must \"\n                \"be an int, float or None.\"\n            )\n        try:\n            float(value)\n        except (TypeError, ValueError):\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            )\n\n        try:\n            if value &lt;= 0:\n                raise ValueError(\n                    \"Attempted to set %s timeout to %s, but the \"\n                    \"timeout cannot be set to a value less \"\n                    \"than or equal to 0.\" % (name, value)\n                )\n        except TypeError:\n            # Python 3\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            )\n\n        return value\n\n    @classmethod\n    def from_float(cls, timeout):\n        \"\"\"Create a new Timeout from a legacy timeout value.\n\n        The timeout value used by httplib.py sets the same timeout on the\n        connect(), and recv() socket requests. This creates a :class:`Timeout`\n        object that sets the individual timeouts to the ``timeout`` value\n        passed to this function.\n\n        :param timeout: The legacy timeout value.\n        :type timeout: integer, float, sentinel default object, or None\n        :return: Timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        return Timeout(read=timeout, connect=timeout)\n\n    def clone(self):\n        \"\"\"Create a copy of the timeout object\n\n        Timeout properties are stored per-pool but each request needs a fresh\n        Timeout object to ensure each one has its own start/stop configured.\n\n        :return: a copy of the timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        # We can't use copy.deepcopy because that will also create a new object\n        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to\n        # detect the user default.\n        return Timeout(connect=self._connect, read=self._read, total=self.total)\n\n    def start_connect(self):\n        \"\"\"Start the timeout clock, used during a connect() attempt\n\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to start a timer that has been started already.\n        \"\"\"\n        if self._start_connect is not None:\n            raise TimeoutStateError(\"Timeout timer has already been started.\")\n        self._start_connect = current_time()\n        return self._start_connect\n\n    def get_connect_duration(self):\n        \"\"\"Gets the time elapsed since the call to :meth:`start_connect`.\n\n        :return: Elapsed time in seconds.\n        :rtype: float\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to get duration for a timer that hasn't been started.\n        \"\"\"\n        if self._start_connect is None:\n            raise TimeoutStateError(\n                \"Can't get connect duration for timer that has not started.\"\n            )\n        return current_time() - self._start_connect\n\n    @property\n    def connect_timeout(self):\n        \"\"\"Get the value to use when setting a connection timeout.\n\n        This will be a positive float or integer, the value None\n        (never timeout), or the default system timeout.\n\n        :return: Connect timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        \"\"\"\n        if self.total is None:\n            return self._connect\n\n        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:\n            return self.total\n\n        return min(self._connect, self.total)\n\n    @property\n    def read_timeout(self):\n        \"\"\"Get the value for the read timeout.\n\n        This assumes some time has elapsed in the connection timeout and\n        computes the read timeout appropriately.\n\n        If self.total is set, the read timeout is dependent on the amount of\n        time taken by the connect timeout. If the connection time has not been\n        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be\n        raised.\n\n        :return: Value to use for the read timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`\n            has not yet been called on this object.\n        \"\"\"\n        if (\n            self.total is not None\n            and self.total is not self.DEFAULT_TIMEOUT\n            and self._read is not None\n            and self._read is not self.DEFAULT_TIMEOUT\n        ):\n            # In case the connect timeout has not yet been established.\n            if self._start_connect is None:\n                return self._read\n            return max(0, min(self.total - self.get_connect_duration(), self._read))\n        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:\n            return max(0, self.total - self.get_connect_duration())\n        else:\n            return self._read\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Timeout.connect_timeout","title":"<code>connect_timeout</code>  <code>property</code>","text":"<p>Get the value to use when setting a connection timeout.</p> <p>This will be a positive float or integer, the value None (never timeout), or the default system timeout.</p> <p>:return: Connect timeout. :rtype: int, float, :attr:<code>Timeout.DEFAULT_TIMEOUT</code> or None</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Timeout.read_timeout","title":"<code>read_timeout</code>  <code>property</code>","text":"<p>Get the value for the read timeout.</p> <p>This assumes some time has elapsed in the connection timeout and computes the read timeout appropriately.</p> <p>If self.total is set, the read timeout is dependent on the amount of time taken by the connect timeout. If the connection time has not been established, a :exc:<code>~urllib3.exceptions.TimeoutStateError</code> will be raised.</p> <p>:return: Value to use for the read timeout. :rtype: int, float, :attr:<code>Timeout.DEFAULT_TIMEOUT</code> or None :raises urllib3.exceptions.TimeoutStateError: If :meth:<code>start_connect</code>     has not yet been called on this object.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Timeout.clone","title":"<code>clone()</code>","text":"<p>Create a copy of the timeout object</p> <p>Timeout properties are stored per-pool but each request needs a fresh Timeout object to ensure each one has its own start/stop configured.</p> <p>:return: a copy of the timeout object :rtype: :class:<code>Timeout</code></p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>def clone(self):\n    \"\"\"Create a copy of the timeout object\n\n    Timeout properties are stored per-pool but each request needs a fresh\n    Timeout object to ensure each one has its own start/stop configured.\n\n    :return: a copy of the timeout object\n    :rtype: :class:`Timeout`\n    \"\"\"\n    # We can't use copy.deepcopy because that will also create a new object\n    # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to\n    # detect the user default.\n    return Timeout(connect=self._connect, read=self._read, total=self.total)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Timeout.from_float","title":"<code>from_float(timeout)</code>  <code>classmethod</code>","text":"<p>Create a new Timeout from a legacy timeout value.</p> <p>The timeout value used by httplib.py sets the same timeout on the connect(), and recv() socket requests. This creates a :class:<code>Timeout</code> object that sets the individual timeouts to the <code>timeout</code> value passed to this function.</p> <p>:param timeout: The legacy timeout value. :type timeout: integer, float, sentinel default object, or None :return: Timeout object :rtype: :class:<code>Timeout</code></p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>@classmethod\ndef from_float(cls, timeout):\n    \"\"\"Create a new Timeout from a legacy timeout value.\n\n    The timeout value used by httplib.py sets the same timeout on the\n    connect(), and recv() socket requests. This creates a :class:`Timeout`\n    object that sets the individual timeouts to the ``timeout`` value\n    passed to this function.\n\n    :param timeout: The legacy timeout value.\n    :type timeout: integer, float, sentinel default object, or None\n    :return: Timeout object\n    :rtype: :class:`Timeout`\n    \"\"\"\n    return Timeout(read=timeout, connect=timeout)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Timeout.get_connect_duration","title":"<code>get_connect_duration()</code>","text":"<p>Gets the time elapsed since the call to :meth:<code>start_connect</code>.</p> <p>:return: Elapsed time in seconds. :rtype: float :raises urllib3.exceptions.TimeoutStateError: if you attempt     to get duration for a timer that hasn't been started.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>def get_connect_duration(self):\n    \"\"\"Gets the time elapsed since the call to :meth:`start_connect`.\n\n    :return: Elapsed time in seconds.\n    :rtype: float\n    :raises urllib3.exceptions.TimeoutStateError: if you attempt\n        to get duration for a timer that hasn't been started.\n    \"\"\"\n    if self._start_connect is None:\n        raise TimeoutStateError(\n            \"Can't get connect duration for timer that has not started.\"\n        )\n    return current_time() - self._start_connect\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.Timeout.start_connect","title":"<code>start_connect()</code>","text":"<p>Start the timeout clock, used during a connect() attempt</p> <p>:raises urllib3.exceptions.TimeoutStateError: if you attempt     to start a timer that has been started already.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>def start_connect(self):\n    \"\"\"Start the timeout clock, used during a connect() attempt\n\n    :raises urllib3.exceptions.TimeoutStateError: if you attempt\n        to start a timer that has been started already.\n    \"\"\"\n    if self._start_connect is not None:\n        raise TimeoutStateError(\"Timeout timer has already been started.\")\n    self._start_connect = current_time()\n    return self._start_connect\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.add_stderr_logger","title":"<code>add_stderr_logger(level=logging.DEBUG)</code>","text":"<p>Helper for quickly adding a StreamHandler to the logger. Useful for debugging.</p> <p>Returns the handler after adding it.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/__init__.py</code> <pre><code>def add_stderr_logger(level=logging.DEBUG):\n    \"\"\"\n    Helper for quickly adding a StreamHandler to the logger. Useful for\n    debugging.\n\n    Returns the handler after adding it.\n    \"\"\"\n    # This method needs to be in this __init__.py to get the __name__ correct\n    # even if urllib3 is vendored within another package.\n    logger = logging.getLogger(__name__)\n    handler = logging.StreamHandler()\n    handler.setFormatter(logging.Formatter(\"%(asctime)s %(levelname)s %(message)s\"))\n    logger.addHandler(handler)\n    logger.setLevel(level)\n    logger.debug(\"Added a stderr logging handler to logger: %s\", __name__)\n    return handler\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.connection_from_url","title":"<code>connection_from_url(url, **kw)</code>","text":"<p>Given a url, return an :class:<code>.ConnectionPool</code> instance of its host.</p> <p>This is a shortcut for not having to parse out the scheme, host, and port of the url before creating an :class:<code>.ConnectionPool</code> instance.</p> <p>:param url:     Absolute URL string that must include the scheme. Port is optional.</p> <p>:param **kw:     Passes additional parameters to the constructor of the appropriate     :class:<code>.ConnectionPool</code>. Useful for specifying things like     timeout, maxsize, headers, etc.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; conn = connection_from_url('http://google.com/')\n&gt;&gt;&gt; r = conn.request('GET', '/')\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>def connection_from_url(url, **kw):\n    \"\"\"\n    Given a url, return an :class:`.ConnectionPool` instance of its host.\n\n    This is a shortcut for not having to parse out the scheme, host, and port\n    of the url before creating an :class:`.ConnectionPool` instance.\n\n    :param url:\n        Absolute URL string that must include the scheme. Port is optional.\n\n    :param \\\\**kw:\n        Passes additional parameters to the constructor of the appropriate\n        :class:`.ConnectionPool`. Useful for specifying things like\n        timeout, maxsize, headers, etc.\n\n    Example::\n\n        &gt;&gt;&gt; conn = connection_from_url('http://google.com/')\n        &gt;&gt;&gt; r = conn.request('GET', '/')\n    \"\"\"\n    scheme, host, port = get_host(url)\n    port = port or port_by_scheme.get(scheme, 80)\n    if scheme == \"https\":\n        return HTTPSConnectionPool(host, port=port, **kw)\n    else:\n        return HTTPConnectionPool(host, port=port, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.disable_warnings","title":"<code>disable_warnings(category=exceptions.HTTPWarning)</code>","text":"<p>Helper for quickly disabling all urllib3 warnings.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/__init__.py</code> <pre><code>def disable_warnings(category=exceptions.HTTPWarning):\n    \"\"\"\n    Helper for quickly disabling all urllib3 warnings.\n    \"\"\"\n    warnings.simplefilter(\"ignore\", category)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.encode_multipart_formdata","title":"<code>encode_multipart_formdata(fields, boundary=None)</code>","text":"<p>Encode a dictionary of <code>fields</code> using the multipart/form-data MIME format.</p> <p>:param fields:     Dictionary of fields or list of (key, :class:<code>~urllib3.fields.RequestField</code>).</p> <p>:param boundary:     If not specified, then a random boundary will be generated using     :func:<code>urllib3.filepost.choose_boundary</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/filepost.py</code> <pre><code>def encode_multipart_formdata(fields, boundary=None):\n    \"\"\"\n    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.\n\n    :param fields:\n        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).\n\n    :param boundary:\n        If not specified, then a random boundary will be generated using\n        :func:`urllib3.filepost.choose_boundary`.\n    \"\"\"\n    body = BytesIO()\n    if boundary is None:\n        boundary = choose_boundary()\n\n    for field in iter_field_objects(fields):\n        body.write(b(\"--%s\\r\\n\" % (boundary)))\n\n        writer(body).write(field.render_headers())\n        data = field.data\n\n        if isinstance(data, int):\n            data = str(data)  # Backwards compatibility\n\n        if isinstance(data, six.text_type):\n            writer(body).write(data)\n        else:\n            body.write(data)\n\n        body.write(b\"\\r\\n\")\n\n    body.write(b(\"--%s--\\r\\n\" % (boundary)))\n\n    content_type = str(\"multipart/form-data; boundary=%s\" % boundary)\n\n    return body.getvalue(), content_type\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.get_host","title":"<code>get_host(url)</code>","text":"<p>Deprecated. Use :func:<code>parse_url</code> instead.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/url.py</code> <pre><code>def get_host(url):\n    \"\"\"\n    Deprecated. Use :func:`parse_url` instead.\n    \"\"\"\n    p = parse_url(url)\n    return p.scheme or \"http\", p.hostname, p.port\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/index.html#client.ayon_fusion.vendor.urllib3.make_headers","title":"<code>make_headers(keep_alive=None, accept_encoding=None, user_agent=None, basic_auth=None, proxy_basic_auth=None, disable_cache=None)</code>","text":"<p>Shortcuts for generating request headers.</p> <p>:param keep_alive:     If <code>True</code>, adds 'connection: keep-alive' header.</p> <p>:param accept_encoding:     Can be a boolean, list, or string.     <code>True</code> translates to 'gzip,deflate'.     List will get joined by comma.     String will be used as provided.</p> <p>:param user_agent:     String representing the user-agent you want, such as     \"python-urllib3/0.6\"</p> <p>:param basic_auth:     Colon-separated username:password string for 'authorization: basic ...'     auth header.</p> <p>:param proxy_basic_auth:     Colon-separated username:password string for 'proxy-authorization: basic ...'     auth header.</p> <p>:param disable_cache:     If <code>True</code>, adds 'cache-control: no-cache' header.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; make_headers(keep_alive=True, user_agent=\"Batman/1.0\")\n{'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n&gt;&gt;&gt; make_headers(accept_encoding=True)\n{'accept-encoding': 'gzip,deflate'}\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/util/request.py</code> <pre><code>def make_headers(\n    keep_alive=None,\n    accept_encoding=None,\n    user_agent=None,\n    basic_auth=None,\n    proxy_basic_auth=None,\n    disable_cache=None,\n):\n    \"\"\"\n    Shortcuts for generating request headers.\n\n    :param keep_alive:\n        If ``True``, adds 'connection: keep-alive' header.\n\n    :param accept_encoding:\n        Can be a boolean, list, or string.\n        ``True`` translates to 'gzip,deflate'.\n        List will get joined by comma.\n        String will be used as provided.\n\n    :param user_agent:\n        String representing the user-agent you want, such as\n        \"python-urllib3/0.6\"\n\n    :param basic_auth:\n        Colon-separated username:password string for 'authorization: basic ...'\n        auth header.\n\n    :param proxy_basic_auth:\n        Colon-separated username:password string for 'proxy-authorization: basic ...'\n        auth header.\n\n    :param disable_cache:\n        If ``True``, adds 'cache-control: no-cache' header.\n\n    Example::\n\n        &gt;&gt;&gt; make_headers(keep_alive=True, user_agent=\"Batman/1.0\")\n        {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n        &gt;&gt;&gt; make_headers(accept_encoding=True)\n        {'accept-encoding': 'gzip,deflate'}\n    \"\"\"\n    headers = {}\n    if accept_encoding:\n        if isinstance(accept_encoding, str):\n            pass\n        elif isinstance(accept_encoding, list):\n            accept_encoding = \",\".join(accept_encoding)\n        else:\n            accept_encoding = ACCEPT_ENCODING\n        headers[\"accept-encoding\"] = accept_encoding\n\n    if user_agent:\n        headers[\"user-agent\"] = user_agent\n\n    if keep_alive:\n        headers[\"connection\"] = \"keep-alive\"\n\n    if basic_auth:\n        headers[\"authorization\"] = \"Basic \" + b64encode(b(basic_auth)).decode(\"utf-8\")\n\n    if proxy_basic_auth:\n        headers[\"proxy-authorization\"] = \"Basic \" + b64encode(\n            b(proxy_basic_auth)\n        ).decode(\"utf-8\")\n\n    if disable_cache:\n        headers[\"cache-control\"] = \"no-cache\"\n\n    return headers\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html","title":"_collections","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html#client.ayon_fusion.vendor.urllib3._collections.HTTPHeaderDict","title":"<code>HTTPHeaderDict</code>","text":"<p>               Bases: <code>MutableMapping</code></p> <p>:param headers:     An iterable of field-value pairs. Must not contain multiple field names     when compared case-insensitively.</p> <p>:param kwargs:     Additional field-value pairs to pass in to <code>dict.update</code>.</p> <p>A <code>dict</code> like container for storing HTTP Headers.</p> <p>Field names are stored and compared case-insensitively in compliance with RFC 7230. Iteration provides the first case-sensitive key seen for each case-insensitive pair.</p> <p>Using <code>__setitem__</code> syntax overwrites fields that compare equal case-insensitively in order to maintain <code>dict</code>'s api. For fields that compare equal, instead create a new <code>HTTPHeaderDict</code> and use <code>.add</code> in a loop.</p> <p>If multiple fields that are equal case-insensitively are passed to the constructor or <code>.update</code>, the behavior is undefined and some will be lost.</p> <p>headers = HTTPHeaderDict() headers.add('Set-Cookie', 'foo=bar') headers.add('set-cookie', 'baz=quxx') headers['content-length'] = '7' headers['SET-cookie'] 'foo=bar, baz=quxx' headers['Content-Length'] '7'</p> Source code in <code>client/ayon_fusion/vendor/urllib3/_collections.py</code> <pre><code>class HTTPHeaderDict(MutableMapping):\n    \"\"\"\n    :param headers:\n        An iterable of field-value pairs. Must not contain multiple field names\n        when compared case-insensitively.\n\n    :param kwargs:\n        Additional field-value pairs to pass in to ``dict.update``.\n\n    A ``dict`` like container for storing HTTP Headers.\n\n    Field names are stored and compared case-insensitively in compliance with\n    RFC 7230. Iteration provides the first case-sensitive key seen for each\n    case-insensitive pair.\n\n    Using ``__setitem__`` syntax overwrites fields that compare equal\n    case-insensitively in order to maintain ``dict``'s api. For fields that\n    compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``\n    in a loop.\n\n    If multiple fields that are equal case-insensitively are passed to the\n    constructor or ``.update``, the behavior is undefined and some will be\n    lost.\n\n    &gt;&gt;&gt; headers = HTTPHeaderDict()\n    &gt;&gt;&gt; headers.add('Set-Cookie', 'foo=bar')\n    &gt;&gt;&gt; headers.add('set-cookie', 'baz=quxx')\n    &gt;&gt;&gt; headers['content-length'] = '7'\n    &gt;&gt;&gt; headers['SET-cookie']\n    'foo=bar, baz=quxx'\n    &gt;&gt;&gt; headers['Content-Length']\n    '7'\n    \"\"\"\n\n    def __init__(self, headers=None, **kwargs):\n        super(HTTPHeaderDict, self).__init__()\n        self._container = OrderedDict()\n        if headers is not None:\n            if isinstance(headers, HTTPHeaderDict):\n                self._copy_from(headers)\n            else:\n                self.extend(headers)\n        if kwargs:\n            self.extend(kwargs)\n\n    def __setitem__(self, key, val):\n        self._container[key.lower()] = [key, val]\n        return self._container[key.lower()]\n\n    def __getitem__(self, key):\n        val = self._container[key.lower()]\n        return \", \".join(val[1:])\n\n    def __delitem__(self, key):\n        del self._container[key.lower()]\n\n    def __contains__(self, key):\n        return key.lower() in self._container\n\n    def __eq__(self, other):\n        if not isinstance(other, Mapping) and not hasattr(other, \"keys\"):\n            return False\n        if not isinstance(other, type(self)):\n            other = type(self)(other)\n        return dict((k.lower(), v) for k, v in self.itermerged()) == dict(\n            (k.lower(), v) for k, v in other.itermerged()\n        )\n\n    def __ne__(self, other):\n        return not self.__eq__(other)\n\n    if six.PY2:  # Python 2\n        iterkeys = MutableMapping.iterkeys\n        itervalues = MutableMapping.itervalues\n\n    __marker = object()\n\n    def __len__(self):\n        return len(self._container)\n\n    def __iter__(self):\n        # Only provide the originally cased names\n        for vals in self._container.values():\n            yield vals[0]\n\n    def pop(self, key, default=__marker):\n        \"\"\"D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.\n        If key is not found, d is returned if given, otherwise KeyError is raised.\n        \"\"\"\n        # Using the MutableMapping function directly fails due to the private marker.\n        # Using ordinary dict.pop would expose the internal structures.\n        # So let's reinvent the wheel.\n        try:\n            value = self[key]\n        except KeyError:\n            if default is self.__marker:\n                raise\n            return default\n        else:\n            del self[key]\n            return value\n\n    def discard(self, key):\n        try:\n            del self[key]\n        except KeyError:\n            pass\n\n    def add(self, key, val):\n        \"\"\"Adds a (name, value) pair, doesn't overwrite the value if it already\n        exists.\n\n        &gt;&gt;&gt; headers = HTTPHeaderDict(foo='bar')\n        &gt;&gt;&gt; headers.add('Foo', 'baz')\n        &gt;&gt;&gt; headers['foo']\n        'bar, baz'\n        \"\"\"\n        key_lower = key.lower()\n        new_vals = [key, val]\n        # Keep the common case aka no item present as fast as possible\n        vals = self._container.setdefault(key_lower, new_vals)\n        if new_vals is not vals:\n            vals.append(val)\n\n    def extend(self, *args, **kwargs):\n        \"\"\"Generic import function for any type of header-like object.\n        Adapted version of MutableMapping.update in order to insert items\n        with self.add instead of self.__setitem__\n        \"\"\"\n        if len(args) &gt; 1:\n            raise TypeError(\n                \"extend() takes at most 1 positional \"\n                \"arguments ({0} given)\".format(len(args))\n            )\n        other = args[0] if len(args) &gt;= 1 else ()\n\n        if isinstance(other, HTTPHeaderDict):\n            for key, val in other.iteritems():\n                self.add(key, val)\n        elif isinstance(other, Mapping):\n            for key in other:\n                self.add(key, other[key])\n        elif hasattr(other, \"keys\"):\n            for key in other.keys():\n                self.add(key, other[key])\n        else:\n            for key, value in other:\n                self.add(key, value)\n\n        for key, value in kwargs.items():\n            self.add(key, value)\n\n    def getlist(self, key, default=__marker):\n        \"\"\"Returns a list of all the values for the named field. Returns an\n        empty list if the key doesn't exist.\"\"\"\n        try:\n            vals = self._container[key.lower()]\n        except KeyError:\n            if default is self.__marker:\n                return []\n            return default\n        else:\n            return vals[1:]\n\n    # Backwards compatibility for httplib\n    getheaders = getlist\n    getallmatchingheaders = getlist\n    iget = getlist\n\n    # Backwards compatibility for http.cookiejar\n    get_all = getlist\n\n    def __repr__(self):\n        return \"%s(%s)\" % (type(self).__name__, dict(self.itermerged()))\n\n    def _copy_from(self, other):\n        for key in other:\n            val = other.getlist(key)\n            if isinstance(val, list):\n                # Don't need to convert tuples\n                val = list(val)\n            self._container[key.lower()] = [key] + val\n\n    def copy(self):\n        clone = type(self)()\n        clone._copy_from(self)\n        return clone\n\n    def iteritems(self):\n        \"\"\"Iterate over all header lines, including duplicate ones.\"\"\"\n        for key in self:\n            vals = self._container[key.lower()]\n            for val in vals[1:]:\n                yield vals[0], val\n\n    def itermerged(self):\n        \"\"\"Iterate over all headers, merging duplicate ones together.\"\"\"\n        for key in self:\n            val = self._container[key.lower()]\n            yield val[0], \", \".join(val[1:])\n\n    def items(self):\n        return list(self.iteritems())\n\n    @classmethod\n    def from_httplib(cls, message):  # Python 2\n        \"\"\"Read headers from a Python 2 httplib message object.\"\"\"\n        # python2.7 does not expose a proper API for exporting multiheaders\n        # efficiently. This function re-reads raw lines from the message\n        # object and extracts the multiheaders properly.\n        obs_fold_continued_leaders = (\" \", \"\\t\")\n        headers = []\n\n        for line in message.headers:\n            if line.startswith(obs_fold_continued_leaders):\n                if not headers:\n                    # We received a header line that starts with OWS as described\n                    # in RFC-7230 S3.2.4. This indicates a multiline header, but\n                    # there exists no previous header to which we can attach it.\n                    raise InvalidHeader(\n                        \"Header continuation with no previous header: %s\" % line\n                    )\n                else:\n                    key, value = headers[-1]\n                    headers[-1] = (key, value + \" \" + line.strip())\n                    continue\n\n            key, value = line.split(\":\", 1)\n            headers.append((key, value.strip()))\n\n        return cls(headers)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html#client.ayon_fusion.vendor.urllib3._collections.HTTPHeaderDict.add","title":"<code>add(key, val)</code>","text":"<p>Adds a (name, value) pair, doesn't overwrite the value if it already exists.</p> <p>headers = HTTPHeaderDict(foo='bar') headers.add('Foo', 'baz') headers['foo'] 'bar, baz'</p> Source code in <code>client/ayon_fusion/vendor/urllib3/_collections.py</code> <pre><code>def add(self, key, val):\n    \"\"\"Adds a (name, value) pair, doesn't overwrite the value if it already\n    exists.\n\n    &gt;&gt;&gt; headers = HTTPHeaderDict(foo='bar')\n    &gt;&gt;&gt; headers.add('Foo', 'baz')\n    &gt;&gt;&gt; headers['foo']\n    'bar, baz'\n    \"\"\"\n    key_lower = key.lower()\n    new_vals = [key, val]\n    # Keep the common case aka no item present as fast as possible\n    vals = self._container.setdefault(key_lower, new_vals)\n    if new_vals is not vals:\n        vals.append(val)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html#client.ayon_fusion.vendor.urllib3._collections.HTTPHeaderDict.extend","title":"<code>extend(*args, **kwargs)</code>","text":"<p>Generic import function for any type of header-like object. Adapted version of MutableMapping.update in order to insert items with self.add instead of self.setitem</p> Source code in <code>client/ayon_fusion/vendor/urllib3/_collections.py</code> <pre><code>def extend(self, *args, **kwargs):\n    \"\"\"Generic import function for any type of header-like object.\n    Adapted version of MutableMapping.update in order to insert items\n    with self.add instead of self.__setitem__\n    \"\"\"\n    if len(args) &gt; 1:\n        raise TypeError(\n            \"extend() takes at most 1 positional \"\n            \"arguments ({0} given)\".format(len(args))\n        )\n    other = args[0] if len(args) &gt;= 1 else ()\n\n    if isinstance(other, HTTPHeaderDict):\n        for key, val in other.iteritems():\n            self.add(key, val)\n    elif isinstance(other, Mapping):\n        for key in other:\n            self.add(key, other[key])\n    elif hasattr(other, \"keys\"):\n        for key in other.keys():\n            self.add(key, other[key])\n    else:\n        for key, value in other:\n            self.add(key, value)\n\n    for key, value in kwargs.items():\n        self.add(key, value)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html#client.ayon_fusion.vendor.urllib3._collections.HTTPHeaderDict.from_httplib","title":"<code>from_httplib(message)</code>  <code>classmethod</code>","text":"<p>Read headers from a Python 2 httplib message object.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/_collections.py</code> <pre><code>@classmethod\ndef from_httplib(cls, message):  # Python 2\n    \"\"\"Read headers from a Python 2 httplib message object.\"\"\"\n    # python2.7 does not expose a proper API for exporting multiheaders\n    # efficiently. This function re-reads raw lines from the message\n    # object and extracts the multiheaders properly.\n    obs_fold_continued_leaders = (\" \", \"\\t\")\n    headers = []\n\n    for line in message.headers:\n        if line.startswith(obs_fold_continued_leaders):\n            if not headers:\n                # We received a header line that starts with OWS as described\n                # in RFC-7230 S3.2.4. This indicates a multiline header, but\n                # there exists no previous header to which we can attach it.\n                raise InvalidHeader(\n                    \"Header continuation with no previous header: %s\" % line\n                )\n            else:\n                key, value = headers[-1]\n                headers[-1] = (key, value + \" \" + line.strip())\n                continue\n\n        key, value = line.split(\":\", 1)\n        headers.append((key, value.strip()))\n\n    return cls(headers)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html#client.ayon_fusion.vendor.urllib3._collections.HTTPHeaderDict.getlist","title":"<code>getlist(key, default=__marker)</code>","text":"<p>Returns a list of all the values for the named field. Returns an empty list if the key doesn't exist.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/_collections.py</code> <pre><code>def getlist(self, key, default=__marker):\n    \"\"\"Returns a list of all the values for the named field. Returns an\n    empty list if the key doesn't exist.\"\"\"\n    try:\n        vals = self._container[key.lower()]\n    except KeyError:\n        if default is self.__marker:\n            return []\n        return default\n    else:\n        return vals[1:]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html#client.ayon_fusion.vendor.urllib3._collections.HTTPHeaderDict.iteritems","title":"<code>iteritems()</code>","text":"<p>Iterate over all header lines, including duplicate ones.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/_collections.py</code> <pre><code>def iteritems(self):\n    \"\"\"Iterate over all header lines, including duplicate ones.\"\"\"\n    for key in self:\n        vals = self._container[key.lower()]\n        for val in vals[1:]:\n            yield vals[0], val\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html#client.ayon_fusion.vendor.urllib3._collections.HTTPHeaderDict.itermerged","title":"<code>itermerged()</code>","text":"<p>Iterate over all headers, merging duplicate ones together.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/_collections.py</code> <pre><code>def itermerged(self):\n    \"\"\"Iterate over all headers, merging duplicate ones together.\"\"\"\n    for key in self:\n        val = self._container[key.lower()]\n        yield val[0], \", \".join(val[1:])\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html#client.ayon_fusion.vendor.urllib3._collections.HTTPHeaderDict.pop","title":"<code>pop(key, default=__marker)</code>","text":"<p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value. If key is not found, d is returned if given, otherwise KeyError is raised.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/_collections.py</code> <pre><code>def pop(self, key, default=__marker):\n    \"\"\"D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.\n    If key is not found, d is returned if given, otherwise KeyError is raised.\n    \"\"\"\n    # Using the MutableMapping function directly fails due to the private marker.\n    # Using ordinary dict.pop would expose the internal structures.\n    # So let's reinvent the wheel.\n    try:\n        value = self[key]\n    except KeyError:\n        if default is self.__marker:\n            raise\n        return default\n    else:\n        del self[key]\n        return value\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_collections.html#client.ayon_fusion.vendor.urllib3._collections.RecentlyUsedContainer","title":"<code>RecentlyUsedContainer</code>","text":"<p>               Bases: <code>MutableMapping</code></p> <p>Provides a thread-safe dict-like container which maintains up to <code>maxsize</code> keys while throwing away the least-recently-used keys beyond <code>maxsize</code>.</p> <p>:param maxsize:     Maximum number of recent elements to retain.</p> <p>:param dispose_func:     Every time an item is evicted from the container,     <code>dispose_func(value)</code> is called.  Callback which will get called</p> Source code in <code>client/ayon_fusion/vendor/urllib3/_collections.py</code> <pre><code>class RecentlyUsedContainer(MutableMapping):\n    \"\"\"\n    Provides a thread-safe dict-like container which maintains up to\n    ``maxsize`` keys while throwing away the least-recently-used keys beyond\n    ``maxsize``.\n\n    :param maxsize:\n        Maximum number of recent elements to retain.\n\n    :param dispose_func:\n        Every time an item is evicted from the container,\n        ``dispose_func(value)`` is called.  Callback which will get called\n    \"\"\"\n\n    ContainerCls = OrderedDict\n\n    def __init__(self, maxsize=10, dispose_func=None):\n        self._maxsize = maxsize\n        self.dispose_func = dispose_func\n\n        self._container = self.ContainerCls()\n        self.lock = RLock()\n\n    def __getitem__(self, key):\n        # Re-insert the item, moving it to the end of the eviction line.\n        with self.lock:\n            item = self._container.pop(key)\n            self._container[key] = item\n            return item\n\n    def __setitem__(self, key, value):\n        evicted_value = _Null\n        with self.lock:\n            # Possibly evict the existing value of 'key'\n            evicted_value = self._container.get(key, _Null)\n            self._container[key] = value\n\n            # If we didn't evict an existing value, we might have to evict the\n            # least recently used item from the beginning of the container.\n            if len(self._container) &gt; self._maxsize:\n                _key, evicted_value = self._container.popitem(last=False)\n\n        if self.dispose_func and evicted_value is not _Null:\n            self.dispose_func(evicted_value)\n\n    def __delitem__(self, key):\n        with self.lock:\n            value = self._container.pop(key)\n\n        if self.dispose_func:\n            self.dispose_func(value)\n\n    def __len__(self):\n        with self.lock:\n            return len(self._container)\n\n    def __iter__(self):\n        raise NotImplementedError(\n            \"Iteration over this class is unlikely to be threadsafe.\"\n        )\n\n    def clear(self):\n        with self.lock:\n            # Copy pointers to all values, then wipe the mapping\n            values = list(itervalues(self._container))\n            self._container.clear()\n\n        if self.dispose_func:\n            for value in values:\n                self.dispose_func(value)\n\n    def keys(self):\n        with self.lock:\n            return list(iterkeys(self._container))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/_version.html","title":"_version","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connection.html","title":"connection","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connection.html#client.ayon_fusion.vendor.urllib3.connection.DummyConnection","title":"<code>DummyConnection</code>","text":"<p>               Bases: <code>object</code></p> <p>Used to detect a failed ConnectionCls import.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connection.py</code> <pre><code>class DummyConnection(object):\n    \"\"\"Used to detect a failed ConnectionCls import.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connection.html#client.ayon_fusion.vendor.urllib3.connection.HTTPConnection","title":"<code>HTTPConnection</code>","text":"<p>               Bases: <code>HTTPConnection</code>, <code>object</code></p> <p>Based on :class:<code>http.client.HTTPConnection</code> but provides an extra constructor backwards-compatibility layer between older and newer Pythons.</p> <p>Additional keyword parameters are used to configure attributes of the connection. Accepted parameters include:</p> <ul> <li><code>strict</code>: See the documentation on :class:<code>urllib3.connectionpool.HTTPConnectionPool</code></li> <li><code>source_address</code>: Set the source address for the current connection.</li> <li><code>socket_options</code>: Set specific options on the underlying socket. If not specified, then   defaults are loaded from <code>HTTPConnection.default_socket_options</code> which includes disabling   Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.</li> </ul> <p>For example, if you wish to enable TCP Keep Alive in addition to the defaults,   you might pass:</p> <p>.. code-block:: python</p> <pre><code> HTTPConnection.default_socket_options + [\n     (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),\n ]\n</code></pre> <p>Or you may want to disable the defaults by passing an empty list (e.g., <code>[]</code>).</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connection.py</code> <pre><code>class HTTPConnection(_HTTPConnection, object):\n    \"\"\"\n    Based on :class:`http.client.HTTPConnection` but provides an extra constructor\n    backwards-compatibility layer between older and newer Pythons.\n\n    Additional keyword parameters are used to configure attributes of the connection.\n    Accepted parameters include:\n\n    - ``strict``: See the documentation on :class:`urllib3.connectionpool.HTTPConnectionPool`\n    - ``source_address``: Set the source address for the current connection.\n    - ``socket_options``: Set specific options on the underlying socket. If not specified, then\n      defaults are loaded from ``HTTPConnection.default_socket_options`` which includes disabling\n      Nagle's algorithm (sets TCP_NODELAY to 1) unless the connection is behind a proxy.\n\n      For example, if you wish to enable TCP Keep Alive in addition to the defaults,\n      you might pass:\n\n      .. code-block:: python\n\n         HTTPConnection.default_socket_options + [\n             (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1),\n         ]\n\n      Or you may want to disable the defaults by passing an empty list (e.g., ``[]``).\n    \"\"\"\n\n    default_port = port_by_scheme[\"http\"]\n\n    #: Disable Nagle's algorithm by default.\n    #: ``[(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]``\n    default_socket_options = [(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)]\n\n    #: Whether this connection verifies the host's certificate.\n    is_verified = False\n\n    def __init__(self, *args, **kw):\n        if not six.PY2:\n            kw.pop(\"strict\", None)\n\n        # Pre-set source_address.\n        self.source_address = kw.get(\"source_address\")\n\n        #: The socket options provided by the user. If no options are\n        #: provided, we use the default options.\n        self.socket_options = kw.pop(\"socket_options\", self.default_socket_options)\n\n        # Proxy options provided by the user.\n        self.proxy = kw.pop(\"proxy\", None)\n        self.proxy_config = kw.pop(\"proxy_config\", None)\n\n        _HTTPConnection.__init__(self, *args, **kw)\n\n    @property\n    def host(self):\n        \"\"\"\n        Getter method to remove any trailing dots that indicate the hostname is an FQDN.\n\n        In general, SSL certificates don't include the trailing dot indicating a\n        fully-qualified domain name, and thus, they don't validate properly when\n        checked against a domain name that includes the dot. In addition, some\n        servers may not expect to receive the trailing dot when provided.\n\n        However, the hostname with trailing dot is critical to DNS resolution; doing a\n        lookup with the trailing dot will properly only resolve the appropriate FQDN,\n        whereas a lookup without a trailing dot will search the system's search domain\n        list. Thus, it's important to keep the original host around for use only in\n        those cases where it's appropriate (i.e., when doing DNS lookup to establish the\n        actual TCP connection across which we're going to send HTTP requests).\n        \"\"\"\n        return self._dns_host.rstrip(\".\")\n\n    @host.setter\n    def host(self, value):\n        \"\"\"\n        Setter for the `host` property.\n\n        We assume that only urllib3 uses the _dns_host attribute; httplib itself\n        only uses `host`, and it seems reasonable that other libraries follow suit.\n        \"\"\"\n        self._dns_host = value\n\n    def _new_conn(self):\n        \"\"\"Establish a socket connection and set nodelay settings on it.\n\n        :return: New socket connection.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n\n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n\n        try:\n            conn = connection.create_connection(\n                (self._dns_host, self.port), self.timeout, **extra_kw\n            )\n\n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n\n        except SocketError as e:\n            raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\n\n        return conn\n\n    def _is_using_tunnel(self):\n        # Google App Engine's httplib does not define _tunnel_host\n        return getattr(self, \"_tunnel_host\", None)\n\n    def _prepare_conn(self, conn):\n        self.sock = conn\n        if self._is_using_tunnel():\n            # TODO: Fix tunnel so it doesn't depend on self.sock state.\n            self._tunnel()\n            # Mark this connection as not reusable\n            self.auto_open = 0\n\n    def connect(self):\n        conn = self._new_conn()\n        self._prepare_conn(conn)\n\n    def putrequest(self, method, url, *args, **kwargs):\n        \"\"\" \"\"\"\n        # Empty docstring because the indentation of CPython's implementation\n        # is broken but we don't want this method in our documentation.\n        match = _CONTAINS_CONTROL_CHAR_RE.search(method)\n        if match:\n            raise ValueError(\n                \"Method cannot contain non-token characters %r (found at least %r)\"\n                % (method, match.group())\n            )\n\n        return _HTTPConnection.putrequest(self, method, url, *args, **kwargs)\n\n    def putheader(self, header, *values):\n        \"\"\" \"\"\"\n        if not any(isinstance(v, str) and v == SKIP_HEADER for v in values):\n            _HTTPConnection.putheader(self, header, *values)\n        elif six.ensure_str(header.lower()) not in SKIPPABLE_HEADERS:\n            raise ValueError(\n                \"urllib3.util.SKIP_HEADER only supports '%s'\"\n                % (\"', '\".join(map(str.title, sorted(SKIPPABLE_HEADERS))),)\n            )\n\n    def request(self, method, url, body=None, headers=None):\n        if headers is None:\n            headers = {}\n        else:\n            # Avoid modifying the headers passed into .request()\n            headers = headers.copy()\n        if \"user-agent\" not in (six.ensure_str(k.lower()) for k in headers):\n            headers[\"User-Agent\"] = _get_default_user_agent()\n        super(HTTPConnection, self).request(method, url, body=body, headers=headers)\n\n    def request_chunked(self, method, url, body=None, headers=None):\n        \"\"\"\n        Alternative to the common request method, which sends the\n        body with chunked encoding and not as one block\n        \"\"\"\n        headers = headers or {}\n        header_keys = set([six.ensure_str(k.lower()) for k in headers])\n        skip_accept_encoding = \"accept-encoding\" in header_keys\n        skip_host = \"host\" in header_keys\n        self.putrequest(\n            method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\n        )\n        if \"user-agent\" not in header_keys:\n            self.putheader(\"User-Agent\", _get_default_user_agent())\n        for header, value in headers.items():\n            self.putheader(header, value)\n        if \"transfer-encoding\" not in header_keys:\n            self.putheader(\"Transfer-Encoding\", \"chunked\")\n        self.endheaders()\n\n        if body is not None:\n            stringish_types = six.string_types + (bytes,)\n            if isinstance(body, stringish_types):\n                body = (body,)\n            for chunk in body:\n                if not chunk:\n                    continue\n                if not isinstance(chunk, bytes):\n                    chunk = chunk.encode(\"utf8\")\n                len_str = hex(len(chunk))[2:]\n                to_send = bytearray(len_str.encode())\n                to_send += b\"\\r\\n\"\n                to_send += chunk\n                to_send += b\"\\r\\n\"\n                self.send(to_send)\n\n        # After the if clause, to always have a closed body\n        self.send(b\"0\\r\\n\\r\\n\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connection.html#client.ayon_fusion.vendor.urllib3.connection.HTTPConnection.host","title":"<code>host</code>  <code>property</code> <code>writable</code>","text":"<p>Getter method to remove any trailing dots that indicate the hostname is an FQDN.</p> <p>In general, SSL certificates don't include the trailing dot indicating a fully-qualified domain name, and thus, they don't validate properly when checked against a domain name that includes the dot. In addition, some servers may not expect to receive the trailing dot when provided.</p> <p>However, the hostname with trailing dot is critical to DNS resolution; doing a lookup with the trailing dot will properly only resolve the appropriate FQDN, whereas a lookup without a trailing dot will search the system's search domain list. Thus, it's important to keep the original host around for use only in those cases where it's appropriate (i.e., when doing DNS lookup to establish the actual TCP connection across which we're going to send HTTP requests).</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connection.html#client.ayon_fusion.vendor.urllib3.connection.HTTPConnection.putheader","title":"<code>putheader(header, *values)</code>","text":"Source code in <code>client/ayon_fusion/vendor/urllib3/connection.py</code> <pre><code>def putheader(self, header, *values):\n    \"\"\" \"\"\"\n    if not any(isinstance(v, str) and v == SKIP_HEADER for v in values):\n        _HTTPConnection.putheader(self, header, *values)\n    elif six.ensure_str(header.lower()) not in SKIPPABLE_HEADERS:\n        raise ValueError(\n            \"urllib3.util.SKIP_HEADER only supports '%s'\"\n            % (\"', '\".join(map(str.title, sorted(SKIPPABLE_HEADERS))),)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connection.html#client.ayon_fusion.vendor.urllib3.connection.HTTPConnection.putrequest","title":"<code>putrequest(method, url, *args, **kwargs)</code>","text":"Source code in <code>client/ayon_fusion/vendor/urllib3/connection.py</code> <pre><code>def putrequest(self, method, url, *args, **kwargs):\n    \"\"\" \"\"\"\n    # Empty docstring because the indentation of CPython's implementation\n    # is broken but we don't want this method in our documentation.\n    match = _CONTAINS_CONTROL_CHAR_RE.search(method)\n    if match:\n        raise ValueError(\n            \"Method cannot contain non-token characters %r (found at least %r)\"\n            % (method, match.group())\n        )\n\n    return _HTTPConnection.putrequest(self, method, url, *args, **kwargs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connection.html#client.ayon_fusion.vendor.urllib3.connection.HTTPConnection.request_chunked","title":"<code>request_chunked(method, url, body=None, headers=None)</code>","text":"<p>Alternative to the common request method, which sends the body with chunked encoding and not as one block</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connection.py</code> <pre><code>def request_chunked(self, method, url, body=None, headers=None):\n    \"\"\"\n    Alternative to the common request method, which sends the\n    body with chunked encoding and not as one block\n    \"\"\"\n    headers = headers or {}\n    header_keys = set([six.ensure_str(k.lower()) for k in headers])\n    skip_accept_encoding = \"accept-encoding\" in header_keys\n    skip_host = \"host\" in header_keys\n    self.putrequest(\n        method, url, skip_accept_encoding=skip_accept_encoding, skip_host=skip_host\n    )\n    if \"user-agent\" not in header_keys:\n        self.putheader(\"User-Agent\", _get_default_user_agent())\n    for header, value in headers.items():\n        self.putheader(header, value)\n    if \"transfer-encoding\" not in header_keys:\n        self.putheader(\"Transfer-Encoding\", \"chunked\")\n    self.endheaders()\n\n    if body is not None:\n        stringish_types = six.string_types + (bytes,)\n        if isinstance(body, stringish_types):\n            body = (body,)\n        for chunk in body:\n            if not chunk:\n                continue\n            if not isinstance(chunk, bytes):\n                chunk = chunk.encode(\"utf8\")\n            len_str = hex(len(chunk))[2:]\n            to_send = bytearray(len_str.encode())\n            to_send += b\"\\r\\n\"\n            to_send += chunk\n            to_send += b\"\\r\\n\"\n            self.send(to_send)\n\n    # After the if clause, to always have a closed body\n    self.send(b\"0\\r\\n\\r\\n\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connection.html#client.ayon_fusion.vendor.urllib3.connection.HTTPSConnection","title":"<code>HTTPSConnection</code>","text":"<p>               Bases: <code>HTTPConnection</code></p> <p>Many of the parameters to this constructor are passed to the underlying SSL socket by means of :py:func:<code>urllib3.util.ssl_wrap_socket</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connection.py</code> <pre><code>class HTTPSConnection(HTTPConnection):\n    \"\"\"\n    Many of the parameters to this constructor are passed to the underlying SSL\n    socket by means of :py:func:`urllib3.util.ssl_wrap_socket`.\n    \"\"\"\n\n    default_port = port_by_scheme[\"https\"]\n\n    cert_reqs = None\n    ca_certs = None\n    ca_cert_dir = None\n    ca_cert_data = None\n    ssl_version = None\n    assert_fingerprint = None\n    tls_in_tls_required = False\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        key_file=None,\n        cert_file=None,\n        key_password=None,\n        strict=None,\n        timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n        ssl_context=None,\n        server_hostname=None,\n        **kw\n    ):\n\n        HTTPConnection.__init__(self, host, port, strict=strict, timeout=timeout, **kw)\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.key_password = key_password\n        self.ssl_context = ssl_context\n        self.server_hostname = server_hostname\n\n        # Required property for Google AppEngine 1.9.0 which otherwise causes\n        # HTTPS requests to go out as HTTP. (See Issue #356)\n        self._protocol = \"https\"\n\n    def set_cert(\n        self,\n        key_file=None,\n        cert_file=None,\n        cert_reqs=None,\n        key_password=None,\n        ca_certs=None,\n        assert_hostname=None,\n        assert_fingerprint=None,\n        ca_cert_dir=None,\n        ca_cert_data=None,\n    ):\n        \"\"\"\n        This method should only be called once, before the connection is used.\n        \"\"\"\n        # If cert_reqs is not provided we'll assume CERT_REQUIRED unless we also\n        # have an SSLContext object in which case we'll use its verify_mode.\n        if cert_reqs is None:\n            if self.ssl_context is not None:\n                cert_reqs = self.ssl_context.verify_mode\n            else:\n                cert_reqs = resolve_cert_reqs(None)\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.key_password = key_password\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n        self.ca_certs = ca_certs and os.path.expanduser(ca_certs)\n        self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)\n        self.ca_cert_data = ca_cert_data\n\n    def connect(self):\n        # Add certificate verification\n        conn = self._new_conn()\n        hostname = self.host\n        tls_in_tls = False\n\n        if self._is_using_tunnel():\n            if self.tls_in_tls_required:\n                conn = self._connect_tls_proxy(hostname, conn)\n                tls_in_tls = True\n\n            self.sock = conn\n\n            # Calls self._set_hostport(), so self.host is\n            # self._tunnel_host below.\n            self._tunnel()\n            # Mark this connection as not reusable\n            self.auto_open = 0\n\n            # Override the host with the one we're requesting data from.\n            hostname = self._tunnel_host\n\n        server_hostname = hostname\n        if self.server_hostname is not None:\n            server_hostname = self.server_hostname\n\n        is_time_off = datetime.date.today() &lt; RECENT_DATE\n        if is_time_off:\n            warnings.warn(\n                (\n                    \"System time is way off (before {0}). This will probably \"\n                    \"lead to SSL verification errors\"\n                ).format(RECENT_DATE),\n                SystemTimeWarning,\n            )\n\n        # Wrap socket using verification with the root certs in\n        # trusted_root_certs\n        default_ssl_context = False\n        if self.ssl_context is None:\n            default_ssl_context = True\n            self.ssl_context = create_urllib3_context(\n                ssl_version=resolve_ssl_version(self.ssl_version),\n                cert_reqs=resolve_cert_reqs(self.cert_reqs),\n            )\n\n        context = self.ssl_context\n        context.verify_mode = resolve_cert_reqs(self.cert_reqs)\n\n        # Try to load OS default certs if none are given.\n        # Works well on Windows (requires Python3.4+)\n        if (\n            not self.ca_certs\n            and not self.ca_cert_dir\n            and not self.ca_cert_data\n            and default_ssl_context\n            and hasattr(context, \"load_default_certs\")\n        ):\n            context.load_default_certs()\n\n        self.sock = ssl_wrap_socket(\n            sock=conn,\n            keyfile=self.key_file,\n            certfile=self.cert_file,\n            key_password=self.key_password,\n            ca_certs=self.ca_certs,\n            ca_cert_dir=self.ca_cert_dir,\n            ca_cert_data=self.ca_cert_data,\n            server_hostname=server_hostname,\n            ssl_context=context,\n            tls_in_tls=tls_in_tls,\n        )\n\n        # If we're using all defaults and the connection\n        # is TLSv1 or TLSv1.1 we throw a DeprecationWarning\n        # for the host.\n        if (\n            default_ssl_context\n            and self.ssl_version is None\n            and hasattr(self.sock, \"version\")\n            and self.sock.version() in {\"TLSv1\", \"TLSv1.1\"}\n        ):\n            warnings.warn(\n                \"Negotiating TLSv1/TLSv1.1 by default is deprecated \"\n                \"and will be disabled in urllib3 v2.0.0. Connecting to \"\n                \"'%s' with '%s' can be enabled by explicitly opting-in \"\n                \"with 'ssl_version'\" % (self.host, self.sock.version()),\n                DeprecationWarning,\n            )\n\n        if self.assert_fingerprint:\n            assert_fingerprint(\n                self.sock.getpeercert(binary_form=True), self.assert_fingerprint\n            )\n        elif (\n            context.verify_mode != ssl.CERT_NONE\n            and not getattr(context, \"check_hostname\", False)\n            and self.assert_hostname is not False\n        ):\n            # While urllib3 attempts to always turn off hostname matching from\n            # the TLS library, this cannot always be done. So we check whether\n            # the TLS Library still thinks it's matching hostnames.\n            cert = self.sock.getpeercert()\n            if not cert.get(\"subjectAltName\", ()):\n                warnings.warn(\n                    (\n                        \"Certificate for {0} has no `subjectAltName`, falling back to check for a \"\n                        \"`commonName` for now. This feature is being removed by major browsers and \"\n                        \"deprecated by RFC 2818. (See https://github.com/urllib3/urllib3/issues/497 \"\n                        \"for details.)\".format(hostname)\n                    ),\n                    SubjectAltNameWarning,\n                )\n            _match_hostname(cert, self.assert_hostname or server_hostname)\n\n        self.is_verified = (\n            context.verify_mode == ssl.CERT_REQUIRED\n            or self.assert_fingerprint is not None\n        )\n\n    def _connect_tls_proxy(self, hostname, conn):\n        \"\"\"\n        Establish a TLS connection to the proxy using the provided SSL context.\n        \"\"\"\n        proxy_config = self.proxy_config\n        ssl_context = proxy_config.ssl_context\n        if ssl_context:\n            # If the user provided a proxy context, we assume CA and client\n            # certificates have already been set\n            return ssl_wrap_socket(\n                sock=conn,\n                server_hostname=hostname,\n                ssl_context=ssl_context,\n            )\n\n        ssl_context = create_proxy_ssl_context(\n            self.ssl_version,\n            self.cert_reqs,\n            self.ca_certs,\n            self.ca_cert_dir,\n            self.ca_cert_data,\n        )\n        # By default urllib3's SSLContext disables `check_hostname` and uses\n        # a custom check. For proxies we're good with relying on the default\n        # verification.\n        ssl_context.check_hostname = True\n\n        # If no cert was provided, use only the default options for server\n        # certificate validation\n        return ssl_wrap_socket(\n            sock=conn,\n            ca_certs=self.ca_certs,\n            ca_cert_dir=self.ca_cert_dir,\n            ca_cert_data=self.ca_cert_data,\n            server_hostname=hostname,\n            ssl_context=ssl_context,\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connection.html#client.ayon_fusion.vendor.urllib3.connection.HTTPSConnection.set_cert","title":"<code>set_cert(key_file=None, cert_file=None, cert_reqs=None, key_password=None, ca_certs=None, assert_hostname=None, assert_fingerprint=None, ca_cert_dir=None, ca_cert_data=None)</code>","text":"<p>This method should only be called once, before the connection is used.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connection.py</code> <pre><code>def set_cert(\n    self,\n    key_file=None,\n    cert_file=None,\n    cert_reqs=None,\n    key_password=None,\n    ca_certs=None,\n    assert_hostname=None,\n    assert_fingerprint=None,\n    ca_cert_dir=None,\n    ca_cert_data=None,\n):\n    \"\"\"\n    This method should only be called once, before the connection is used.\n    \"\"\"\n    # If cert_reqs is not provided we'll assume CERT_REQUIRED unless we also\n    # have an SSLContext object in which case we'll use its verify_mode.\n    if cert_reqs is None:\n        if self.ssl_context is not None:\n            cert_reqs = self.ssl_context.verify_mode\n        else:\n            cert_reqs = resolve_cert_reqs(None)\n\n    self.key_file = key_file\n    self.cert_file = cert_file\n    self.cert_reqs = cert_reqs\n    self.key_password = key_password\n    self.assert_hostname = assert_hostname\n    self.assert_fingerprint = assert_fingerprint\n    self.ca_certs = ca_certs and os.path.expanduser(ca_certs)\n    self.ca_cert_dir = ca_cert_dir and os.path.expanduser(ca_cert_dir)\n    self.ca_cert_data = ca_cert_data\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connectionpool.html","title":"connectionpool","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connectionpool.html#client.ayon_fusion.vendor.urllib3.connectionpool.ConnectionPool","title":"<code>ConnectionPool</code>","text":"<p>               Bases: <code>object</code></p> <p>Base class for all connection pools, such as :class:<code>.HTTPConnectionPool</code> and :class:<code>.HTTPSConnectionPool</code>.</p> <p>.. note::    ConnectionPool.urlopen() does not normalize or percent-encode target URIs    which is useful if your target server doesn't support percent-encoded    target URIs.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>class ConnectionPool(object):\n    \"\"\"\n    Base class for all connection pools, such as\n    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.\n\n    .. note::\n       ConnectionPool.urlopen() does not normalize or percent-encode target URIs\n       which is useful if your target server doesn't support percent-encoded\n       target URIs.\n    \"\"\"\n\n    scheme = None\n    QueueCls = LifoQueue\n\n    def __init__(self, host, port=None):\n        if not host:\n            raise LocationValueError(\"No host specified.\")\n\n        self.host = _normalize_host(host, scheme=self.scheme)\n        self._proxy_host = host.lower()\n        self.port = port\n\n    def __str__(self):\n        return \"%s(host=%r, port=%r)\" % (type(self).__name__, self.host, self.port)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.close()\n        # Return False to re-raise any potential exceptions\n        return False\n\n    def close(self):\n        \"\"\"\n        Close all pooled connections and disable the pool.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connectionpool.html#client.ayon_fusion.vendor.urllib3.connectionpool.ConnectionPool.close","title":"<code>close()</code>","text":"<p>Close all pooled connections and disable the pool.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close all pooled connections and disable the pool.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connectionpool.html#client.ayon_fusion.vendor.urllib3.connectionpool.HTTPConnectionPool","title":"<code>HTTPConnectionPool</code>","text":"<p>               Bases: <code>ConnectionPool</code>, <code>RequestMethods</code></p> <p>Thread-safe connection pool for one host.</p> <p>:param host:     Host used for this HTTP Connection (e.g. \"localhost\"), passed into     :class:<code>http.client.HTTPConnection</code>.</p> <p>:param port:     Port used for this HTTP Connection (None is equivalent to 80), passed     into :class:<code>http.client.HTTPConnection</code>.</p> <p>:param strict:     Causes BadStatusLine to be raised if the status line can't be parsed     as a valid HTTP/1.0 or 1.1 status line, passed into     :class:<code>http.client.HTTPConnection</code>.</p> <pre><code>.. note::\n   Only works in Python 2. This parameter is ignored in Python 3.\n</code></pre> <p>:param timeout:     Socket timeout in seconds for each individual connection. This can     be a float or integer, which sets the timeout for the HTTP request,     or an instance of :class:<code>urllib3.util.Timeout</code> which gives you more     fine-grained control over request timeouts. After the constructor has     been parsed, this is always a <code>urllib3.util.Timeout</code> object.</p> <p>:param maxsize:     Number of connections to save that can be reused. More than 1 is useful     in multithreaded situations. If <code>block</code> is set to False, more     connections will be created but they will not be saved once they've     been used.</p> <p>:param block:     If set to True, no more than <code>maxsize</code> connections will be used at     a time. When no free connections are available, the call will block     until a connection has been released. This is a useful side effect for     particular multithreaded situations where one does not want to use more     than maxsize connections per host to prevent flooding.</p> <p>:param headers:     Headers to include with all requests, unless other headers are given     explicitly.</p> <p>:param retries:     Retry configuration to use by default with requests in this pool.</p> <p>:param _proxy:     Parsed proxy URL, should not be used directly, instead, see     :class:<code>urllib3.ProxyManager</code></p> <p>:param _proxy_headers:     A dictionary with proxy headers, should not be used directly,     instead, see :class:<code>urllib3.ProxyManager</code></p> <p>:param **conn_kw:     Additional parameters are used to create fresh :class:<code>urllib3.connection.HTTPConnection</code>,     :class:<code>urllib3.connection.HTTPSConnection</code> instances.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>class HTTPConnectionPool(ConnectionPool, RequestMethods):\n    \"\"\"\n    Thread-safe connection pool for one host.\n\n    :param host:\n        Host used for this HTTP Connection (e.g. \"localhost\"), passed into\n        :class:`http.client.HTTPConnection`.\n\n    :param port:\n        Port used for this HTTP Connection (None is equivalent to 80), passed\n        into :class:`http.client.HTTPConnection`.\n\n    :param strict:\n        Causes BadStatusLine to be raised if the status line can't be parsed\n        as a valid HTTP/1.0 or 1.1 status line, passed into\n        :class:`http.client.HTTPConnection`.\n\n        .. note::\n           Only works in Python 2. This parameter is ignored in Python 3.\n\n    :param timeout:\n        Socket timeout in seconds for each individual connection. This can\n        be a float or integer, which sets the timeout for the HTTP request,\n        or an instance of :class:`urllib3.util.Timeout` which gives you more\n        fine-grained control over request timeouts. After the constructor has\n        been parsed, this is always a `urllib3.util.Timeout` object.\n\n    :param maxsize:\n        Number of connections to save that can be reused. More than 1 is useful\n        in multithreaded situations. If ``block`` is set to False, more\n        connections will be created but they will not be saved once they've\n        been used.\n\n    :param block:\n        If set to True, no more than ``maxsize`` connections will be used at\n        a time. When no free connections are available, the call will block\n        until a connection has been released. This is a useful side effect for\n        particular multithreaded situations where one does not want to use more\n        than maxsize connections per host to prevent flooding.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param retries:\n        Retry configuration to use by default with requests in this pool.\n\n    :param _proxy:\n        Parsed proxy URL, should not be used directly, instead, see\n        :class:`urllib3.ProxyManager`\n\n    :param _proxy_headers:\n        A dictionary with proxy headers, should not be used directly,\n        instead, see :class:`urllib3.ProxyManager`\n\n    :param \\\\**conn_kw:\n        Additional parameters are used to create fresh :class:`urllib3.connection.HTTPConnection`,\n        :class:`urllib3.connection.HTTPSConnection` instances.\n    \"\"\"\n\n    scheme = \"http\"\n    ConnectionCls = HTTPConnection\n    ResponseCls = HTTPResponse\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        strict=False,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        _proxy_config=None,\n        **conn_kw\n    ):\n        ConnectionPool.__init__(self, host, port)\n        RequestMethods.__init__(self, headers)\n\n        self.strict = strict\n\n        if not isinstance(timeout, Timeout):\n            timeout = Timeout.from_float(timeout)\n\n        if retries is None:\n            retries = Retry.DEFAULT\n\n        self.timeout = timeout\n        self.retries = retries\n\n        self.pool = self.QueueCls(maxsize)\n        self.block = block\n\n        self.proxy = _proxy\n        self.proxy_headers = _proxy_headers or {}\n        self.proxy_config = _proxy_config\n\n        # Fill the queue up so that doing get() on it will block properly\n        for _ in xrange(maxsize):\n            self.pool.put(None)\n\n        # These are mostly for testing and debugging purposes.\n        self.num_connections = 0\n        self.num_requests = 0\n        self.conn_kw = conn_kw\n\n        if self.proxy:\n            # Enable Nagle's algorithm for proxies, to avoid packet fragmentation.\n            # We cannot know if the user has added default socket options, so we cannot replace the\n            # list.\n            self.conn_kw.setdefault(\"socket_options\", [])\n\n            self.conn_kw[\"proxy\"] = self.proxy\n            self.conn_kw[\"proxy_config\"] = self.proxy_config\n\n    def _new_conn(self):\n        \"\"\"\n        Return a fresh :class:`HTTPConnection`.\n        \"\"\"\n        self.num_connections += 1\n        log.debug(\n            \"Starting new HTTP connection (%d): %s:%s\",\n            self.num_connections,\n            self.host,\n            self.port or \"80\",\n        )\n\n        conn = self.ConnectionCls(\n            host=self.host,\n            port=self.port,\n            timeout=self.timeout.connect_timeout,\n            strict=self.strict,\n            **self.conn_kw\n        )\n        return conn\n\n    def _get_conn(self, timeout=None):\n        \"\"\"\n        Get a connection. Will return a pooled connection if one is available.\n\n        If no connections are available and :prop:`.block` is ``False``, then a\n        fresh connection is returned.\n\n        :param timeout:\n            Seconds to wait before giving up and raising\n            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and\n            :prop:`.block` is ``True``.\n        \"\"\"\n        conn = None\n        try:\n            conn = self.pool.get(block=self.block, timeout=timeout)\n\n        except AttributeError:  # self.pool is None\n            raise ClosedPoolError(self, \"Pool is closed.\")\n\n        except queue.Empty:\n            if self.block:\n                raise EmptyPoolError(\n                    self,\n                    \"Pool reached maximum size and no more connections are allowed.\",\n                )\n            pass  # Oh well, we'll create a new connection then\n\n        # If this is a persistent connection, check if it got disconnected\n        if conn and is_connection_dropped(conn):\n            log.debug(\"Resetting dropped connection: %s\", self.host)\n            conn.close()\n            if getattr(conn, \"auto_open\", 1) == 0:\n                # This is a proxied connection that has been mutated by\n                # http.client._tunnel() and cannot be reused (since it would\n                # attempt to bypass the proxy)\n                conn = None\n\n        return conn or self._new_conn()\n\n    def _put_conn(self, conn):\n        \"\"\"\n        Put a connection back into the pool.\n\n        :param conn:\n            Connection object for the current host and port as returned by\n            :meth:`._new_conn` or :meth:`._get_conn`.\n\n        If the pool is already full, the connection is closed and discarded\n        because we exceeded maxsize. If connections are discarded frequently,\n        then maxsize should be increased.\n\n        If the pool is closed, then the connection will be closed and discarded.\n        \"\"\"\n        try:\n            self.pool.put(conn, block=False)\n            return  # Everything is dandy, done.\n        except AttributeError:\n            # self.pool is None.\n            pass\n        except queue.Full:\n            # This should never happen if self.block == True\n            log.warning(\"Connection pool is full, discarding connection: %s\", self.host)\n\n        # Connection never got put back into the pool, close it.\n        if conn:\n            conn.close()\n\n    def _validate_conn(self, conn):\n        \"\"\"\n        Called right before a request is made, after the socket is created.\n        \"\"\"\n        pass\n\n    def _prepare_proxy(self, conn):\n        # Nothing to do for HTTP connections.\n        pass\n\n    def _get_timeout(self, timeout):\n        \"\"\"Helper that always returns a :class:`urllib3.util.Timeout`\"\"\"\n        if timeout is _Default:\n            return self.timeout.clone()\n\n        if isinstance(timeout, Timeout):\n            return timeout.clone()\n        else:\n            # User passed us an int/float. This is for backwards compatibility,\n            # can be removed later\n            return Timeout.from_float(timeout)\n\n    def _raise_timeout(self, err, url, timeout_value):\n        \"\"\"Is the error actually a timeout? Will raise a ReadTimeout or pass\"\"\"\n\n        if isinstance(err, SocketTimeout):\n            raise ReadTimeoutError(\n                self, url, \"Read timed out. (read timeout=%s)\" % timeout_value\n            )\n\n        # See the above comment about EAGAIN in Python 3. In Python 2 we have\n        # to specifically catch it and throw the timeout error\n        if hasattr(err, \"errno\") and err.errno in _blocking_errnos:\n            raise ReadTimeoutError(\n                self, url, \"Read timed out. (read timeout=%s)\" % timeout_value\n            )\n\n        # Catch possible read timeouts thrown as SSL errors. If not the\n        # case, rethrow the original. We need to do this because of:\n        # http://bugs.python.org/issue10272\n        if \"timed out\" in str(err) or \"did not complete (read)\" in str(\n            err\n        ):  # Python &lt; 2.7.4\n            raise ReadTimeoutError(\n                self, url, \"Read timed out. (read timeout=%s)\" % timeout_value\n            )\n\n    def _make_request(\n        self, conn, method, url, timeout=_Default, chunked=False, **httplib_request_kw\n    ):\n        \"\"\"\n        Perform a request on a given urllib connection object taken from our\n        pool.\n\n        :param conn:\n            a connection from one of our connection pools\n\n        :param timeout:\n            Socket timeout in seconds for the request. This can be a\n            float or integer, which will set the same timeout value for\n            the socket connect and the socket read, or an instance of\n            :class:`urllib3.util.Timeout`, which gives you more fine-grained\n            control over your timeouts.\n        \"\"\"\n        self.num_requests += 1\n\n        timeout_obj = self._get_timeout(timeout)\n        timeout_obj.start_connect()\n        conn.timeout = timeout_obj.connect_timeout\n\n        # Trigger any extra validation we need to do.\n        try:\n            self._validate_conn(conn)\n        except (SocketTimeout, BaseSSLError) as e:\n            # Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.\n            self._raise_timeout(err=e, url=url, timeout_value=conn.timeout)\n            raise\n\n        # conn.request() calls http.client.*.request, not the method in\n        # urllib3.request. It also calls makefile (recv) on the socket.\n        try:\n            if chunked:\n                conn.request_chunked(method, url, **httplib_request_kw)\n            else:\n                conn.request(method, url, **httplib_request_kw)\n\n        # We are swallowing BrokenPipeError (errno.EPIPE) since the server is\n        # legitimately able to close the connection after sending a valid response.\n        # With this behaviour, the received response is still readable.\n        except BrokenPipeError:\n            # Python 3\n            pass\n        except IOError as e:\n            # Python 2 and macOS/Linux\n            # EPIPE and ESHUTDOWN are BrokenPipeError on Python 2, and EPROTOTYPE is needed on macOS\n            # https://erickt.github.io/blog/2014/11/19/adventures-in-debugging-a-potential-osx-kernel-bug/\n            if e.errno not in {\n                errno.EPIPE,\n                errno.ESHUTDOWN,\n                errno.EPROTOTYPE,\n            }:\n                raise\n\n        # Reset the timeout for the recv() on the socket\n        read_timeout = timeout_obj.read_timeout\n\n        # App Engine doesn't have a sock attr\n        if getattr(conn, \"sock\", None):\n            # In Python 3 socket.py will catch EAGAIN and return None when you\n            # try and read into the file pointer created by http.client, which\n            # instead raises a BadStatusLine exception. Instead of catching\n            # the exception and assuming all BadStatusLine exceptions are read\n            # timeouts, check for a zero timeout before making the request.\n            if read_timeout == 0:\n                raise ReadTimeoutError(\n                    self, url, \"Read timed out. (read timeout=%s)\" % read_timeout\n                )\n            if read_timeout is Timeout.DEFAULT_TIMEOUT:\n                conn.sock.settimeout(socket.getdefaulttimeout())\n            else:  # None or a value\n                conn.sock.settimeout(read_timeout)\n\n        # Receive the response from the server\n        try:\n            try:\n                # Python 2.7, use buffering of HTTP responses\n                httplib_response = conn.getresponse(buffering=True)\n            except TypeError:\n                # Python 3\n                try:\n                    httplib_response = conn.getresponse()\n                except BaseException as e:\n                    # Remove the TypeError from the exception chain in\n                    # Python 3 (including for exceptions like SystemExit).\n                    # Otherwise it looks like a bug in the code.\n                    six.raise_from(e, None)\n        except (SocketTimeout, BaseSSLError, SocketError) as e:\n            self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n            raise\n\n        # AppEngine doesn't have a version attr.\n        http_version = getattr(conn, \"_http_vsn_str\", \"HTTP/?\")\n        log.debug(\n            '%s://%s:%s \"%s %s %s\" %s %s',\n            self.scheme,\n            self.host,\n            self.port,\n            method,\n            url,\n            http_version,\n            httplib_response.status,\n            httplib_response.length,\n        )\n\n        try:\n            assert_header_parsing(httplib_response.msg)\n        except (HeaderParsingError, TypeError) as hpe:  # Platform-specific: Python 3\n            log.warning(\n                \"Failed to parse headers (url=%s): %s\",\n                self._absolute_url(url),\n                hpe,\n                exc_info=True,\n            )\n\n        return httplib_response\n\n    def _absolute_url(self, path):\n        return Url(scheme=self.scheme, host=self.host, port=self.port, path=path).url\n\n    def close(self):\n        \"\"\"\n        Close all pooled connections and disable the pool.\n        \"\"\"\n        if self.pool is None:\n            return\n        # Disable access to the pool\n        old_pool, self.pool = self.pool, None\n\n        try:\n            while True:\n                conn = old_pool.get(block=False)\n                if conn:\n                    conn.close()\n\n        except queue.Empty:\n            pass  # Done.\n\n    def is_same_host(self, url):\n        \"\"\"\n        Check if the given ``url`` is a member of the same host as this\n        connection pool.\n        \"\"\"\n        if url.startswith(\"/\"):\n            return True\n\n        # TODO: Add optional support for socket.gethostbyname checking.\n        scheme, host, port = get_host(url)\n        if host is not None:\n            host = _normalize_host(host, scheme=scheme)\n\n        # Use explicit default port for comparison when none is given\n        if self.port and not port:\n            port = port_by_scheme.get(scheme)\n        elif not self.port and port == port_by_scheme.get(scheme):\n            port = None\n\n        return (scheme, host, port) == (self.scheme, self.host, self.port)\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        assert_same_host=True,\n        timeout=_Default,\n        pool_timeout=None,\n        release_conn=None,\n        chunked=False,\n        body_pos=None,\n        **response_kw\n    ):\n        \"\"\"\n        Get a connection from the pool and perform an HTTP request. This is the\n        lowest level call for making a request, so you'll need to specify all\n        the raw details.\n\n        .. note::\n\n           More commonly, it's appropriate to use a convenience method provided\n           by :class:`.RequestMethods`, such as :meth:`request`.\n\n        .. note::\n\n           `release_conn` will only behave as expected if\n           `preload_content=False` because we want to make\n           `preload_content=False` the default behaviour someday soon without\n           breaking backwards compatibility.\n\n        :param method:\n            HTTP request method (such as GET, POST, PUT, etc.)\n\n        :param url:\n            The URL to perform the request on.\n\n        :param body:\n            Data to send in the request body, either :class:`str`, :class:`bytes`,\n            an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n        :param headers:\n            Dictionary of custom headers to send, such as User-Agent,\n            If-None-Match, etc. If None, pool headers are used. If provided,\n            these headers completely replace any pool-specific headers.\n\n        :param retries:\n            Configure the number of retries to allow before raising a\n            :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n            Pass ``None`` to retry until you receive a response. Pass a\n            :class:`~urllib3.util.retry.Retry` object for fine-grained control\n            over different types of retries.\n            Pass an integer number to retry connection errors that many times,\n            but no other types of errors. Pass zero to never retry.\n\n            If ``False``, then retries are disabled and any exception is raised\n            immediately. Also, instead of raising a MaxRetryError on redirects,\n            the redirect response will be returned.\n\n        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n        :param redirect:\n            If True, automatically handle redirects (status codes 301, 302,\n            303, 307, 308). Each redirect counts as a retry. Disabling retries\n            will disable redirect, too.\n\n        :param assert_same_host:\n            If ``True``, will make sure that the host of the pool requests is\n            consistent else will raise HostChangedError. When ``False``, you can\n            use the pool on an HTTP proxy and request foreign hosts.\n\n        :param timeout:\n            If specified, overrides the default timeout for this one\n            request. It may be a float (in seconds) or an instance of\n            :class:`urllib3.util.Timeout`.\n\n        :param pool_timeout:\n            If set and the pool is set to block=True, then this method will\n            block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n            connection is available within the time period.\n\n        :param release_conn:\n            If False, then the urlopen call will not release the connection\n            back into the pool once a response is received (but will release if\n            you read the entire contents of the response such as when\n            `preload_content=True`). This is useful if you're not preloading\n            the response's content immediately. You will need to call\n            ``r.release_conn()`` on the response ``r`` to return the connection\n            back into the pool. If None, it takes the value of\n            ``response_kw.get('preload_content', True)``.\n\n        :param chunked:\n            If True, urllib3 will send the body using chunked transfer\n            encoding. Otherwise, urllib3 will send the body using the standard\n            content-length form. Defaults to False.\n\n        :param int body_pos:\n            Position to seek to in file-like body in the event of a retry or\n            redirect. Typically this won't need to be set because urllib3 will\n            auto-populate the value when needed.\n\n        :param \\\\**response_kw:\n            Additional parameters are passed to\n            :meth:`urllib3.response.HTTPResponse.from_httplib`\n        \"\"\"\n\n        parsed_url = parse_url(url)\n        destination_scheme = parsed_url.scheme\n\n        if headers is None:\n            headers = self.headers\n\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n        if release_conn is None:\n            release_conn = response_kw.get(\"preload_content\", True)\n\n        # Check host\n        if assert_same_host and not self.is_same_host(url):\n            raise HostChangedError(self, url, retries)\n\n        # Ensure that the URL we're connecting to is properly encoded\n        if url.startswith(\"/\"):\n            url = six.ensure_str(_encode_target(url))\n        else:\n            url = six.ensure_str(parsed_url.url)\n\n        conn = None\n\n        # Track whether `conn` needs to be released before\n        # returning/raising/recursing. Update this variable if necessary, and\n        # leave `release_conn` constant throughout the function. That way, if\n        # the function recurses, the original value of `release_conn` will be\n        # passed down into the recursive call, and its value will be respected.\n        #\n        # See issue #651 [1] for details.\n        #\n        # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\n        release_this_conn = release_conn\n\n        http_tunnel_required = connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, destination_scheme\n        )\n\n        # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n        # have to copy the headers dict so we can safely change it without those\n        # changes being reflected in anyone else's copy.\n        if not http_tunnel_required:\n            headers = headers.copy()\n            headers.update(self.proxy_headers)\n\n        # Must keep the exception bound to a separate variable or else Python 3\n        # complains about UnboundLocalError.\n        err = None\n\n        # Keep track of whether we cleanly exited the except block. This\n        # ensures we do proper cleanup in finally.\n        clean_exit = False\n\n        # Rewind body position, if needed. Record current position\n        # for future rewinds in the event of a redirect/retry.\n        body_pos = set_file_position(body, body_pos)\n\n        try:\n            # Request a connection from the queue.\n            timeout_obj = self._get_timeout(timeout)\n            conn = self._get_conn(timeout=pool_timeout)\n\n            conn.timeout = timeout_obj.connect_timeout\n\n            is_new_proxy_conn = self.proxy is not None and not getattr(\n                conn, \"sock\", None\n            )\n            if is_new_proxy_conn and http_tunnel_required:\n                self._prepare_proxy(conn)\n\n            # Make the request on the httplib connection object.\n            httplib_response = self._make_request(\n                conn,\n                method,\n                url,\n                timeout=timeout_obj,\n                body=body,\n                headers=headers,\n                chunked=chunked,\n            )\n\n            # If we're going to release the connection in ``finally:``, then\n            # the response doesn't need to know about the connection. Otherwise\n            # it will also try to release it and we'll have a double-release\n            # mess.\n            response_conn = conn if not release_conn else None\n\n            # Pass method to Response for length checking\n            response_kw[\"request_method\"] = method\n\n            # Import httplib's response into our own wrapper object\n            response = self.ResponseCls.from_httplib(\n                httplib_response,\n                pool=self,\n                connection=response_conn,\n                retries=retries,\n                **response_kw\n            )\n\n            # Everything went great!\n            clean_exit = True\n\n        except EmptyPoolError:\n            # Didn't get a connection from the pool, no need to clean up\n            clean_exit = True\n            release_this_conn = False\n            raise\n\n        except (\n            TimeoutError,\n            HTTPException,\n            SocketError,\n            ProtocolError,\n            BaseSSLError,\n            SSLError,\n            CertificateError,\n        ) as e:\n            # Discard the connection for these exceptions. It will be\n            # replaced during the next _get_conn() call.\n            clean_exit = False\n            if isinstance(e, (BaseSSLError, CertificateError)):\n                e = SSLError(e)\n            elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:\n                e = ProxyError(\"Cannot connect to proxy.\", e)\n            elif isinstance(e, (SocketError, HTTPException)):\n                e = ProtocolError(\"Connection aborted.\", e)\n\n            retries = retries.increment(\n                method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]\n            )\n            retries.sleep()\n\n            # Keep track of the error for the retry warning.\n            err = e\n\n        finally:\n            if not clean_exit:\n                # We hit some kind of exception, handled or otherwise. We need\n                # to throw the connection away unless explicitly told not to.\n                # Close the connection, set the variable to None, and make sure\n                # we put the None back in the pool to avoid leaking it.\n                conn = conn and conn.close()\n                release_this_conn = True\n\n            if release_this_conn:\n                # Put the connection back to be reused. If the connection is\n                # expired then it will be None, which will get replaced with a\n                # fresh connection during _get_conn.\n                self._put_conn(conn)\n\n        if not conn:\n            # Try again\n            log.warning(\n                \"Retrying (%r) after connection broken by '%r': %s\", retries, err, url\n            )\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries,\n                redirect,\n                assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                **response_kw\n            )\n\n        # Handle redirect?\n        redirect_location = redirect and response.get_redirect_location()\n        if redirect_location:\n            if response.status == 303:\n                method = \"GET\"\n\n            try:\n                retries = retries.increment(method, url, response=response, _pool=self)\n            except MaxRetryError:\n                if retries.raise_on_redirect:\n                    response.drain_conn()\n                    raise\n                return response\n\n            response.drain_conn()\n            retries.sleep_for_retry(response)\n            log.debug(\"Redirecting %s -&gt; %s\", url, redirect_location)\n            return self.urlopen(\n                method,\n                redirect_location,\n                body,\n                headers,\n                retries=retries,\n                redirect=redirect,\n                assert_same_host=assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                **response_kw\n            )\n\n        # Check if we should retry the HTTP response.\n        has_retry_after = bool(response.getheader(\"Retry-After\"))\n        if retries.is_retry(method, response.status, has_retry_after):\n            try:\n                retries = retries.increment(method, url, response=response, _pool=self)\n            except MaxRetryError:\n                if retries.raise_on_status:\n                    response.drain_conn()\n                    raise\n                return response\n\n            response.drain_conn()\n            retries.sleep(response)\n            log.debug(\"Retry: %s\", url)\n            return self.urlopen(\n                method,\n                url,\n                body,\n                headers,\n                retries=retries,\n                redirect=redirect,\n                assert_same_host=assert_same_host,\n                timeout=timeout,\n                pool_timeout=pool_timeout,\n                release_conn=release_conn,\n                chunked=chunked,\n                body_pos=body_pos,\n                **response_kw\n            )\n\n        return response\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connectionpool.html#client.ayon_fusion.vendor.urllib3.connectionpool.HTTPConnectionPool.close","title":"<code>close()</code>","text":"<p>Close all pooled connections and disable the pool.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>def close(self):\n    \"\"\"\n    Close all pooled connections and disable the pool.\n    \"\"\"\n    if self.pool is None:\n        return\n    # Disable access to the pool\n    old_pool, self.pool = self.pool, None\n\n    try:\n        while True:\n            conn = old_pool.get(block=False)\n            if conn:\n                conn.close()\n\n    except queue.Empty:\n        pass  # Done.\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connectionpool.html#client.ayon_fusion.vendor.urllib3.connectionpool.HTTPConnectionPool.is_same_host","title":"<code>is_same_host(url)</code>","text":"<p>Check if the given <code>url</code> is a member of the same host as this connection pool.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>def is_same_host(self, url):\n    \"\"\"\n    Check if the given ``url`` is a member of the same host as this\n    connection pool.\n    \"\"\"\n    if url.startswith(\"/\"):\n        return True\n\n    # TODO: Add optional support for socket.gethostbyname checking.\n    scheme, host, port = get_host(url)\n    if host is not None:\n        host = _normalize_host(host, scheme=scheme)\n\n    # Use explicit default port for comparison when none is given\n    if self.port and not port:\n        port = port_by_scheme.get(scheme)\n    elif not self.port and port == port_by_scheme.get(scheme):\n        port = None\n\n    return (scheme, host, port) == (self.scheme, self.host, self.port)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connectionpool.html#client.ayon_fusion.vendor.urllib3.connectionpool.HTTPConnectionPool.urlopen","title":"<code>urlopen(method, url, body=None, headers=None, retries=None, redirect=True, assert_same_host=True, timeout=_Default, pool_timeout=None, release_conn=None, chunked=False, body_pos=None, **response_kw)</code>","text":"<p>Get a connection from the pool and perform an HTTP request. This is the lowest level call for making a request, so you'll need to specify all the raw details.</p> <p>.. note::</p> <p>More commonly, it's appropriate to use a convenience method provided    by :class:<code>.RequestMethods</code>, such as :meth:<code>request</code>.</p> <p>.. note::</p> <p><code>release_conn</code> will only behave as expected if    <code>preload_content=False</code> because we want to make    <code>preload_content=False</code> the default behaviour someday soon without    breaking backwards compatibility.</p> <p>:param method:     HTTP request method (such as GET, POST, PUT, etc.)</p> <p>:param url:     The URL to perform the request on.</p> <p>:param body:     Data to send in the request body, either :class:<code>str</code>, :class:<code>bytes</code>,     an iterable of :class:<code>str</code>/:class:<code>bytes</code>, or a file-like object.</p> <p>:param headers:     Dictionary of custom headers to send, such as User-Agent,     If-None-Match, etc. If None, pool headers are used. If provided,     these headers completely replace any pool-specific headers.</p> <p>:param retries:     Configure the number of retries to allow before raising a     :class:<code>~urllib3.exceptions.MaxRetryError</code> exception.</p> <pre><code>Pass ``None`` to retry until you receive a response. Pass a\n:class:`~urllib3.util.retry.Retry` object for fine-grained control\nover different types of retries.\nPass an integer number to retry connection errors that many times,\nbut no other types of errors. Pass zero to never retry.\n\nIf ``False``, then retries are disabled and any exception is raised\nimmediately. Also, instead of raising a MaxRetryError on redirects,\nthe redirect response will be returned.\n</code></pre> <p>:type retries: :class:<code>~urllib3.util.retry.Retry</code>, False, or an int.</p> <p>:param redirect:     If True, automatically handle redirects (status codes 301, 302,     303, 307, 308). Each redirect counts as a retry. Disabling retries     will disable redirect, too.</p> <p>:param assert_same_host:     If <code>True</code>, will make sure that the host of the pool requests is     consistent else will raise HostChangedError. When <code>False</code>, you can     use the pool on an HTTP proxy and request foreign hosts.</p> <p>:param timeout:     If specified, overrides the default timeout for this one     request. It may be a float (in seconds) or an instance of     :class:<code>urllib3.util.Timeout</code>.</p> <p>:param pool_timeout:     If set and the pool is set to block=True, then this method will     block for <code>pool_timeout</code> seconds and raise EmptyPoolError if no     connection is available within the time period.</p> <p>:param release_conn:     If False, then the urlopen call will not release the connection     back into the pool once a response is received (but will release if     you read the entire contents of the response such as when     <code>preload_content=True</code>). This is useful if you're not preloading     the response's content immediately. You will need to call     <code>r.release_conn()</code> on the response <code>r</code> to return the connection     back into the pool. If None, it takes the value of     <code>response_kw.get('preload_content', True)</code>.</p> <p>:param chunked:     If True, urllib3 will send the body using chunked transfer     encoding. Otherwise, urllib3 will send the body using the standard     content-length form. Defaults to False.</p> <p>:param int body_pos:     Position to seek to in file-like body in the event of a retry or     redirect. Typically this won't need to be set because urllib3 will     auto-populate the value when needed.</p> <p>:param **response_kw:     Additional parameters are passed to     :meth:<code>urllib3.response.HTTPResponse.from_httplib</code></p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>def urlopen(\n    self,\n    method,\n    url,\n    body=None,\n    headers=None,\n    retries=None,\n    redirect=True,\n    assert_same_host=True,\n    timeout=_Default,\n    pool_timeout=None,\n    release_conn=None,\n    chunked=False,\n    body_pos=None,\n    **response_kw\n):\n    \"\"\"\n    Get a connection from the pool and perform an HTTP request. This is the\n    lowest level call for making a request, so you'll need to specify all\n    the raw details.\n\n    .. note::\n\n       More commonly, it's appropriate to use a convenience method provided\n       by :class:`.RequestMethods`, such as :meth:`request`.\n\n    .. note::\n\n       `release_conn` will only behave as expected if\n       `preload_content=False` because we want to make\n       `preload_content=False` the default behaviour someday soon without\n       breaking backwards compatibility.\n\n    :param method:\n        HTTP request method (such as GET, POST, PUT, etc.)\n\n    :param url:\n        The URL to perform the request on.\n\n    :param body:\n        Data to send in the request body, either :class:`str`, :class:`bytes`,\n        an iterable of :class:`str`/:class:`bytes`, or a file-like object.\n\n    :param headers:\n        Dictionary of custom headers to send, such as User-Agent,\n        If-None-Match, etc. If None, pool headers are used. If provided,\n        these headers completely replace any pool-specific headers.\n\n    :param retries:\n        Configure the number of retries to allow before raising a\n        :class:`~urllib3.exceptions.MaxRetryError` exception.\n\n        Pass ``None`` to retry until you receive a response. Pass a\n        :class:`~urllib3.util.retry.Retry` object for fine-grained control\n        over different types of retries.\n        Pass an integer number to retry connection errors that many times,\n        but no other types of errors. Pass zero to never retry.\n\n        If ``False``, then retries are disabled and any exception is raised\n        immediately. Also, instead of raising a MaxRetryError on redirects,\n        the redirect response will be returned.\n\n    :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.\n\n    :param redirect:\n        If True, automatically handle redirects (status codes 301, 302,\n        303, 307, 308). Each redirect counts as a retry. Disabling retries\n        will disable redirect, too.\n\n    :param assert_same_host:\n        If ``True``, will make sure that the host of the pool requests is\n        consistent else will raise HostChangedError. When ``False``, you can\n        use the pool on an HTTP proxy and request foreign hosts.\n\n    :param timeout:\n        If specified, overrides the default timeout for this one\n        request. It may be a float (in seconds) or an instance of\n        :class:`urllib3.util.Timeout`.\n\n    :param pool_timeout:\n        If set and the pool is set to block=True, then this method will\n        block for ``pool_timeout`` seconds and raise EmptyPoolError if no\n        connection is available within the time period.\n\n    :param release_conn:\n        If False, then the urlopen call will not release the connection\n        back into the pool once a response is received (but will release if\n        you read the entire contents of the response such as when\n        `preload_content=True`). This is useful if you're not preloading\n        the response's content immediately. You will need to call\n        ``r.release_conn()`` on the response ``r`` to return the connection\n        back into the pool. If None, it takes the value of\n        ``response_kw.get('preload_content', True)``.\n\n    :param chunked:\n        If True, urllib3 will send the body using chunked transfer\n        encoding. Otherwise, urllib3 will send the body using the standard\n        content-length form. Defaults to False.\n\n    :param int body_pos:\n        Position to seek to in file-like body in the event of a retry or\n        redirect. Typically this won't need to be set because urllib3 will\n        auto-populate the value when needed.\n\n    :param \\\\**response_kw:\n        Additional parameters are passed to\n        :meth:`urllib3.response.HTTPResponse.from_httplib`\n    \"\"\"\n\n    parsed_url = parse_url(url)\n    destination_scheme = parsed_url.scheme\n\n    if headers is None:\n        headers = self.headers\n\n    if not isinstance(retries, Retry):\n        retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n    if release_conn is None:\n        release_conn = response_kw.get(\"preload_content\", True)\n\n    # Check host\n    if assert_same_host and not self.is_same_host(url):\n        raise HostChangedError(self, url, retries)\n\n    # Ensure that the URL we're connecting to is properly encoded\n    if url.startswith(\"/\"):\n        url = six.ensure_str(_encode_target(url))\n    else:\n        url = six.ensure_str(parsed_url.url)\n\n    conn = None\n\n    # Track whether `conn` needs to be released before\n    # returning/raising/recursing. Update this variable if necessary, and\n    # leave `release_conn` constant throughout the function. That way, if\n    # the function recurses, the original value of `release_conn` will be\n    # passed down into the recursive call, and its value will be respected.\n    #\n    # See issue #651 [1] for details.\n    #\n    # [1] &lt;https://github.com/urllib3/urllib3/issues/651&gt;\n    release_this_conn = release_conn\n\n    http_tunnel_required = connection_requires_http_tunnel(\n        self.proxy, self.proxy_config, destination_scheme\n    )\n\n    # Merge the proxy headers. Only done when not using HTTP CONNECT. We\n    # have to copy the headers dict so we can safely change it without those\n    # changes being reflected in anyone else's copy.\n    if not http_tunnel_required:\n        headers = headers.copy()\n        headers.update(self.proxy_headers)\n\n    # Must keep the exception bound to a separate variable or else Python 3\n    # complains about UnboundLocalError.\n    err = None\n\n    # Keep track of whether we cleanly exited the except block. This\n    # ensures we do proper cleanup in finally.\n    clean_exit = False\n\n    # Rewind body position, if needed. Record current position\n    # for future rewinds in the event of a redirect/retry.\n    body_pos = set_file_position(body, body_pos)\n\n    try:\n        # Request a connection from the queue.\n        timeout_obj = self._get_timeout(timeout)\n        conn = self._get_conn(timeout=pool_timeout)\n\n        conn.timeout = timeout_obj.connect_timeout\n\n        is_new_proxy_conn = self.proxy is not None and not getattr(\n            conn, \"sock\", None\n        )\n        if is_new_proxy_conn and http_tunnel_required:\n            self._prepare_proxy(conn)\n\n        # Make the request on the httplib connection object.\n        httplib_response = self._make_request(\n            conn,\n            method,\n            url,\n            timeout=timeout_obj,\n            body=body,\n            headers=headers,\n            chunked=chunked,\n        )\n\n        # If we're going to release the connection in ``finally:``, then\n        # the response doesn't need to know about the connection. Otherwise\n        # it will also try to release it and we'll have a double-release\n        # mess.\n        response_conn = conn if not release_conn else None\n\n        # Pass method to Response for length checking\n        response_kw[\"request_method\"] = method\n\n        # Import httplib's response into our own wrapper object\n        response = self.ResponseCls.from_httplib(\n            httplib_response,\n            pool=self,\n            connection=response_conn,\n            retries=retries,\n            **response_kw\n        )\n\n        # Everything went great!\n        clean_exit = True\n\n    except EmptyPoolError:\n        # Didn't get a connection from the pool, no need to clean up\n        clean_exit = True\n        release_this_conn = False\n        raise\n\n    except (\n        TimeoutError,\n        HTTPException,\n        SocketError,\n        ProtocolError,\n        BaseSSLError,\n        SSLError,\n        CertificateError,\n    ) as e:\n        # Discard the connection for these exceptions. It will be\n        # replaced during the next _get_conn() call.\n        clean_exit = False\n        if isinstance(e, (BaseSSLError, CertificateError)):\n            e = SSLError(e)\n        elif isinstance(e, (SocketError, NewConnectionError)) and self.proxy:\n            e = ProxyError(\"Cannot connect to proxy.\", e)\n        elif isinstance(e, (SocketError, HTTPException)):\n            e = ProtocolError(\"Connection aborted.\", e)\n\n        retries = retries.increment(\n            method, url, error=e, _pool=self, _stacktrace=sys.exc_info()[2]\n        )\n        retries.sleep()\n\n        # Keep track of the error for the retry warning.\n        err = e\n\n    finally:\n        if not clean_exit:\n            # We hit some kind of exception, handled or otherwise. We need\n            # to throw the connection away unless explicitly told not to.\n            # Close the connection, set the variable to None, and make sure\n            # we put the None back in the pool to avoid leaking it.\n            conn = conn and conn.close()\n            release_this_conn = True\n\n        if release_this_conn:\n            # Put the connection back to be reused. If the connection is\n            # expired then it will be None, which will get replaced with a\n            # fresh connection during _get_conn.\n            self._put_conn(conn)\n\n    if not conn:\n        # Try again\n        log.warning(\n            \"Retrying (%r) after connection broken by '%r': %s\", retries, err, url\n        )\n        return self.urlopen(\n            method,\n            url,\n            body,\n            headers,\n            retries,\n            redirect,\n            assert_same_host,\n            timeout=timeout,\n            pool_timeout=pool_timeout,\n            release_conn=release_conn,\n            chunked=chunked,\n            body_pos=body_pos,\n            **response_kw\n        )\n\n    # Handle redirect?\n    redirect_location = redirect and response.get_redirect_location()\n    if redirect_location:\n        if response.status == 303:\n            method = \"GET\"\n\n        try:\n            retries = retries.increment(method, url, response=response, _pool=self)\n        except MaxRetryError:\n            if retries.raise_on_redirect:\n                response.drain_conn()\n                raise\n            return response\n\n        response.drain_conn()\n        retries.sleep_for_retry(response)\n        log.debug(\"Redirecting %s -&gt; %s\", url, redirect_location)\n        return self.urlopen(\n            method,\n            redirect_location,\n            body,\n            headers,\n            retries=retries,\n            redirect=redirect,\n            assert_same_host=assert_same_host,\n            timeout=timeout,\n            pool_timeout=pool_timeout,\n            release_conn=release_conn,\n            chunked=chunked,\n            body_pos=body_pos,\n            **response_kw\n        )\n\n    # Check if we should retry the HTTP response.\n    has_retry_after = bool(response.getheader(\"Retry-After\"))\n    if retries.is_retry(method, response.status, has_retry_after):\n        try:\n            retries = retries.increment(method, url, response=response, _pool=self)\n        except MaxRetryError:\n            if retries.raise_on_status:\n                response.drain_conn()\n                raise\n            return response\n\n        response.drain_conn()\n        retries.sleep(response)\n        log.debug(\"Retry: %s\", url)\n        return self.urlopen(\n            method,\n            url,\n            body,\n            headers,\n            retries=retries,\n            redirect=redirect,\n            assert_same_host=assert_same_host,\n            timeout=timeout,\n            pool_timeout=pool_timeout,\n            release_conn=release_conn,\n            chunked=chunked,\n            body_pos=body_pos,\n            **response_kw\n        )\n\n    return response\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connectionpool.html#client.ayon_fusion.vendor.urllib3.connectionpool.HTTPSConnectionPool","title":"<code>HTTPSConnectionPool</code>","text":"<p>               Bases: <code>HTTPConnectionPool</code></p> <p>Same as :class:<code>.HTTPConnectionPool</code>, but HTTPS.</p> <p>:class:<code>.HTTPSConnection</code> uses one of <code>assert_fingerprint</code>, <code>assert_hostname</code> and <code>host</code> in this order to verify connections. If <code>assert_hostname</code> is False, no verification is done.</p> <p>The <code>key_file</code>, <code>cert_file</code>, <code>cert_reqs</code>, <code>ca_certs</code>, <code>ca_cert_dir</code>, <code>ssl_version</code>, <code>key_password</code> are only used if :mod:<code>ssl</code> is available and are fed into :meth:<code>urllib3.util.ssl_wrap_socket</code> to upgrade the connection socket into an SSL socket.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>class HTTPSConnectionPool(HTTPConnectionPool):\n    \"\"\"\n    Same as :class:`.HTTPConnectionPool`, but HTTPS.\n\n    :class:`.HTTPSConnection` uses one of ``assert_fingerprint``,\n    ``assert_hostname`` and ``host`` in this order to verify connections.\n    If ``assert_hostname`` is False, no verification is done.\n\n    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs``,\n    ``ca_cert_dir``, ``ssl_version``, ``key_password`` are only used if :mod:`ssl`\n    is available and are fed into :meth:`urllib3.util.ssl_wrap_socket` to upgrade\n    the connection socket into an SSL socket.\n    \"\"\"\n\n    scheme = \"https\"\n    ConnectionCls = HTTPSConnection\n\n    def __init__(\n        self,\n        host,\n        port=None,\n        strict=False,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        maxsize=1,\n        block=False,\n        headers=None,\n        retries=None,\n        _proxy=None,\n        _proxy_headers=None,\n        key_file=None,\n        cert_file=None,\n        cert_reqs=None,\n        key_password=None,\n        ca_certs=None,\n        ssl_version=None,\n        assert_hostname=None,\n        assert_fingerprint=None,\n        ca_cert_dir=None,\n        **conn_kw\n    ):\n\n        HTTPConnectionPool.__init__(\n            self,\n            host,\n            port,\n            strict,\n            timeout,\n            maxsize,\n            block,\n            headers,\n            retries,\n            _proxy,\n            _proxy_headers,\n            **conn_kw\n        )\n\n        self.key_file = key_file\n        self.cert_file = cert_file\n        self.cert_reqs = cert_reqs\n        self.key_password = key_password\n        self.ca_certs = ca_certs\n        self.ca_cert_dir = ca_cert_dir\n        self.ssl_version = ssl_version\n        self.assert_hostname = assert_hostname\n        self.assert_fingerprint = assert_fingerprint\n\n    def _prepare_conn(self, conn):\n        \"\"\"\n        Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket`\n        and establish the tunnel if proxy is used.\n        \"\"\"\n\n        if isinstance(conn, VerifiedHTTPSConnection):\n            conn.set_cert(\n                key_file=self.key_file,\n                key_password=self.key_password,\n                cert_file=self.cert_file,\n                cert_reqs=self.cert_reqs,\n                ca_certs=self.ca_certs,\n                ca_cert_dir=self.ca_cert_dir,\n                assert_hostname=self.assert_hostname,\n                assert_fingerprint=self.assert_fingerprint,\n            )\n            conn.ssl_version = self.ssl_version\n        return conn\n\n    def _prepare_proxy(self, conn):\n        \"\"\"\n        Establishes a tunnel connection through HTTP CONNECT.\n\n        Tunnel connection is established early because otherwise httplib would\n        improperly set Host: header to proxy's IP:port.\n        \"\"\"\n\n        conn.set_tunnel(self._proxy_host, self.port, self.proxy_headers)\n\n        if self.proxy.scheme == \"https\":\n            conn.tls_in_tls_required = True\n\n        conn.connect()\n\n    def _new_conn(self):\n        \"\"\"\n        Return a fresh :class:`http.client.HTTPSConnection`.\n        \"\"\"\n        self.num_connections += 1\n        log.debug(\n            \"Starting new HTTPS connection (%d): %s:%s\",\n            self.num_connections,\n            self.host,\n            self.port or \"443\",\n        )\n\n        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:\n            raise SSLError(\n                \"Can't connect to HTTPS URL because the SSL module is not available.\"\n            )\n\n        actual_host = self.host\n        actual_port = self.port\n        if self.proxy is not None:\n            actual_host = self.proxy.host\n            actual_port = self.proxy.port\n\n        conn = self.ConnectionCls(\n            host=actual_host,\n            port=actual_port,\n            timeout=self.timeout.connect_timeout,\n            strict=self.strict,\n            cert_file=self.cert_file,\n            key_file=self.key_file,\n            key_password=self.key_password,\n            **self.conn_kw\n        )\n\n        return self._prepare_conn(conn)\n\n    def _validate_conn(self, conn):\n        \"\"\"\n        Called right before a request is made, after the socket is created.\n        \"\"\"\n        super(HTTPSConnectionPool, self)._validate_conn(conn)\n\n        # Force connect early to allow us to validate the connection.\n        if not getattr(conn, \"sock\", None):  # AppEngine might not have  `.sock`\n            conn.connect()\n\n        if not conn.is_verified:\n            warnings.warn(\n                (\n                    \"Unverified HTTPS request is being made to host '%s'. \"\n                    \"Adding certificate verification is strongly advised. See: \"\n                    \"https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html\"\n                    \"#ssl-warnings\" % conn.host\n                ),\n                InsecureRequestWarning,\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/connectionpool.html#client.ayon_fusion.vendor.urllib3.connectionpool.connection_from_url","title":"<code>connection_from_url(url, **kw)</code>","text":"<p>Given a url, return an :class:<code>.ConnectionPool</code> instance of its host.</p> <p>This is a shortcut for not having to parse out the scheme, host, and port of the url before creating an :class:<code>.ConnectionPool</code> instance.</p> <p>:param url:     Absolute URL string that must include the scheme. Port is optional.</p> <p>:param **kw:     Passes additional parameters to the constructor of the appropriate     :class:<code>.ConnectionPool</code>. Useful for specifying things like     timeout, maxsize, headers, etc.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; conn = connection_from_url('http://google.com/')\n&gt;&gt;&gt; r = conn.request('GET', '/')\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/connectionpool.py</code> <pre><code>def connection_from_url(url, **kw):\n    \"\"\"\n    Given a url, return an :class:`.ConnectionPool` instance of its host.\n\n    This is a shortcut for not having to parse out the scheme, host, and port\n    of the url before creating an :class:`.ConnectionPool` instance.\n\n    :param url:\n        Absolute URL string that must include the scheme. Port is optional.\n\n    :param \\\\**kw:\n        Passes additional parameters to the constructor of the appropriate\n        :class:`.ConnectionPool`. Useful for specifying things like\n        timeout, maxsize, headers, etc.\n\n    Example::\n\n        &gt;&gt;&gt; conn = connection_from_url('http://google.com/')\n        &gt;&gt;&gt; r = conn.request('GET', '/')\n    \"\"\"\n    scheme, host, port = get_host(url)\n    port = port or port_by_scheme.get(scheme, 80)\n    if scheme == \"https\":\n        return HTTPSConnectionPool(host, port=port, **kw)\n    else:\n        return HTTPConnectionPool(host, port=port, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html","title":"exceptions","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.BodyNotHttplibCompatible","title":"<code>BodyNotHttplibCompatible</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Body should be :class:<code>http.client.HTTPResponse</code> like (have an fp attribute which returns raw chunks) for read_chunked().</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class BodyNotHttplibCompatible(HTTPError):\n    \"\"\"\n    Body should be :class:`http.client.HTTPResponse` like\n    (have an fp attribute which returns raw chunks) for read_chunked().\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.ClosedPoolError","title":"<code>ClosedPoolError</code>","text":"<p>               Bases: <code>PoolError</code></p> <p>Raised when a request enters a pool after the pool has been closed.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class ClosedPoolError(PoolError):\n    \"\"\"Raised when a request enters a pool after the pool has been closed.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.ConnectTimeoutError","title":"<code>ConnectTimeoutError</code>","text":"<p>               Bases: <code>TimeoutError</code></p> <p>Raised when a socket timeout occurs while connecting to a server</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class ConnectTimeoutError(TimeoutError):\n    \"\"\"Raised when a socket timeout occurs while connecting to a server\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.DecodeError","title":"<code>DecodeError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Raised when automatic decoding based on Content-Type fails.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.DependencyWarning","title":"<code>DependencyWarning</code>","text":"<p>               Bases: <code>HTTPWarning</code></p> <p>Warned when an attempt is made to import a module with missing optional dependencies.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class DependencyWarning(HTTPWarning):\n    \"\"\"\n    Warned when an attempt is made to import a module with missing optional\n    dependencies.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.EmptyPoolError","title":"<code>EmptyPoolError</code>","text":"<p>               Bases: <code>PoolError</code></p> <p>Raised when a pool runs out of connections and no more are allowed.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class EmptyPoolError(PoolError):\n    \"\"\"Raised when a pool runs out of connections and no more are allowed.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.HTTPError","title":"<code>HTTPError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception used by this module.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class HTTPError(Exception):\n    \"\"\"Base exception used by this module.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.HTTPWarning","title":"<code>HTTPWarning</code>","text":"<p>               Bases: <code>Warning</code></p> <p>Base warning used by this module.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class HTTPWarning(Warning):\n    \"\"\"Base warning used by this module.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.HeaderParsingError","title":"<code>HeaderParsingError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Raised by assert_header_parsing, but we convert it to a log.warning statement.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class HeaderParsingError(HTTPError):\n    \"\"\"Raised by assert_header_parsing, but we convert it to a log.warning statement.\"\"\"\n\n    def __init__(self, defects, unparsed_data):\n        message = \"%s, unparsed data: %r\" % (defects or \"Unknown\", unparsed_data)\n        super(HeaderParsingError, self).__init__(message)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.HostChangedError","title":"<code>HostChangedError</code>","text":"<p>               Bases: <code>RequestError</code></p> <p>Raised when an existing pool gets a request for a foreign host.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class HostChangedError(RequestError):\n    \"\"\"Raised when an existing pool gets a request for a foreign host.\"\"\"\n\n    def __init__(self, pool, url, retries=3):\n        message = \"Tried to open a foreign host with url: %s\" % url\n        RequestError.__init__(self, pool, url, message)\n        self.retries = retries\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.IncompleteRead","title":"<code>IncompleteRead</code>","text":"<p>               Bases: <code>HTTPError</code>, <code>IncompleteRead</code></p> <p>Response length doesn't match expected Content-Length</p> <p>Subclass of :class:<code>http.client.IncompleteRead</code> to allow int value for <code>partial</code> to avoid creating large objects on streamed reads.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class IncompleteRead(HTTPError, httplib_IncompleteRead):\n    \"\"\"\n    Response length doesn't match expected Content-Length\n\n    Subclass of :class:`http.client.IncompleteRead` to allow int value\n    for ``partial`` to avoid creating large objects on streamed reads.\n    \"\"\"\n\n    def __init__(self, partial, expected):\n        super(IncompleteRead, self).__init__(partial, expected)\n\n    def __repr__(self):\n        return \"IncompleteRead(%i bytes read, %i more expected)\" % (\n            self.partial,\n            self.expected,\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.InsecurePlatformWarning","title":"<code>InsecurePlatformWarning</code>","text":"<p>               Bases: <code>SecurityWarning</code></p> <p>Warned when certain TLS/SSL configuration is not available on a platform.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class InsecurePlatformWarning(SecurityWarning):\n    \"\"\"Warned when certain TLS/SSL configuration is not available on a platform.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.InsecureRequestWarning","title":"<code>InsecureRequestWarning</code>","text":"<p>               Bases: <code>SecurityWarning</code></p> <p>Warned when making an unverified HTTPS request.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class InsecureRequestWarning(SecurityWarning):\n    \"\"\"Warned when making an unverified HTTPS request.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.InvalidChunkLength","title":"<code>InvalidChunkLength</code>","text":"<p>               Bases: <code>HTTPError</code>, <code>IncompleteRead</code></p> <p>Invalid chunk length in a chunked response.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class InvalidChunkLength(HTTPError, httplib_IncompleteRead):\n    \"\"\"Invalid chunk length in a chunked response.\"\"\"\n\n    def __init__(self, response, length):\n        super(InvalidChunkLength, self).__init__(\n            response.tell(), response.length_remaining\n        )\n        self.response = response\n        self.length = length\n\n    def __repr__(self):\n        return \"InvalidChunkLength(got length %r, %i bytes read)\" % (\n            self.length,\n            self.partial,\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.InvalidHeader","title":"<code>InvalidHeader</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>The header provided was somehow invalid.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class InvalidHeader(HTTPError):\n    \"\"\"The header provided was somehow invalid.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.LocationParseError","title":"<code>LocationParseError</code>","text":"<p>               Bases: <code>LocationValueError</code></p> <p>Raised when get_host or similar fails to parse the URL input.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class LocationParseError(LocationValueError):\n    \"\"\"Raised when get_host or similar fails to parse the URL input.\"\"\"\n\n    def __init__(self, location):\n        message = \"Failed to parse: %s\" % location\n        HTTPError.__init__(self, message)\n\n        self.location = location\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.LocationValueError","title":"<code>LocationValueError</code>","text":"<p>               Bases: <code>ValueError</code>, <code>HTTPError</code></p> <p>Raised when there is something wrong with a given URL input.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class LocationValueError(ValueError, HTTPError):\n    \"\"\"Raised when there is something wrong with a given URL input.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.MaxRetryError","title":"<code>MaxRetryError</code>","text":"<p>               Bases: <code>RequestError</code></p> <p>Raised when the maximum number of retries is exceeded.</p> <p>:param pool: The connection pool :type pool: :class:<code>~urllib3.connectionpool.HTTPConnectionPool</code> :param string url: The requested Url :param exceptions.Exception reason: The underlying error</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class MaxRetryError(RequestError):\n    \"\"\"Raised when the maximum number of retries is exceeded.\n\n    :param pool: The connection pool\n    :type pool: :class:`~urllib3.connectionpool.HTTPConnectionPool`\n    :param string url: The requested Url\n    :param exceptions.Exception reason: The underlying error\n\n    \"\"\"\n\n    def __init__(self, pool, url, reason=None):\n        self.reason = reason\n\n        message = \"Max retries exceeded with url: %s (Caused by %r)\" % (url, reason)\n\n        RequestError.__init__(self, pool, url, message)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.NewConnectionError","title":"<code>NewConnectionError</code>","text":"<p>               Bases: <code>ConnectTimeoutError</code>, <code>PoolError</code></p> <p>Raised when we fail to establish a new connection. Usually ECONNREFUSED.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class NewConnectionError(ConnectTimeoutError, PoolError):\n    \"\"\"Raised when we fail to establish a new connection. Usually ECONNREFUSED.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.PoolError","title":"<code>PoolError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Base exception for errors caused within a pool.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class PoolError(HTTPError):\n    \"\"\"Base exception for errors caused within a pool.\"\"\"\n\n    def __init__(self, pool, message):\n        self.pool = pool\n        HTTPError.__init__(self, \"%s: %s\" % (pool, message))\n\n    def __reduce__(self):\n        # For pickling purposes.\n        return self.__class__, (None, None)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.ProtocolError","title":"<code>ProtocolError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Raised when something unexpected happens mid-request/response.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.ProxyError","title":"<code>ProxyError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Raised when the connection to a proxy fails.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n\n    def __init__(self, message, error, *args):\n        super(ProxyError, self).__init__(message, error, *args)\n        self.original_error = error\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.ProxySchemeUnknown","title":"<code>ProxySchemeUnknown</code>","text":"<p>               Bases: <code>AssertionError</code>, <code>URLSchemeUnknown</code></p> <p>ProxyManager does not support the supplied scheme</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class ProxySchemeUnknown(AssertionError, URLSchemeUnknown):\n    \"\"\"ProxyManager does not support the supplied scheme\"\"\"\n\n    # TODO(t-8ch): Stop inheriting from AssertionError in v2.0.\n\n    def __init__(self, scheme):\n        # 'localhost' is here because our URL parser parses\n        # localhost:8080 -&gt; scheme=localhost, remove if we fix this.\n        if scheme == \"localhost\":\n            scheme = None\n        if scheme is None:\n            message = \"Proxy URL had no scheme, should start with http:// or https://\"\n        else:\n            message = (\n                \"Proxy URL had unsupported scheme %s, should use http:// or https://\"\n                % scheme\n            )\n        super(ProxySchemeUnknown, self).__init__(message)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.ProxySchemeUnsupported","title":"<code>ProxySchemeUnsupported</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Fetching HTTPS resources through HTTPS proxies is unsupported</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class ProxySchemeUnsupported(ValueError):\n    \"\"\"Fetching HTTPS resources through HTTPS proxies is unsupported\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.ReadTimeoutError","title":"<code>ReadTimeoutError</code>","text":"<p>               Bases: <code>TimeoutError</code>, <code>RequestError</code></p> <p>Raised when a socket timeout occurs while receiving data from a server</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class ReadTimeoutError(TimeoutError, RequestError):\n    \"\"\"Raised when a socket timeout occurs while receiving data from a server\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.RequestError","title":"<code>RequestError</code>","text":"<p>               Bases: <code>PoolError</code></p> <p>Base exception for PoolErrors that have associated URLs.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class RequestError(PoolError):\n    \"\"\"Base exception for PoolErrors that have associated URLs.\"\"\"\n\n    def __init__(self, pool, url, message):\n        self.url = url\n        PoolError.__init__(self, pool, message)\n\n    def __reduce__(self):\n        # For pickling purposes.\n        return self.__class__, (None, self.url, None)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.ResponseError","title":"<code>ResponseError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Used as a container for an error reason supplied in a MaxRetryError.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class ResponseError(HTTPError):\n    \"\"\"Used as a container for an error reason supplied in a MaxRetryError.\"\"\"\n\n    GENERIC_ERROR = \"too many error responses\"\n    SPECIFIC_ERROR = \"too many {status_code} error responses\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.ResponseNotChunked","title":"<code>ResponseNotChunked</code>","text":"<p>               Bases: <code>ProtocolError</code>, <code>ValueError</code></p> <p>Response needs to be chunked in order to read it as chunks.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class ResponseNotChunked(ProtocolError, ValueError):\n    \"\"\"Response needs to be chunked in order to read it as chunks.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.SNIMissingWarning","title":"<code>SNIMissingWarning</code>","text":"<p>               Bases: <code>HTTPWarning</code></p> <p>Warned when making a HTTPS request without SNI available.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class SNIMissingWarning(HTTPWarning):\n    \"\"\"Warned when making a HTTPS request without SNI available.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.SSLError","title":"<code>SSLError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Raised when SSL certificate fails in an HTTPS connection.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class SSLError(HTTPError):\n    \"\"\"Raised when SSL certificate fails in an HTTPS connection.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.SecurityWarning","title":"<code>SecurityWarning</code>","text":"<p>               Bases: <code>HTTPWarning</code></p> <p>Warned when performing security reducing actions</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class SecurityWarning(HTTPWarning):\n    \"\"\"Warned when performing security reducing actions\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.SubjectAltNameWarning","title":"<code>SubjectAltNameWarning</code>","text":"<p>               Bases: <code>SecurityWarning</code></p> <p>Warned when connecting to a host with a certificate missing a SAN.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class SubjectAltNameWarning(SecurityWarning):\n    \"\"\"Warned when connecting to a host with a certificate missing a SAN.\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.SystemTimeWarning","title":"<code>SystemTimeWarning</code>","text":"<p>               Bases: <code>SecurityWarning</code></p> <p>Warned when system time is suspected to be wrong</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class SystemTimeWarning(SecurityWarning):\n    \"\"\"Warned when system time is suspected to be wrong\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.TimeoutError","title":"<code>TimeoutError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Raised when a socket timeout error occurs.</p> <p>Catching this error will catch both :exc:<code>ReadTimeoutErrors &lt;ReadTimeoutError&gt;</code> and :exc:<code>ConnectTimeoutErrors &lt;ConnectTimeoutError&gt;</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class TimeoutError(HTTPError):\n    \"\"\"Raised when a socket timeout error occurs.\n\n    Catching this error will catch both :exc:`ReadTimeoutErrors\n    &lt;ReadTimeoutError&gt;` and :exc:`ConnectTimeoutErrors &lt;ConnectTimeoutError&gt;`.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.TimeoutStateError","title":"<code>TimeoutStateError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Raised when passing an invalid state to a timeout</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class TimeoutStateError(HTTPError):\n    \"\"\"Raised when passing an invalid state to a timeout\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.URLSchemeUnknown","title":"<code>URLSchemeUnknown</code>","text":"<p>               Bases: <code>LocationValueError</code></p> <p>Raised when a URL input has an unsupported scheme.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class URLSchemeUnknown(LocationValueError):\n    \"\"\"Raised when a URL input has an unsupported scheme.\"\"\"\n\n    def __init__(self, scheme):\n        message = \"Not supported URL scheme %s\" % scheme\n        super(URLSchemeUnknown, self).__init__(message)\n\n        self.scheme = scheme\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/exceptions.html#client.ayon_fusion.vendor.urllib3.exceptions.UnrewindableBodyError","title":"<code>UnrewindableBodyError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>urllib3 encountered an error when trying to rewind a body</p> Source code in <code>client/ayon_fusion/vendor/urllib3/exceptions.py</code> <pre><code>class UnrewindableBodyError(HTTPError):\n    \"\"\"urllib3 encountered an error when trying to rewind a body\"\"\"\n\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/fields.html","title":"fields","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/fields.html#client.ayon_fusion.vendor.urllib3.fields.RequestField","title":"<code>RequestField</code>","text":"<p>               Bases: <code>object</code></p> <p>A data container for request body parameters.</p> <p>:param name:     The name of this request field. Must be unicode. :param data:     The data/value body. :param filename:     An optional filename of the request field. Must be unicode. :param headers:     An optional dict-like object of headers to initially use for the field. :param header_formatter:     An optional callable that is used to encode and format the headers. By     default, this is :func:<code>format_header_param_html5</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/fields.py</code> <pre><code>class RequestField(object):\n    \"\"\"\n    A data container for request body parameters.\n\n    :param name:\n        The name of this request field. Must be unicode.\n    :param data:\n        The data/value body.\n    :param filename:\n        An optional filename of the request field. Must be unicode.\n    :param headers:\n        An optional dict-like object of headers to initially use for the field.\n    :param header_formatter:\n        An optional callable that is used to encode and format the headers. By\n        default, this is :func:`format_header_param_html5`.\n    \"\"\"\n\n    def __init__(\n        self,\n        name,\n        data,\n        filename=None,\n        headers=None,\n        header_formatter=format_header_param_html5,\n    ):\n        self._name = name\n        self._filename = filename\n        self.data = data\n        self.headers = {}\n        if headers:\n            self.headers = dict(headers)\n        self.header_formatter = header_formatter\n\n    @classmethod\n    def from_tuples(cls, fieldname, value, header_formatter=format_header_param_html5):\n        \"\"\"\n        A :class:`~urllib3.fields.RequestField` factory from old-style tuple parameters.\n\n        Supports constructing :class:`~urllib3.fields.RequestField` from\n        parameter of key/value strings AND key/filetuple. A filetuple is a\n        (filename, data, MIME type) tuple where the MIME type is optional.\n        For example::\n\n            'foo': 'bar',\n            'fakefile': ('foofile.txt', 'contents of foofile'),\n            'realfile': ('barfile.txt', open('realfile').read()),\n            'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),\n            'nonamefile': 'contents of nonamefile field',\n\n        Field names and filenames must be unicode.\n        \"\"\"\n        if isinstance(value, tuple):\n            if len(value) == 3:\n                filename, data, content_type = value\n            else:\n                filename, data = value\n                content_type = guess_content_type(filename)\n        else:\n            filename = None\n            content_type = None\n            data = value\n\n        request_param = cls(\n            fieldname, data, filename=filename, header_formatter=header_formatter\n        )\n        request_param.make_multipart(content_type=content_type)\n\n        return request_param\n\n    def _render_part(self, name, value):\n        \"\"\"\n        Overridable helper function to format a single header parameter. By\n        default, this calls ``self.header_formatter``.\n\n        :param name:\n            The name of the parameter, a string expected to be ASCII only.\n        :param value:\n            The value of the parameter, provided as a unicode string.\n        \"\"\"\n\n        return self.header_formatter(name, value)\n\n    def _render_parts(self, header_parts):\n        \"\"\"\n        Helper function to format and quote a single header.\n\n        Useful for single headers that are composed of multiple items. E.g.,\n        'Content-Disposition' fields.\n\n        :param header_parts:\n            A sequence of (k, v) tuples or a :class:`dict` of (k, v) to format\n            as `k1=\"v1\"; k2=\"v2\"; ...`.\n        \"\"\"\n        parts = []\n        iterable = header_parts\n        if isinstance(header_parts, dict):\n            iterable = header_parts.items()\n\n        for name, value in iterable:\n            if value is not None:\n                parts.append(self._render_part(name, value))\n\n        return u\"; \".join(parts)\n\n    def render_headers(self):\n        \"\"\"\n        Renders the headers for this request field.\n        \"\"\"\n        lines = []\n\n        sort_keys = [\"Content-Disposition\", \"Content-Type\", \"Content-Location\"]\n        for sort_key in sort_keys:\n            if self.headers.get(sort_key, False):\n                lines.append(u\"%s: %s\" % (sort_key, self.headers[sort_key]))\n\n        for header_name, header_value in self.headers.items():\n            if header_name not in sort_keys:\n                if header_value:\n                    lines.append(u\"%s: %s\" % (header_name, header_value))\n\n        lines.append(u\"\\r\\n\")\n        return u\"\\r\\n\".join(lines)\n\n    def make_multipart(\n        self, content_disposition=None, content_type=None, content_location=None\n    ):\n        \"\"\"\n        Makes this request field into a multipart request field.\n\n        This method overrides \"Content-Disposition\", \"Content-Type\" and\n        \"Content-Location\" headers to the request parameter.\n\n        :param content_type:\n            The 'Content-Type' of the request body.\n        :param content_location:\n            The 'Content-Location' of the request body.\n\n        \"\"\"\n        self.headers[\"Content-Disposition\"] = content_disposition or u\"form-data\"\n        self.headers[\"Content-Disposition\"] += u\"; \".join(\n            [\n                u\"\",\n                self._render_parts(\n                    ((u\"name\", self._name), (u\"filename\", self._filename))\n                ),\n            ]\n        )\n        self.headers[\"Content-Type\"] = content_type\n        self.headers[\"Content-Location\"] = content_location\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/fields.html#client.ayon_fusion.vendor.urllib3.fields.RequestField.from_tuples","title":"<code>from_tuples(fieldname, value, header_formatter=format_header_param_html5)</code>  <code>classmethod</code>","text":"<p>A :class:<code>~urllib3.fields.RequestField</code> factory from old-style tuple parameters.</p> <p>Supports constructing :class:<code>~urllib3.fields.RequestField</code> from parameter of key/value strings AND key/filetuple. A filetuple is a (filename, data, MIME type) tuple where the MIME type is optional. For example::</p> <pre><code>'foo': 'bar',\n'fakefile': ('foofile.txt', 'contents of foofile'),\n'realfile': ('barfile.txt', open('realfile').read()),\n'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),\n'nonamefile': 'contents of nonamefile field',\n</code></pre> <p>Field names and filenames must be unicode.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/fields.py</code> <pre><code>@classmethod\ndef from_tuples(cls, fieldname, value, header_formatter=format_header_param_html5):\n    \"\"\"\n    A :class:`~urllib3.fields.RequestField` factory from old-style tuple parameters.\n\n    Supports constructing :class:`~urllib3.fields.RequestField` from\n    parameter of key/value strings AND key/filetuple. A filetuple is a\n    (filename, data, MIME type) tuple where the MIME type is optional.\n    For example::\n\n        'foo': 'bar',\n        'fakefile': ('foofile.txt', 'contents of foofile'),\n        'realfile': ('barfile.txt', open('realfile').read()),\n        'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),\n        'nonamefile': 'contents of nonamefile field',\n\n    Field names and filenames must be unicode.\n    \"\"\"\n    if isinstance(value, tuple):\n        if len(value) == 3:\n            filename, data, content_type = value\n        else:\n            filename, data = value\n            content_type = guess_content_type(filename)\n    else:\n        filename = None\n        content_type = None\n        data = value\n\n    request_param = cls(\n        fieldname, data, filename=filename, header_formatter=header_formatter\n    )\n    request_param.make_multipart(content_type=content_type)\n\n    return request_param\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/fields.html#client.ayon_fusion.vendor.urllib3.fields.RequestField.make_multipart","title":"<code>make_multipart(content_disposition=None, content_type=None, content_location=None)</code>","text":"<p>Makes this request field into a multipart request field.</p> <p>This method overrides \"Content-Disposition\", \"Content-Type\" and \"Content-Location\" headers to the request parameter.</p> <p>:param content_type:     The 'Content-Type' of the request body. :param content_location:     The 'Content-Location' of the request body.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/fields.py</code> <pre><code>def make_multipart(\n    self, content_disposition=None, content_type=None, content_location=None\n):\n    \"\"\"\n    Makes this request field into a multipart request field.\n\n    This method overrides \"Content-Disposition\", \"Content-Type\" and\n    \"Content-Location\" headers to the request parameter.\n\n    :param content_type:\n        The 'Content-Type' of the request body.\n    :param content_location:\n        The 'Content-Location' of the request body.\n\n    \"\"\"\n    self.headers[\"Content-Disposition\"] = content_disposition or u\"form-data\"\n    self.headers[\"Content-Disposition\"] += u\"; \".join(\n        [\n            u\"\",\n            self._render_parts(\n                ((u\"name\", self._name), (u\"filename\", self._filename))\n            ),\n        ]\n    )\n    self.headers[\"Content-Type\"] = content_type\n    self.headers[\"Content-Location\"] = content_location\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/fields.html#client.ayon_fusion.vendor.urllib3.fields.RequestField.render_headers","title":"<code>render_headers()</code>","text":"<p>Renders the headers for this request field.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/fields.py</code> <pre><code>def render_headers(self):\n    \"\"\"\n    Renders the headers for this request field.\n    \"\"\"\n    lines = []\n\n    sort_keys = [\"Content-Disposition\", \"Content-Type\", \"Content-Location\"]\n    for sort_key in sort_keys:\n        if self.headers.get(sort_key, False):\n            lines.append(u\"%s: %s\" % (sort_key, self.headers[sort_key]))\n\n    for header_name, header_value in self.headers.items():\n        if header_name not in sort_keys:\n            if header_value:\n                lines.append(u\"%s: %s\" % (header_name, header_value))\n\n    lines.append(u\"\\r\\n\")\n    return u\"\\r\\n\".join(lines)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/fields.html#client.ayon_fusion.vendor.urllib3.fields.format_header_param_html5","title":"<code>format_header_param_html5(name, value)</code>","text":"<p>Helper function to format and quote a single header parameter using the HTML5 strategy.</p> <p>Particularly useful for header parameters which might contain non-ASCII values, like file names. This follows the <code>HTML5 Working Draft Section 4.10.22.7</code>_ and matches the behavior of curl and modern browsers.</p> <p>.. _HTML5 Working Draft Section 4.10.22.7:     https://w3c.github.io/html/sec-forms.html#multipart-form-data</p> <p>:param name:     The name of the parameter, a string expected to be ASCII only. :param value:     The value of the parameter, provided as <code>bytes</code> or `str``. :ret:     A unicode string, stripped of troublesome characters.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/fields.py</code> <pre><code>def format_header_param_html5(name, value):\n    \"\"\"\n    Helper function to format and quote a single header parameter using the\n    HTML5 strategy.\n\n    Particularly useful for header parameters which might contain\n    non-ASCII values, like file names. This follows the `HTML5 Working Draft\n    Section 4.10.22.7`_ and matches the behavior of curl and modern browsers.\n\n    .. _HTML5 Working Draft Section 4.10.22.7:\n        https://w3c.github.io/html/sec-forms.html#multipart-form-data\n\n    :param name:\n        The name of the parameter, a string expected to be ASCII only.\n    :param value:\n        The value of the parameter, provided as ``bytes`` or `str``.\n    :ret:\n        A unicode string, stripped of troublesome characters.\n    \"\"\"\n    if isinstance(value, six.binary_type):\n        value = value.decode(\"utf-8\")\n\n    value = _replace_multiple(value, _HTML5_REPLACEMENTS)\n\n    return u'%s=\"%s\"' % (name, value)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/fields.html#client.ayon_fusion.vendor.urllib3.fields.format_header_param_rfc2231","title":"<code>format_header_param_rfc2231(name, value)</code>","text":"<p>Helper function to format and quote a single header parameter using the strategy defined in RFC 2231.</p> <p>Particularly useful for header parameters which might contain non-ASCII values, like file names. This follows <code>RFC 2388 Section 4.4 &lt;https://tools.ietf.org/html/rfc2388#section-4.4&gt;</code>_.</p> <p>:param name:     The name of the parameter, a string expected to be ASCII only. :param value:     The value of the parameter, provided as <code>bytes</code> or `str``. :ret:     An RFC-2231-formatted unicode string.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/fields.py</code> <pre><code>def format_header_param_rfc2231(name, value):\n    \"\"\"\n    Helper function to format and quote a single header parameter using the\n    strategy defined in RFC 2231.\n\n    Particularly useful for header parameters which might contain\n    non-ASCII values, like file names. This follows\n    `RFC 2388 Section 4.4 &lt;https://tools.ietf.org/html/rfc2388#section-4.4&gt;`_.\n\n    :param name:\n        The name of the parameter, a string expected to be ASCII only.\n    :param value:\n        The value of the parameter, provided as ``bytes`` or `str``.\n    :ret:\n        An RFC-2231-formatted unicode string.\n    \"\"\"\n    if isinstance(value, six.binary_type):\n        value = value.decode(\"utf-8\")\n\n    if not any(ch in value for ch in '\"\\\\\\r\\n'):\n        result = u'%s=\"%s\"' % (name, value)\n        try:\n            result.encode(\"ascii\")\n        except (UnicodeEncodeError, UnicodeDecodeError):\n            pass\n        else:\n            return result\n\n    if six.PY2:  # Python 2:\n        value = value.encode(\"utf-8\")\n\n    # encode_rfc2231 accepts an encoded string and returns an ascii-encoded\n    # string in Python 2 but accepts and returns unicode strings in Python 3\n    value = email.utils.encode_rfc2231(value, \"utf-8\")\n    value = \"%s*=%s\" % (name, value)\n\n    if six.PY2:  # Python 2:\n        value = value.decode(\"utf-8\")\n\n    return value\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/fields.html#client.ayon_fusion.vendor.urllib3.fields.guess_content_type","title":"<code>guess_content_type(filename, default='application/octet-stream')</code>","text":"<p>Guess the \"Content-Type\" of a file.</p> <p>:param filename:     The filename to guess the \"Content-Type\" of using :mod:<code>mimetypes</code>. :param default:     If no \"Content-Type\" can be guessed, default to <code>default</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/fields.py</code> <pre><code>def guess_content_type(filename, default=\"application/octet-stream\"):\n    \"\"\"\n    Guess the \"Content-Type\" of a file.\n\n    :param filename:\n        The filename to guess the \"Content-Type\" of using :mod:`mimetypes`.\n    :param default:\n        If no \"Content-Type\" can be guessed, default to `default`.\n    \"\"\"\n    if filename:\n        return mimetypes.guess_type(filename)[0] or default\n    return default\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/filepost.html","title":"filepost","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/filepost.html#client.ayon_fusion.vendor.urllib3.filepost.choose_boundary","title":"<code>choose_boundary()</code>","text":"<p>Our embarrassingly-simple replacement for mimetools.choose_boundary.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/filepost.py</code> <pre><code>def choose_boundary():\n    \"\"\"\n    Our embarrassingly-simple replacement for mimetools.choose_boundary.\n    \"\"\"\n    boundary = binascii.hexlify(os.urandom(16))\n    if not six.PY2:\n        boundary = boundary.decode(\"ascii\")\n    return boundary\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/filepost.html#client.ayon_fusion.vendor.urllib3.filepost.encode_multipart_formdata","title":"<code>encode_multipart_formdata(fields, boundary=None)</code>","text":"<p>Encode a dictionary of <code>fields</code> using the multipart/form-data MIME format.</p> <p>:param fields:     Dictionary of fields or list of (key, :class:<code>~urllib3.fields.RequestField</code>).</p> <p>:param boundary:     If not specified, then a random boundary will be generated using     :func:<code>urllib3.filepost.choose_boundary</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/filepost.py</code> <pre><code>def encode_multipart_formdata(fields, boundary=None):\n    \"\"\"\n    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.\n\n    :param fields:\n        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).\n\n    :param boundary:\n        If not specified, then a random boundary will be generated using\n        :func:`urllib3.filepost.choose_boundary`.\n    \"\"\"\n    body = BytesIO()\n    if boundary is None:\n        boundary = choose_boundary()\n\n    for field in iter_field_objects(fields):\n        body.write(b(\"--%s\\r\\n\" % (boundary)))\n\n        writer(body).write(field.render_headers())\n        data = field.data\n\n        if isinstance(data, int):\n            data = str(data)  # Backwards compatibility\n\n        if isinstance(data, six.text_type):\n            writer(body).write(data)\n        else:\n            body.write(data)\n\n        body.write(b\"\\r\\n\")\n\n    body.write(b(\"--%s--\\r\\n\" % (boundary)))\n\n    content_type = str(\"multipart/form-data; boundary=%s\" % boundary)\n\n    return body.getvalue(), content_type\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/filepost.html#client.ayon_fusion.vendor.urllib3.filepost.iter_field_objects","title":"<code>iter_field_objects(fields)</code>","text":"<p>Iterate over fields.</p> <p>Supports list of (k, v) tuples and dicts, and lists of :class:<code>~urllib3.fields.RequestField</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/filepost.py</code> <pre><code>def iter_field_objects(fields):\n    \"\"\"\n    Iterate over fields.\n\n    Supports list of (k, v) tuples and dicts, and lists of\n    :class:`~urllib3.fields.RequestField`.\n\n    \"\"\"\n    if isinstance(fields, dict):\n        i = six.iteritems(fields)\n    else:\n        i = iter(fields)\n\n    for field in i:\n        if isinstance(field, RequestField):\n            yield field\n        else:\n            yield RequestField.from_tuples(*field)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/filepost.html#client.ayon_fusion.vendor.urllib3.filepost.iter_fields","title":"<code>iter_fields(fields)</code>","text":"<p>.. deprecated:: 1.6</p> <p>Iterate over fields.</p> <p>The addition of :class:<code>~urllib3.fields.RequestField</code> makes this function obsolete. Instead, use :func:<code>iter_field_objects</code>, which returns :class:<code>~urllib3.fields.RequestField</code> objects.</p> <p>Supports list of (k, v) tuples and dicts.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/filepost.py</code> <pre><code>def iter_fields(fields):\n    \"\"\"\n    .. deprecated:: 1.6\n\n    Iterate over fields.\n\n    The addition of :class:`~urllib3.fields.RequestField` makes this function\n    obsolete. Instead, use :func:`iter_field_objects`, which returns\n    :class:`~urllib3.fields.RequestField` objects.\n\n    Supports list of (k, v) tuples and dicts.\n    \"\"\"\n    if isinstance(fields, dict):\n        return ((k, v) for k, v in six.iteritems(fields))\n\n    return ((k, v) for k, v in fields)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html","title":"poolmanager","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html#client.ayon_fusion.vendor.urllib3.poolmanager.PoolManager","title":"<code>PoolManager</code>","text":"<p>               Bases: <code>RequestMethods</code></p> <p>Allows for arbitrary requests while transparently keeping track of necessary connection pools for you.</p> <p>:param num_pools:     Number of connection pools to cache before discarding the least     recently used pool.</p> <p>:param headers:     Headers to include with all requests, unless other headers are given     explicitly.</p> <p>:param **connection_pool_kw:     Additional parameters are used to create fresh     :class:<code>urllib3.connectionpool.ConnectionPool</code> instances.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; manager = PoolManager(num_pools=2)\n&gt;&gt;&gt; r = manager.request('GET', 'http://google.com/')\n&gt;&gt;&gt; r = manager.request('GET', 'http://google.com/mail')\n&gt;&gt;&gt; r = manager.request('GET', 'http://yahoo.com/')\n&gt;&gt;&gt; len(manager.pools)\n2\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>class PoolManager(RequestMethods):\n    \"\"\"\n    Allows for arbitrary requests while transparently keeping track of\n    necessary connection pools for you.\n\n    :param num_pools:\n        Number of connection pools to cache before discarding the least\n        recently used pool.\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n\n    :param \\\\**connection_pool_kw:\n        Additional parameters are used to create fresh\n        :class:`urllib3.connectionpool.ConnectionPool` instances.\n\n    Example::\n\n        &gt;&gt;&gt; manager = PoolManager(num_pools=2)\n        &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/')\n        &gt;&gt;&gt; r = manager.request('GET', 'http://google.com/mail')\n        &gt;&gt;&gt; r = manager.request('GET', 'http://yahoo.com/')\n        &gt;&gt;&gt; len(manager.pools)\n        2\n\n    \"\"\"\n\n    proxy = None\n    proxy_config = None\n\n    def __init__(self, num_pools=10, headers=None, **connection_pool_kw):\n        RequestMethods.__init__(self, headers)\n        self.connection_pool_kw = connection_pool_kw\n        self.pools = RecentlyUsedContainer(num_pools, dispose_func=lambda p: p.close())\n\n        # Locally set the pool classes and keys so other PoolManagers can\n        # override them.\n        self.pool_classes_by_scheme = pool_classes_by_scheme\n        self.key_fn_by_scheme = key_fn_by_scheme.copy()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.clear()\n        # Return False to re-raise any potential exceptions\n        return False\n\n    def _new_pool(self, scheme, host, port, request_context=None):\n        \"\"\"\n        Create a new :class:`urllib3.connectionpool.ConnectionPool` based on host, port, scheme, and\n        any additional pool keyword arguments.\n\n        If ``request_context`` is provided, it is provided as keyword arguments\n        to the pool class used. This method is used to actually create the\n        connection pools handed out by :meth:`connection_from_url` and\n        companion methods. It is intended to be overridden for customization.\n        \"\"\"\n        pool_cls = self.pool_classes_by_scheme[scheme]\n        if request_context is None:\n            request_context = self.connection_pool_kw.copy()\n\n        # Although the context has everything necessary to create the pool,\n        # this function has historically only used the scheme, host, and port\n        # in the positional args. When an API change is acceptable these can\n        # be removed.\n        for key in (\"scheme\", \"host\", \"port\"):\n            request_context.pop(key, None)\n\n        if scheme == \"http\":\n            for kw in SSL_KEYWORDS:\n                request_context.pop(kw, None)\n\n        return pool_cls(host, port, **request_context)\n\n    def clear(self):\n        \"\"\"\n        Empty our store of pools and direct them all to close.\n\n        This will not affect in-flight connections, but they will not be\n        re-used after completion.\n        \"\"\"\n        self.pools.clear()\n\n    def connection_from_host(self, host, port=None, scheme=\"http\", pool_kwargs=None):\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\n        If ``port`` isn't given, it will be derived from the ``scheme`` using\n        ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is\n        provided, it is merged with the instance's ``connection_pool_kw``\n        variable and used to create the new connection pool, if one is\n        needed.\n        \"\"\"\n\n        if not host:\n            raise LocationValueError(\"No host specified.\")\n\n        request_context = self._merge_pool_kwargs(pool_kwargs)\n        request_context[\"scheme\"] = scheme or \"http\"\n        if not port:\n            port = port_by_scheme.get(request_context[\"scheme\"].lower(), 80)\n        request_context[\"port\"] = port\n        request_context[\"host\"] = host\n\n        return self.connection_from_context(request_context)\n\n    def connection_from_context(self, request_context):\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n        ``request_context`` must at least contain the ``scheme`` key and its\n        value must be a key in ``key_fn_by_scheme`` instance variable.\n        \"\"\"\n        scheme = request_context[\"scheme\"].lower()\n        pool_key_constructor = self.key_fn_by_scheme.get(scheme)\n        if not pool_key_constructor:\n            raise URLSchemeUnknown(scheme)\n        pool_key = pool_key_constructor(request_context)\n\n        return self.connection_from_pool_key(pool_key, request_context=request_context)\n\n    def connection_from_pool_key(self, pool_key, request_context=None):\n        \"\"\"\n        Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n        ``pool_key`` should be a namedtuple that only contains immutable\n        objects. At a minimum it must have the ``scheme``, ``host``, and\n        ``port`` fields.\n        \"\"\"\n        with self.pools.lock:\n            # If the scheme, host, or port doesn't match existing open\n            # connections, open a new ConnectionPool.\n            pool = self.pools.get(pool_key)\n            if pool:\n                return pool\n\n            # Make a fresh ConnectionPool of the desired type\n            scheme = request_context[\"scheme\"]\n            host = request_context[\"host\"]\n            port = request_context[\"port\"]\n            pool = self._new_pool(scheme, host, port, request_context=request_context)\n            self.pools[pool_key] = pool\n\n        return pool\n\n    def connection_from_url(self, url, pool_kwargs=None):\n        \"\"\"\n        Similar to :func:`urllib3.connectionpool.connection_from_url`.\n\n        If ``pool_kwargs`` is not provided and a new pool needs to be\n        constructed, ``self.connection_pool_kw`` is used to initialize\n        the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``\n        is provided, it is used instead. Note that if a new pool does not\n        need to be created for the request, the provided ``pool_kwargs`` are\n        not used.\n        \"\"\"\n        u = parse_url(url)\n        return self.connection_from_host(\n            u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs\n        )\n\n    def _merge_pool_kwargs(self, override):\n        \"\"\"\n        Merge a dictionary of override values for self.connection_pool_kw.\n\n        This does not modify self.connection_pool_kw and returns a new dict.\n        Any keys in the override dictionary with a value of ``None`` are\n        removed from the merged dictionary.\n        \"\"\"\n        base_pool_kwargs = self.connection_pool_kw.copy()\n        if override:\n            for key, value in override.items():\n                if value is None:\n                    try:\n                        del base_pool_kwargs[key]\n                    except KeyError:\n                        pass\n                else:\n                    base_pool_kwargs[key] = value\n        return base_pool_kwargs\n\n    def _proxy_requires_url_absolute_form(self, parsed_url):\n        \"\"\"\n        Indicates if the proxy requires the complete destination URL in the\n        request.  Normally this is only needed when not using an HTTP CONNECT\n        tunnel.\n        \"\"\"\n        if self.proxy is None:\n            return False\n\n        return not connection_requires_http_tunnel(\n            self.proxy, self.proxy_config, parsed_url.scheme\n        )\n\n    def _validate_proxy_scheme_url_selection(self, url_scheme):\n        \"\"\"\n        Validates that were not attempting to do TLS in TLS connections on\n        Python2 or with unsupported SSL implementations.\n        \"\"\"\n        if self.proxy is None or url_scheme != \"https\":\n            return\n\n        if self.proxy.scheme != \"https\":\n            return\n\n        if six.PY2 and not self.proxy_config.use_forwarding_for_https:\n            raise ProxySchemeUnsupported(\n                \"Contacting HTTPS destinations through HTTPS proxies \"\n                \"'via CONNECT tunnels' is not supported in Python 2\"\n            )\n\n    def urlopen(self, method, url, redirect=True, **kw):\n        \"\"\"\n        Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\n        with custom cross-host redirect logic and only sends the request-uri\n        portion of the ``url``.\n\n        The given ``url`` parameter must be absolute, such that an appropriate\n        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n        \"\"\"\n        u = parse_url(url)\n        self._validate_proxy_scheme_url_selection(u.scheme)\n\n        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)\n\n        kw[\"assert_same_host\"] = False\n        kw[\"redirect\"] = False\n\n        if \"headers\" not in kw:\n            kw[\"headers\"] = self.headers.copy()\n\n        if self._proxy_requires_url_absolute_form(u):\n            response = conn.urlopen(method, url, **kw)\n        else:\n            response = conn.urlopen(method, u.request_uri, **kw)\n\n        redirect_location = redirect and response.get_redirect_location()\n        if not redirect_location:\n            return response\n\n        # Support relative URLs for redirecting.\n        redirect_location = urljoin(url, redirect_location)\n\n        # RFC 7231, Section 6.4.4\n        if response.status == 303:\n            method = \"GET\"\n\n        retries = kw.get(\"retries\")\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect)\n\n        # Strip headers marked as unsafe to forward to the redirected location.\n        # Check remove_headers_on_redirect to avoid a potential network call within\n        # conn.is_same_host() which may use socket.gethostbyname() in the future.\n        if retries.remove_headers_on_redirect and not conn.is_same_host(\n            redirect_location\n        ):\n            headers = list(six.iterkeys(kw[\"headers\"]))\n            for header in headers:\n                if header.lower() in retries.remove_headers_on_redirect:\n                    kw[\"headers\"].pop(header, None)\n\n        try:\n            retries = retries.increment(method, url, response=response, _pool=conn)\n        except MaxRetryError:\n            if retries.raise_on_redirect:\n                response.drain_conn()\n                raise\n            return response\n\n        kw[\"retries\"] = retries\n        kw[\"redirect\"] = redirect\n\n        log.info(\"Redirecting %s -&gt; %s\", url, redirect_location)\n\n        response.drain_conn()\n        return self.urlopen(method, redirect_location, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html#client.ayon_fusion.vendor.urllib3.poolmanager.PoolManager.clear","title":"<code>clear()</code>","text":"<p>Empty our store of pools and direct them all to close.</p> <p>This will not affect in-flight connections, but they will not be re-used after completion.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def clear(self):\n    \"\"\"\n    Empty our store of pools and direct them all to close.\n\n    This will not affect in-flight connections, but they will not be\n    re-used after completion.\n    \"\"\"\n    self.pools.clear()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html#client.ayon_fusion.vendor.urllib3.poolmanager.PoolManager.connection_from_context","title":"<code>connection_from_context(request_context)</code>","text":"<p>Get a :class:<code>urllib3.connectionpool.ConnectionPool</code> based on the request context.</p> <p><code>request_context</code> must at least contain the <code>scheme</code> key and its value must be a key in <code>key_fn_by_scheme</code> instance variable.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def connection_from_context(self, request_context):\n    \"\"\"\n    Get a :class:`urllib3.connectionpool.ConnectionPool` based on the request context.\n\n    ``request_context`` must at least contain the ``scheme`` key and its\n    value must be a key in ``key_fn_by_scheme`` instance variable.\n    \"\"\"\n    scheme = request_context[\"scheme\"].lower()\n    pool_key_constructor = self.key_fn_by_scheme.get(scheme)\n    if not pool_key_constructor:\n        raise URLSchemeUnknown(scheme)\n    pool_key = pool_key_constructor(request_context)\n\n    return self.connection_from_pool_key(pool_key, request_context=request_context)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html#client.ayon_fusion.vendor.urllib3.poolmanager.PoolManager.connection_from_host","title":"<code>connection_from_host(host, port=None, scheme='http', pool_kwargs=None)</code>","text":"<p>Get a :class:<code>urllib3.connectionpool.ConnectionPool</code> based on the host, port, and scheme.</p> <p>If <code>port</code> isn't given, it will be derived from the <code>scheme</code> using <code>urllib3.connectionpool.port_by_scheme</code>. If <code>pool_kwargs</code> is provided, it is merged with the instance's <code>connection_pool_kw</code> variable and used to create the new connection pool, if one is needed.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def connection_from_host(self, host, port=None, scheme=\"http\", pool_kwargs=None):\n    \"\"\"\n    Get a :class:`urllib3.connectionpool.ConnectionPool` based on the host, port, and scheme.\n\n    If ``port`` isn't given, it will be derived from the ``scheme`` using\n    ``urllib3.connectionpool.port_by_scheme``. If ``pool_kwargs`` is\n    provided, it is merged with the instance's ``connection_pool_kw``\n    variable and used to create the new connection pool, if one is\n    needed.\n    \"\"\"\n\n    if not host:\n        raise LocationValueError(\"No host specified.\")\n\n    request_context = self._merge_pool_kwargs(pool_kwargs)\n    request_context[\"scheme\"] = scheme or \"http\"\n    if not port:\n        port = port_by_scheme.get(request_context[\"scheme\"].lower(), 80)\n    request_context[\"port\"] = port\n    request_context[\"host\"] = host\n\n    return self.connection_from_context(request_context)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html#client.ayon_fusion.vendor.urllib3.poolmanager.PoolManager.connection_from_pool_key","title":"<code>connection_from_pool_key(pool_key, request_context=None)</code>","text":"<p>Get a :class:<code>urllib3.connectionpool.ConnectionPool</code> based on the provided pool key.</p> <p><code>pool_key</code> should be a namedtuple that only contains immutable objects. At a minimum it must have the <code>scheme</code>, <code>host</code>, and <code>port</code> fields.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def connection_from_pool_key(self, pool_key, request_context=None):\n    \"\"\"\n    Get a :class:`urllib3.connectionpool.ConnectionPool` based on the provided pool key.\n\n    ``pool_key`` should be a namedtuple that only contains immutable\n    objects. At a minimum it must have the ``scheme``, ``host``, and\n    ``port`` fields.\n    \"\"\"\n    with self.pools.lock:\n        # If the scheme, host, or port doesn't match existing open\n        # connections, open a new ConnectionPool.\n        pool = self.pools.get(pool_key)\n        if pool:\n            return pool\n\n        # Make a fresh ConnectionPool of the desired type\n        scheme = request_context[\"scheme\"]\n        host = request_context[\"host\"]\n        port = request_context[\"port\"]\n        pool = self._new_pool(scheme, host, port, request_context=request_context)\n        self.pools[pool_key] = pool\n\n    return pool\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html#client.ayon_fusion.vendor.urllib3.poolmanager.PoolManager.connection_from_url","title":"<code>connection_from_url(url, pool_kwargs=None)</code>","text":"<p>Similar to :func:<code>urllib3.connectionpool.connection_from_url</code>.</p> <p>If <code>pool_kwargs</code> is not provided and a new pool needs to be constructed, <code>self.connection_pool_kw</code> is used to initialize the :class:<code>urllib3.connectionpool.ConnectionPool</code>. If <code>pool_kwargs</code> is provided, it is used instead. Note that if a new pool does not need to be created for the request, the provided <code>pool_kwargs</code> are not used.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def connection_from_url(self, url, pool_kwargs=None):\n    \"\"\"\n    Similar to :func:`urllib3.connectionpool.connection_from_url`.\n\n    If ``pool_kwargs`` is not provided and a new pool needs to be\n    constructed, ``self.connection_pool_kw`` is used to initialize\n    the :class:`urllib3.connectionpool.ConnectionPool`. If ``pool_kwargs``\n    is provided, it is used instead. Note that if a new pool does not\n    need to be created for the request, the provided ``pool_kwargs`` are\n    not used.\n    \"\"\"\n    u = parse_url(url)\n    return self.connection_from_host(\n        u.host, port=u.port, scheme=u.scheme, pool_kwargs=pool_kwargs\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html#client.ayon_fusion.vendor.urllib3.poolmanager.PoolManager.urlopen","title":"<code>urlopen(method, url, redirect=True, **kw)</code>","text":"<p>Same as :meth:<code>urllib3.HTTPConnectionPool.urlopen</code> with custom cross-host redirect logic and only sends the request-uri portion of the <code>url</code>.</p> <p>The given <code>url</code> parameter must be absolute, such that an appropriate :class:<code>urllib3.connectionpool.ConnectionPool</code> can be chosen for it.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def urlopen(self, method, url, redirect=True, **kw):\n    \"\"\"\n    Same as :meth:`urllib3.HTTPConnectionPool.urlopen`\n    with custom cross-host redirect logic and only sends the request-uri\n    portion of the ``url``.\n\n    The given ``url`` parameter must be absolute, such that an appropriate\n    :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.\n    \"\"\"\n    u = parse_url(url)\n    self._validate_proxy_scheme_url_selection(u.scheme)\n\n    conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)\n\n    kw[\"assert_same_host\"] = False\n    kw[\"redirect\"] = False\n\n    if \"headers\" not in kw:\n        kw[\"headers\"] = self.headers.copy()\n\n    if self._proxy_requires_url_absolute_form(u):\n        response = conn.urlopen(method, url, **kw)\n    else:\n        response = conn.urlopen(method, u.request_uri, **kw)\n\n    redirect_location = redirect and response.get_redirect_location()\n    if not redirect_location:\n        return response\n\n    # Support relative URLs for redirecting.\n    redirect_location = urljoin(url, redirect_location)\n\n    # RFC 7231, Section 6.4.4\n    if response.status == 303:\n        method = \"GET\"\n\n    retries = kw.get(\"retries\")\n    if not isinstance(retries, Retry):\n        retries = Retry.from_int(retries, redirect=redirect)\n\n    # Strip headers marked as unsafe to forward to the redirected location.\n    # Check remove_headers_on_redirect to avoid a potential network call within\n    # conn.is_same_host() which may use socket.gethostbyname() in the future.\n    if retries.remove_headers_on_redirect and not conn.is_same_host(\n        redirect_location\n    ):\n        headers = list(six.iterkeys(kw[\"headers\"]))\n        for header in headers:\n            if header.lower() in retries.remove_headers_on_redirect:\n                kw[\"headers\"].pop(header, None)\n\n    try:\n        retries = retries.increment(method, url, response=response, _pool=conn)\n    except MaxRetryError:\n        if retries.raise_on_redirect:\n            response.drain_conn()\n            raise\n        return response\n\n    kw[\"retries\"] = retries\n    kw[\"redirect\"] = redirect\n\n    log.info(\"Redirecting %s -&gt; %s\", url, redirect_location)\n\n    response.drain_conn()\n    return self.urlopen(method, redirect_location, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html#client.ayon_fusion.vendor.urllib3.poolmanager.ProxyManager","title":"<code>ProxyManager</code>","text":"<p>               Bases: <code>PoolManager</code></p> <p>Behaves just like :class:<code>PoolManager</code>, but sends all requests through the defined proxy, using the CONNECT method for HTTPS URLs.</p> <p>:param proxy_url:     The URL of the proxy to be used.</p> <p>:param proxy_headers:     A dictionary containing headers that will be sent to the proxy. In case     of HTTP they are being sent with each request, while in the     HTTPS/CONNECT case they are sent only once. Could be used for proxy     authentication.</p> <p>:param proxy_ssl_context:     The proxy SSL context is used to establish the TLS connection to the     proxy when using HTTPS proxies.</p> <p>:param use_forwarding_for_https:     (Defaults to False) If set to True will forward requests to the HTTPS     proxy to be made on behalf of the client instead of creating a TLS     tunnel via the CONNECT method. Enabling this flag means that request     and response headers and content will be visible from the HTTPS proxy     whereas tunneling keeps request and response headers and content     private.  IP address, target hostname, SNI, and port are always visible     to an HTTPS proxy even when this flag is disabled.</p> Example <p>proxy = urllib3.ProxyManager('http://localhost:3128/') r1 = proxy.request('GET', 'http://google.com/') r2 = proxy.request('GET', 'http://httpbin.org/') len(proxy.pools) 1 r3 = proxy.request('GET', 'https://httpbin.org/') r4 = proxy.request('GET', 'https://twitter.com/') len(proxy.pools) 3</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>class ProxyManager(PoolManager):\n    \"\"\"\n    Behaves just like :class:`PoolManager`, but sends all requests through\n    the defined proxy, using the CONNECT method for HTTPS URLs.\n\n    :param proxy_url:\n        The URL of the proxy to be used.\n\n    :param proxy_headers:\n        A dictionary containing headers that will be sent to the proxy. In case\n        of HTTP they are being sent with each request, while in the\n        HTTPS/CONNECT case they are sent only once. Could be used for proxy\n        authentication.\n\n    :param proxy_ssl_context:\n        The proxy SSL context is used to establish the TLS connection to the\n        proxy when using HTTPS proxies.\n\n    :param use_forwarding_for_https:\n        (Defaults to False) If set to True will forward requests to the HTTPS\n        proxy to be made on behalf of the client instead of creating a TLS\n        tunnel via the CONNECT method. **Enabling this flag means that request\n        and response headers and content will be visible from the HTTPS proxy**\n        whereas tunneling keeps request and response headers and content\n        private.  IP address, target hostname, SNI, and port are always visible\n        to an HTTPS proxy even when this flag is disabled.\n\n    Example:\n        &gt;&gt;&gt; proxy = urllib3.ProxyManager('http://localhost:3128/')\n        &gt;&gt;&gt; r1 = proxy.request('GET', 'http://google.com/')\n        &gt;&gt;&gt; r2 = proxy.request('GET', 'http://httpbin.org/')\n        &gt;&gt;&gt; len(proxy.pools)\n        1\n        &gt;&gt;&gt; r3 = proxy.request('GET', 'https://httpbin.org/')\n        &gt;&gt;&gt; r4 = proxy.request('GET', 'https://twitter.com/')\n        &gt;&gt;&gt; len(proxy.pools)\n        3\n\n    \"\"\"\n\n    def __init__(\n        self,\n        proxy_url,\n        num_pools=10,\n        headers=None,\n        proxy_headers=None,\n        proxy_ssl_context=None,\n        use_forwarding_for_https=False,\n        **connection_pool_kw\n    ):\n\n        if isinstance(proxy_url, HTTPConnectionPool):\n            proxy_url = \"%s://%s:%i\" % (\n                proxy_url.scheme,\n                proxy_url.host,\n                proxy_url.port,\n            )\n        proxy = parse_url(proxy_url)\n\n        if proxy.scheme not in (\"http\", \"https\"):\n            raise ProxySchemeUnknown(proxy.scheme)\n\n        if not proxy.port:\n            port = port_by_scheme.get(proxy.scheme, 80)\n            proxy = proxy._replace(port=port)\n\n        self.proxy = proxy\n        self.proxy_headers = proxy_headers or {}\n        self.proxy_ssl_context = proxy_ssl_context\n        self.proxy_config = ProxyConfig(proxy_ssl_context, use_forwarding_for_https)\n\n        connection_pool_kw[\"_proxy\"] = self.proxy\n        connection_pool_kw[\"_proxy_headers\"] = self.proxy_headers\n        connection_pool_kw[\"_proxy_config\"] = self.proxy_config\n\n        super(ProxyManager, self).__init__(num_pools, headers, **connection_pool_kw)\n\n    def connection_from_host(self, host, port=None, scheme=\"http\", pool_kwargs=None):\n        if scheme == \"https\":\n            return super(ProxyManager, self).connection_from_host(\n                host, port, scheme, pool_kwargs=pool_kwargs\n            )\n\n        return super(ProxyManager, self).connection_from_host(\n            self.proxy.host, self.proxy.port, self.proxy.scheme, pool_kwargs=pool_kwargs\n        )\n\n    def _set_proxy_headers(self, url, headers=None):\n        \"\"\"\n        Sets headers needed by proxies: specifically, the Accept and Host\n        headers. Only sets headers not provided by the user.\n        \"\"\"\n        headers_ = {\"Accept\": \"*/*\"}\n\n        netloc = parse_url(url).netloc\n        if netloc:\n            headers_[\"Host\"] = netloc\n\n        if headers:\n            headers_.update(headers)\n        return headers_\n\n    def urlopen(self, method, url, redirect=True, **kw):\n        \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n        u = parse_url(url)\n        if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):\n            # For connections using HTTP CONNECT, httplib sets the necessary\n            # headers on the CONNECT to the proxy. If we're not using CONNECT,\n            # we'll definitely need to set 'Host' at the very least.\n            headers = kw.get(\"headers\", self.headers)\n            kw[\"headers\"] = self._set_proxy_headers(url, headers)\n\n        return super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/poolmanager.html#client.ayon_fusion.vendor.urllib3.poolmanager.ProxyManager.urlopen","title":"<code>urlopen(method, url, redirect=True, **kw)</code>","text":"<p>Same as HTTP(S)ConnectionPool.urlopen, <code>url</code> must be absolute.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/poolmanager.py</code> <pre><code>def urlopen(self, method, url, redirect=True, **kw):\n    \"Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute.\"\n    u = parse_url(url)\n    if not connection_requires_http_tunnel(self.proxy, self.proxy_config, u.scheme):\n        # For connections using HTTP CONNECT, httplib sets the necessary\n        # headers on the CONNECT to the proxy. If we're not using CONNECT,\n        # we'll definitely need to set 'Host' at the very least.\n        headers = kw.get(\"headers\", self.headers)\n        kw[\"headers\"] = self._set_proxy_headers(url, headers)\n\n    return super(ProxyManager, self).urlopen(method, url, redirect=redirect, **kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/request.html","title":"request","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/request.html#client.ayon_fusion.vendor.urllib3.request.RequestMethods","title":"<code>RequestMethods</code>","text":"<p>               Bases: <code>object</code></p> <p>Convenience mixin for classes who implement a :meth:<code>urlopen</code> method, such as :class:<code>urllib3.HTTPConnectionPool</code> and :class:<code>urllib3.PoolManager</code>.</p> <p>Provides behavior for making common types of HTTP request methods and decides which type of request field encoding to use.</p> <p>Specifically,</p> <p>:meth:<code>.request_encode_url</code> is for sending requests whose fields are encoded in the URL (such as GET, HEAD, DELETE).</p> <p>:meth:<code>.request_encode_body</code> is for sending requests whose fields are encoded in the body of the request using multipart or www-form-urlencoded (such as for POST, PUT, PATCH).</p> <p>:meth:<code>.request</code> is for making any kind of request, it will look up the appropriate encoding format and use one of the above two methods to make the request.</p> <p>Initializer parameters:</p> <p>:param headers:     Headers to include with all requests, unless other headers are given     explicitly.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/request.py</code> <pre><code>class RequestMethods(object):\n    \"\"\"\n    Convenience mixin for classes who implement a :meth:`urlopen` method, such\n    as :class:`urllib3.HTTPConnectionPool` and\n    :class:`urllib3.PoolManager`.\n\n    Provides behavior for making common types of HTTP request methods and\n    decides which type of request field encoding to use.\n\n    Specifically,\n\n    :meth:`.request_encode_url` is for sending requests whose fields are\n    encoded in the URL (such as GET, HEAD, DELETE).\n\n    :meth:`.request_encode_body` is for sending requests whose fields are\n    encoded in the *body* of the request using multipart or www-form-urlencoded\n    (such as for POST, PUT, PATCH).\n\n    :meth:`.request` is for making any kind of request, it will look up the\n    appropriate encoding format and use one of the above two methods to make\n    the request.\n\n    Initializer parameters:\n\n    :param headers:\n        Headers to include with all requests, unless other headers are given\n        explicitly.\n    \"\"\"\n\n    _encode_url_methods = {\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\"}\n\n    def __init__(self, headers=None):\n        self.headers = headers or {}\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        encode_multipart=True,\n        multipart_boundary=None,\n        **kw\n    ):  # Abstract\n        raise NotImplementedError(\n            \"Classes extending RequestMethods must implement \"\n            \"their own ``urlopen`` method.\"\n        )\n\n    def request(self, method, url, fields=None, headers=None, **urlopen_kw):\n        \"\"\"\n        Make a request using :meth:`urlopen` with the appropriate encoding of\n        ``fields`` based on the ``method`` used.\n\n        This is a convenience method that requires the least amount of manual\n        effort. It can be used in most situations, while still having the\n        option to drop down to more specific methods when necessary, such as\n        :meth:`request_encode_url`, :meth:`request_encode_body`,\n        or even the lowest level :meth:`urlopen`.\n        \"\"\"\n        method = method.upper()\n\n        urlopen_kw[\"request_url\"] = url\n\n        if method in self._encode_url_methods:\n            return self.request_encode_url(\n                method, url, fields=fields, headers=headers, **urlopen_kw\n            )\n        else:\n            return self.request_encode_body(\n                method, url, fields=fields, headers=headers, **urlopen_kw\n            )\n\n    def request_encode_url(self, method, url, fields=None, headers=None, **urlopen_kw):\n        \"\"\"\n        Make a request using :meth:`urlopen` with the ``fields`` encoded in\n        the url. This is useful for request methods like GET, HEAD, DELETE, etc.\n        \"\"\"\n        if headers is None:\n            headers = self.headers\n\n        extra_kw = {\"headers\": headers}\n        extra_kw.update(urlopen_kw)\n\n        if fields:\n            url += \"?\" + urlencode(fields)\n\n        return self.urlopen(method, url, **extra_kw)\n\n    def request_encode_body(\n        self,\n        method,\n        url,\n        fields=None,\n        headers=None,\n        encode_multipart=True,\n        multipart_boundary=None,\n        **urlopen_kw\n    ):\n        \"\"\"\n        Make a request using :meth:`urlopen` with the ``fields`` encoded in\n        the body. This is useful for request methods like POST, PUT, PATCH, etc.\n\n        When ``encode_multipart=True`` (default), then\n        :func:`urllib3.encode_multipart_formdata` is used to encode\n        the payload with the appropriate content type. Otherwise\n        :func:`urllib.parse.urlencode` is used with the\n        'application/x-www-form-urlencoded' content type.\n\n        Multipart encoding must be used when posting files, and it's reasonably\n        safe to use it in other times too. However, it may break request\n        signing, such as with OAuth.\n\n        Supports an optional ``fields`` parameter of key/value strings AND\n        key/filetuple. A filetuple is a (filename, data, MIME type) tuple where\n        the MIME type is optional. For example::\n\n            fields = {\n                'foo': 'bar',\n                'fakefile': ('foofile.txt', 'contents of foofile'),\n                'realfile': ('barfile.txt', open('realfile').read()),\n                'typedfile': ('bazfile.bin', open('bazfile').read(),\n                              'image/jpeg'),\n                'nonamefile': 'contents of nonamefile field',\n            }\n\n        When uploading a file, providing a filename (the first parameter of the\n        tuple) is optional but recommended to best mimic behavior of browsers.\n\n        Note that if ``headers`` are supplied, the 'Content-Type' header will\n        be overwritten because it depends on the dynamic random boundary string\n        which is used to compose the body of the request. The random boundary\n        string can be explicitly set with the ``multipart_boundary`` parameter.\n        \"\"\"\n        if headers is None:\n            headers = self.headers\n\n        extra_kw = {\"headers\": {}}\n\n        if fields:\n            if \"body\" in urlopen_kw:\n                raise TypeError(\n                    \"request got values for both 'fields' and 'body', can only specify one.\"\n                )\n\n            if encode_multipart:\n                body, content_type = encode_multipart_formdata(\n                    fields, boundary=multipart_boundary\n                )\n            else:\n                body, content_type = (\n                    urlencode(fields),\n                    \"application/x-www-form-urlencoded\",\n                )\n\n            extra_kw[\"body\"] = body\n            extra_kw[\"headers\"] = {\"Content-Type\": content_type}\n\n        extra_kw[\"headers\"].update(headers)\n        extra_kw.update(urlopen_kw)\n\n        return self.urlopen(method, url, **extra_kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/request.html#client.ayon_fusion.vendor.urllib3.request.RequestMethods.request","title":"<code>request(method, url, fields=None, headers=None, **urlopen_kw)</code>","text":"<p>Make a request using :meth:<code>urlopen</code> with the appropriate encoding of <code>fields</code> based on the <code>method</code> used.</p> <p>This is a convenience method that requires the least amount of manual effort. It can be used in most situations, while still having the option to drop down to more specific methods when necessary, such as :meth:<code>request_encode_url</code>, :meth:<code>request_encode_body</code>, or even the lowest level :meth:<code>urlopen</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/request.py</code> <pre><code>def request(self, method, url, fields=None, headers=None, **urlopen_kw):\n    \"\"\"\n    Make a request using :meth:`urlopen` with the appropriate encoding of\n    ``fields`` based on the ``method`` used.\n\n    This is a convenience method that requires the least amount of manual\n    effort. It can be used in most situations, while still having the\n    option to drop down to more specific methods when necessary, such as\n    :meth:`request_encode_url`, :meth:`request_encode_body`,\n    or even the lowest level :meth:`urlopen`.\n    \"\"\"\n    method = method.upper()\n\n    urlopen_kw[\"request_url\"] = url\n\n    if method in self._encode_url_methods:\n        return self.request_encode_url(\n            method, url, fields=fields, headers=headers, **urlopen_kw\n        )\n    else:\n        return self.request_encode_body(\n            method, url, fields=fields, headers=headers, **urlopen_kw\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/request.html#client.ayon_fusion.vendor.urllib3.request.RequestMethods.request_encode_body","title":"<code>request_encode_body(method, url, fields=None, headers=None, encode_multipart=True, multipart_boundary=None, **urlopen_kw)</code>","text":"<p>Make a request using :meth:<code>urlopen</code> with the <code>fields</code> encoded in the body. This is useful for request methods like POST, PUT, PATCH, etc.</p> <p>When <code>encode_multipart=True</code> (default), then :func:<code>urllib3.encode_multipart_formdata</code> is used to encode the payload with the appropriate content type. Otherwise :func:<code>urllib.parse.urlencode</code> is used with the 'application/x-www-form-urlencoded' content type.</p> <p>Multipart encoding must be used when posting files, and it's reasonably safe to use it in other times too. However, it may break request signing, such as with OAuth.</p> <p>Supports an optional <code>fields</code> parameter of key/value strings AND key/filetuple. A filetuple is a (filename, data, MIME type) tuple where the MIME type is optional. For example::</p> <pre><code>fields = {\n    'foo': 'bar',\n    'fakefile': ('foofile.txt', 'contents of foofile'),\n    'realfile': ('barfile.txt', open('realfile').read()),\n    'typedfile': ('bazfile.bin', open('bazfile').read(),\n                  'image/jpeg'),\n    'nonamefile': 'contents of nonamefile field',\n}\n</code></pre> <p>When uploading a file, providing a filename (the first parameter of the tuple) is optional but recommended to best mimic behavior of browsers.</p> <p>Note that if <code>headers</code> are supplied, the 'Content-Type' header will be overwritten because it depends on the dynamic random boundary string which is used to compose the body of the request. The random boundary string can be explicitly set with the <code>multipart_boundary</code> parameter.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/request.py</code> <pre><code>def request_encode_body(\n    self,\n    method,\n    url,\n    fields=None,\n    headers=None,\n    encode_multipart=True,\n    multipart_boundary=None,\n    **urlopen_kw\n):\n    \"\"\"\n    Make a request using :meth:`urlopen` with the ``fields`` encoded in\n    the body. This is useful for request methods like POST, PUT, PATCH, etc.\n\n    When ``encode_multipart=True`` (default), then\n    :func:`urllib3.encode_multipart_formdata` is used to encode\n    the payload with the appropriate content type. Otherwise\n    :func:`urllib.parse.urlencode` is used with the\n    'application/x-www-form-urlencoded' content type.\n\n    Multipart encoding must be used when posting files, and it's reasonably\n    safe to use it in other times too. However, it may break request\n    signing, such as with OAuth.\n\n    Supports an optional ``fields`` parameter of key/value strings AND\n    key/filetuple. A filetuple is a (filename, data, MIME type) tuple where\n    the MIME type is optional. For example::\n\n        fields = {\n            'foo': 'bar',\n            'fakefile': ('foofile.txt', 'contents of foofile'),\n            'realfile': ('barfile.txt', open('realfile').read()),\n            'typedfile': ('bazfile.bin', open('bazfile').read(),\n                          'image/jpeg'),\n            'nonamefile': 'contents of nonamefile field',\n        }\n\n    When uploading a file, providing a filename (the first parameter of the\n    tuple) is optional but recommended to best mimic behavior of browsers.\n\n    Note that if ``headers`` are supplied, the 'Content-Type' header will\n    be overwritten because it depends on the dynamic random boundary string\n    which is used to compose the body of the request. The random boundary\n    string can be explicitly set with the ``multipart_boundary`` parameter.\n    \"\"\"\n    if headers is None:\n        headers = self.headers\n\n    extra_kw = {\"headers\": {}}\n\n    if fields:\n        if \"body\" in urlopen_kw:\n            raise TypeError(\n                \"request got values for both 'fields' and 'body', can only specify one.\"\n            )\n\n        if encode_multipart:\n            body, content_type = encode_multipart_formdata(\n                fields, boundary=multipart_boundary\n            )\n        else:\n            body, content_type = (\n                urlencode(fields),\n                \"application/x-www-form-urlencoded\",\n            )\n\n        extra_kw[\"body\"] = body\n        extra_kw[\"headers\"] = {\"Content-Type\": content_type}\n\n    extra_kw[\"headers\"].update(headers)\n    extra_kw.update(urlopen_kw)\n\n    return self.urlopen(method, url, **extra_kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/request.html#client.ayon_fusion.vendor.urllib3.request.RequestMethods.request_encode_url","title":"<code>request_encode_url(method, url, fields=None, headers=None, **urlopen_kw)</code>","text":"<p>Make a request using :meth:<code>urlopen</code> with the <code>fields</code> encoded in the url. This is useful for request methods like GET, HEAD, DELETE, etc.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/request.py</code> <pre><code>def request_encode_url(self, method, url, fields=None, headers=None, **urlopen_kw):\n    \"\"\"\n    Make a request using :meth:`urlopen` with the ``fields`` encoded in\n    the url. This is useful for request methods like GET, HEAD, DELETE, etc.\n    \"\"\"\n    if headers is None:\n        headers = self.headers\n\n    extra_kw = {\"headers\": headers}\n    extra_kw.update(urlopen_kw)\n\n    if fields:\n        url += \"?\" + urlencode(fields)\n\n    return self.urlopen(method, url, **extra_kw)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html","title":"response","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse","title":"<code>HTTPResponse</code>","text":"<p>               Bases: <code>IOBase</code></p> <p>HTTP Response container.</p> <p>Backwards-compatible with :class:<code>http.client.HTTPResponse</code> but the response <code>body</code> is loaded and decoded on-demand when the <code>data</code> property is accessed.  This class is also compatible with the Python standard library's :mod:<code>io</code> module, and can hence be treated as a readable object in the context of that framework.</p> <p>Extra parameters for behaviour not present in :class:<code>http.client.HTTPResponse</code>:</p> <p>:param preload_content:     If True, the response's body will be preloaded during construction.</p> <p>:param decode_content:     If True, will attempt to decode the body based on the     'content-encoding' header.</p> <p>:param original_response:     When this HTTPResponse wrapper is generated from an :class:<code>http.client.HTTPResponse</code>     object, it's convenient to include the original for debug purposes. It's     otherwise unused.</p> <p>:param retries:     The retries contains the last :class:<code>~urllib3.util.retry.Retry</code> that     was used during the request.</p> <p>:param enforce_content_length:     Enforce content length checking. Body returned by server must match     value of Content-Length header, if present. Otherwise, raise error.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>class HTTPResponse(io.IOBase):\n    \"\"\"\n    HTTP Response container.\n\n    Backwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is\n    loaded and decoded on-demand when the ``data`` property is accessed.  This\n    class is also compatible with the Python standard library's :mod:`io`\n    module, and can hence be treated as a readable object in the context of that\n    framework.\n\n    Extra parameters for behaviour not present in :class:`http.client.HTTPResponse`:\n\n    :param preload_content:\n        If True, the response's body will be preloaded during construction.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n\n    :param original_response:\n        When this HTTPResponse wrapper is generated from an :class:`http.client.HTTPResponse`\n        object, it's convenient to include the original for debug purposes. It's\n        otherwise unused.\n\n    :param retries:\n        The retries contains the last :class:`~urllib3.util.retry.Retry` that\n        was used during the request.\n\n    :param enforce_content_length:\n        Enforce content length checking. Body returned by server must match\n        value of Content-Length header, if present. Otherwise, raise error.\n    \"\"\"\n\n    CONTENT_DECODERS = [\"gzip\", \"deflate\"]\n    if brotli is not None:\n        CONTENT_DECODERS += [\"br\"]\n    REDIRECT_STATUSES = [301, 302, 303, 307, 308]\n\n    def __init__(\n        self,\n        body=\"\",\n        headers=None,\n        status=0,\n        version=0,\n        reason=None,\n        strict=0,\n        preload_content=True,\n        decode_content=True,\n        original_response=None,\n        pool=None,\n        connection=None,\n        msg=None,\n        retries=None,\n        enforce_content_length=False,\n        request_method=None,\n        request_url=None,\n        auto_close=True,\n    ):\n\n        if isinstance(headers, HTTPHeaderDict):\n            self.headers = headers\n        else:\n            self.headers = HTTPHeaderDict(headers)\n        self.status = status\n        self.version = version\n        self.reason = reason\n        self.strict = strict\n        self.decode_content = decode_content\n        self.retries = retries\n        self.enforce_content_length = enforce_content_length\n        self.auto_close = auto_close\n\n        self._decoder = None\n        self._body = None\n        self._fp = None\n        self._original_response = original_response\n        self._fp_bytes_read = 0\n        self.msg = msg\n        self._request_url = request_url\n\n        if body and isinstance(body, (six.string_types, bytes)):\n            self._body = body\n\n        self._pool = pool\n        self._connection = connection\n\n        if hasattr(body, \"read\"):\n            self._fp = body\n\n        # Are we using the chunked-style of transfer encoding?\n        self.chunked = False\n        self.chunk_left = None\n        tr_enc = self.headers.get(\"transfer-encoding\", \"\").lower()\n        # Don't incur the penalty of creating a list and then discarding it\n        encodings = (enc.strip() for enc in tr_enc.split(\",\"))\n        if \"chunked\" in encodings:\n            self.chunked = True\n\n        # Determine length of response\n        self.length_remaining = self._init_length(request_method)\n\n        # If requested, preload the body.\n        if preload_content and not self._body:\n            self._body = self.read(decode_content=decode_content)\n\n    def get_redirect_location(self):\n        \"\"\"\n        Should we redirect and where to?\n\n        :returns: Truthy redirect location string if we got a redirect status\n            code and valid location. ``None`` if redirect status and no\n            location. ``False`` if not a redirect status code.\n        \"\"\"\n        if self.status in self.REDIRECT_STATUSES:\n            return self.headers.get(\"location\")\n\n        return False\n\n    def release_conn(self):\n        if not self._pool or not self._connection:\n            return\n\n        self._pool._put_conn(self._connection)\n        self._connection = None\n\n    def drain_conn(self):\n        \"\"\"\n        Read and discard any remaining HTTP response data in the response connection.\n\n        Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.\n        \"\"\"\n        try:\n            self.read()\n        except (HTTPError, SocketError, BaseSSLError, HTTPException):\n            pass\n\n    @property\n    def data(self):\n        # For backwards-compat with earlier urllib3 0.4 and earlier.\n        if self._body:\n            return self._body\n\n        if self._fp:\n            return self.read(cache_content=True)\n\n    @property\n    def connection(self):\n        return self._connection\n\n    def isclosed(self):\n        return is_fp_closed(self._fp)\n\n    def tell(self):\n        \"\"\"\n        Obtain the number of bytes pulled over the wire so far. May differ from\n        the amount of content returned by :meth:``urllib3.response.HTTPResponse.read``\n        if bytes are encoded on the wire (e.g, compressed).\n        \"\"\"\n        return self._fp_bytes_read\n\n    def _init_length(self, request_method):\n        \"\"\"\n        Set initial length value for Response content if available.\n        \"\"\"\n        length = self.headers.get(\"content-length\")\n\n        if length is not None:\n            if self.chunked:\n                # This Response will fail with an IncompleteRead if it can't be\n                # received as chunked. This method falls back to attempt reading\n                # the response before raising an exception.\n                log.warning(\n                    \"Received response with both Content-Length and \"\n                    \"Transfer-Encoding set. This is expressly forbidden \"\n                    \"by RFC 7230 sec 3.3.2. Ignoring Content-Length and \"\n                    \"attempting to process response as Transfer-Encoding: \"\n                    \"chunked.\"\n                )\n                return None\n\n            try:\n                # RFC 7230 section 3.3.2 specifies multiple content lengths can\n                # be sent in a single Content-Length header\n                # (e.g. Content-Length: 42, 42). This line ensures the values\n                # are all valid ints and that as long as the `set` length is 1,\n                # all values are the same. Otherwise, the header is invalid.\n                lengths = set([int(val) for val in length.split(\",\")])\n                if len(lengths) &gt; 1:\n                    raise InvalidHeader(\n                        \"Content-Length contained multiple \"\n                        \"unmatching values (%s)\" % length\n                    )\n                length = lengths.pop()\n            except ValueError:\n                length = None\n            else:\n                if length &lt; 0:\n                    length = None\n\n        # Convert status to int for comparison\n        # In some cases, httplib returns a status of \"_UNKNOWN\"\n        try:\n            status = int(self.status)\n        except ValueError:\n            status = 0\n\n        # Check for responses that shouldn't include a body\n        if status in (204, 304) or 100 &lt;= status &lt; 200 or request_method == \"HEAD\":\n            length = 0\n\n        return length\n\n    def _init_decoder(self):\n        \"\"\"\n        Set-up the _decoder attribute if necessary.\n        \"\"\"\n        # Note: content-encoding value should be case-insensitive, per RFC 7230\n        # Section 3.2\n        content_encoding = self.headers.get(\"content-encoding\", \"\").lower()\n        if self._decoder is None:\n            if content_encoding in self.CONTENT_DECODERS:\n                self._decoder = _get_decoder(content_encoding)\n            elif \",\" in content_encoding:\n                encodings = [\n                    e.strip()\n                    for e in content_encoding.split(\",\")\n                    if e.strip() in self.CONTENT_DECODERS\n                ]\n                if len(encodings):\n                    self._decoder = _get_decoder(content_encoding)\n\n    DECODER_ERROR_CLASSES = (IOError, zlib.error)\n    if brotli is not None:\n        DECODER_ERROR_CLASSES += (brotli.error,)\n\n    def _decode(self, data, decode_content, flush_decoder):\n        \"\"\"\n        Decode the data passed in and potentially flush the decoder.\n        \"\"\"\n        if not decode_content:\n            return data\n\n        try:\n            if self._decoder:\n                data = self._decoder.decompress(data)\n        except self.DECODER_ERROR_CLASSES as e:\n            content_encoding = self.headers.get(\"content-encoding\", \"\").lower()\n            raise DecodeError(\n                \"Received response with content-encoding: %s, but \"\n                \"failed to decode it.\" % content_encoding,\n                e,\n            )\n        if flush_decoder:\n            data += self._flush_decoder()\n\n        return data\n\n    def _flush_decoder(self):\n        \"\"\"\n        Flushes the decoder. Should only be called if the decoder is actually\n        being used.\n        \"\"\"\n        if self._decoder:\n            buf = self._decoder.decompress(b\"\")\n            return buf + self._decoder.flush()\n\n        return b\"\"\n\n    @contextmanager\n    def _error_catcher(self):\n        \"\"\"\n        Catch low-level python exceptions, instead re-raising urllib3\n        variants, so that low-level exceptions are not leaked in the\n        high-level api.\n\n        On exit, release the connection back to the pool.\n        \"\"\"\n        clean_exit = False\n\n        try:\n            try:\n                yield\n\n            except SocketTimeout:\n                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but\n                # there is yet no clean way to get at it from this context.\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n\n            except BaseSSLError as e:\n                # FIXME: Is there a better way to differentiate between SSLErrors?\n                if \"read operation timed out\" not in str(e):\n                    # SSL errors related to framing/MAC get wrapped and reraised here\n                    raise SSLError(e)\n\n                raise ReadTimeoutError(self._pool, None, \"Read timed out.\")\n\n            except (HTTPException, SocketError) as e:\n                # This includes IncompleteRead.\n                raise ProtocolError(\"Connection broken: %r\" % e, e)\n\n            # If no exception is thrown, we should avoid cleaning up\n            # unnecessarily.\n            clean_exit = True\n        finally:\n            # If we didn't terminate cleanly, we need to throw away our\n            # connection.\n            if not clean_exit:\n                # The response may not be closed but we're not going to use it\n                # anymore so close it now to ensure that the connection is\n                # released back to the pool.\n                if self._original_response:\n                    self._original_response.close()\n\n                # Closing the response may not actually be sufficient to close\n                # everything, so if we have a hold of the connection close that\n                # too.\n                if self._connection:\n                    self._connection.close()\n\n            # If we hold the original response but it's closed now, we should\n            # return the connection back to the pool.\n            if self._original_response and self._original_response.isclosed():\n                self.release_conn()\n\n    def read(self, amt=None, decode_content=None, cache_content=False):\n        \"\"\"\n        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n        parameters: ``decode_content`` and ``cache_content``.\n\n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n\n        :param cache_content:\n            If True, will save the returned data such that the same result is\n            returned despite of the state of the underlying file object. This\n            is useful if you want the ``.data`` property to continue working\n            after having ``.read()`` the file object. (Overridden if ``amt`` is\n            set.)\n        \"\"\"\n        self._init_decoder()\n        if decode_content is None:\n            decode_content = self.decode_content\n\n        if self._fp is None:\n            return\n\n        flush_decoder = False\n        fp_closed = getattr(self._fp, \"closed\", False)\n\n        with self._error_catcher():\n            if amt is None:\n                # cStringIO doesn't like amt=None\n                data = self._fp.read() if not fp_closed else b\"\"\n                flush_decoder = True\n            else:\n                cache_content = False\n                data = self._fp.read(amt) if not fp_closed else b\"\"\n                if (\n                    amt != 0 and not data\n                ):  # Platform-specific: Buggy versions of Python.\n                    # Close the connection when no data is returned\n                    #\n                    # This is redundant to what httplib/http.client _should_\n                    # already do.  However, versions of python released before\n                    # December 15, 2012 (http://bugs.python.org/issue16298) do\n                    # not properly close the connection in all cases. There is\n                    # no harm in redundantly calling close.\n                    self._fp.close()\n                    flush_decoder = True\n                    if self.enforce_content_length and self.length_remaining not in (\n                        0,\n                        None,\n                    ):\n                        # This is an edge case that httplib failed to cover due\n                        # to concerns of backward compatibility. We're\n                        # addressing it here to make sure IncompleteRead is\n                        # raised during streaming, so all calls with incorrect\n                        # Content-Length are caught.\n                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n\n        if data:\n            self._fp_bytes_read += len(data)\n            if self.length_remaining is not None:\n                self.length_remaining -= len(data)\n\n            data = self._decode(data, decode_content, flush_decoder)\n\n            if cache_content:\n                self._body = data\n\n        return data\n\n    def stream(self, amt=2 ** 16, decode_content=None):\n        \"\"\"\n        A generator wrapper for the read() method. A call will block until\n        ``amt`` bytes have been read from the connection or until the\n        connection is closed.\n\n        :param amt:\n            How much of the content to read. The generator will return up to\n            much data per iteration, but may return less. This is particularly\n            likely when using compressed data. However, the empty string will\n            never be returned.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        if self.chunked and self.supports_chunked_reads():\n            for line in self.read_chunked(amt, decode_content=decode_content):\n                yield line\n        else:\n            while not is_fp_closed(self._fp):\n                data = self.read(amt=amt, decode_content=decode_content)\n\n                if data:\n                    yield data\n\n    @classmethod\n    def from_httplib(ResponseCls, r, **response_kw):\n        \"\"\"\n        Given an :class:`http.client.HTTPResponse` instance ``r``, return a\n        corresponding :class:`urllib3.response.HTTPResponse` object.\n\n        Remaining parameters are passed to the HTTPResponse constructor, along\n        with ``original_response=r``.\n        \"\"\"\n        headers = r.msg\n\n        if not isinstance(headers, HTTPHeaderDict):\n            if six.PY2:\n                # Python 2.7\n                headers = HTTPHeaderDict.from_httplib(headers)\n            else:\n                headers = HTTPHeaderDict(headers.items())\n\n        # HTTPResponse objects in Python 3 don't have a .strict attribute\n        strict = getattr(r, \"strict\", 0)\n        resp = ResponseCls(\n            body=r,\n            headers=headers,\n            status=r.status,\n            version=r.version,\n            reason=r.reason,\n            strict=strict,\n            original_response=r,\n            **response_kw\n        )\n        return resp\n\n    # Backwards-compatibility methods for http.client.HTTPResponse\n    def getheaders(self):\n        return self.headers\n\n    def getheader(self, name, default=None):\n        return self.headers.get(name, default)\n\n    # Backwards compatibility for http.cookiejar\n    def info(self):\n        return self.headers\n\n    # Overrides from io.IOBase\n    def close(self):\n        if not self.closed:\n            self._fp.close()\n\n        if self._connection:\n            self._connection.close()\n\n        if not self.auto_close:\n            io.IOBase.close(self)\n\n    @property\n    def closed(self):\n        if not self.auto_close:\n            return io.IOBase.closed.__get__(self)\n        elif self._fp is None:\n            return True\n        elif hasattr(self._fp, \"isclosed\"):\n            return self._fp.isclosed()\n        elif hasattr(self._fp, \"closed\"):\n            return self._fp.closed\n        else:\n            return True\n\n    def fileno(self):\n        if self._fp is None:\n            raise IOError(\"HTTPResponse has no file to get a fileno from\")\n        elif hasattr(self._fp, \"fileno\"):\n            return self._fp.fileno()\n        else:\n            raise IOError(\n                \"The file-like object this HTTPResponse is wrapped \"\n                \"around has no file descriptor\"\n            )\n\n    def flush(self):\n        if (\n            self._fp is not None\n            and hasattr(self._fp, \"flush\")\n            and not getattr(self._fp, \"closed\", False)\n        ):\n            return self._fp.flush()\n\n    def readable(self):\n        # This method is required for `io` module compatibility.\n        return True\n\n    def readinto(self, b):\n        # This method is required for `io` module compatibility.\n        temp = self.read(len(b))\n        if len(temp) == 0:\n            return 0\n        else:\n            b[: len(temp)] = temp\n            return len(temp)\n\n    def supports_chunked_reads(self):\n        \"\"\"\n        Checks if the underlying file-like object looks like a\n        :class:`http.client.HTTPResponse` object. We do this by testing for\n        the fp attribute. If it is present we assume it returns raw chunks as\n        processed by read_chunked().\n        \"\"\"\n        return hasattr(self._fp, \"fp\")\n\n    def _update_chunk_length(self):\n        # First, we'll figure out length of a chunk and then\n        # we'll try to read it from socket.\n        if self.chunk_left is not None:\n            return\n        line = self._fp.fp.readline()\n        line = line.split(b\";\", 1)[0]\n        try:\n            self.chunk_left = int(line, 16)\n        except ValueError:\n            # Invalid chunked protocol response, abort.\n            self.close()\n            raise InvalidChunkLength(self, line)\n\n    def _handle_chunk(self, amt):\n        returned_chunk = None\n        if amt is None:\n            chunk = self._fp._safe_read(self.chunk_left)\n            returned_chunk = chunk\n            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n        elif amt &lt; self.chunk_left:\n            value = self._fp._safe_read(amt)\n            self.chunk_left = self.chunk_left - amt\n            returned_chunk = value\n        elif amt == self.chunk_left:\n            value = self._fp._safe_read(amt)\n            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n            returned_chunk = value\n        else:  # amt &gt; self.chunk_left\n            returned_chunk = self._fp._safe_read(self.chunk_left)\n            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.\n            self.chunk_left = None\n        return returned_chunk\n\n    def read_chunked(self, amt=None, decode_content=None):\n        \"\"\"\n        Similar to :meth:`HTTPResponse.read`, but with an additional\n        parameter: ``decode_content``.\n\n        :param amt:\n            How much of the content to read. If specified, caching is skipped\n            because it doesn't make sense to cache partial content as the full\n            response.\n\n        :param decode_content:\n            If True, will attempt to decode the body based on the\n            'content-encoding' header.\n        \"\"\"\n        self._init_decoder()\n        # FIXME: Rewrite this method and make it a class with a better structured logic.\n        if not self.chunked:\n            raise ResponseNotChunked(\n                \"Response is not chunked. \"\n                \"Header 'transfer-encoding: chunked' is missing.\"\n            )\n        if not self.supports_chunked_reads():\n            raise BodyNotHttplibCompatible(\n                \"Body should be http.client.HTTPResponse like. \"\n                \"It should have have an fp attribute which returns raw chunks.\"\n            )\n\n        with self._error_catcher():\n            # Don't bother reading the body of a HEAD request.\n            if self._original_response and is_response_to_head(self._original_response):\n                self._original_response.close()\n                return\n\n            # If a response is already read and closed\n            # then return immediately.\n            if self._fp.fp is None:\n                return\n\n            while True:\n                self._update_chunk_length()\n                if self.chunk_left == 0:\n                    break\n                chunk = self._handle_chunk(amt)\n                decoded = self._decode(\n                    chunk, decode_content=decode_content, flush_decoder=False\n                )\n                if decoded:\n                    yield decoded\n\n            if decode_content:\n                # On CPython and PyPy, we should never need to flush the\n                # decoder. However, on Jython we *might* need to, so\n                # lets defensively do it anyway.\n                decoded = self._flush_decoder()\n                if decoded:  # Platform-specific: Jython.\n                    yield decoded\n\n            # Chunk content ends with \\r\\n: discard it.\n            while True:\n                line = self._fp.fp.readline()\n                if not line:\n                    # Some sites may not end with '\\r\\n'.\n                    break\n                if line == b\"\\r\\n\":\n                    break\n\n            # We read everything; close the \"file\".\n            if self._original_response:\n                self._original_response.close()\n\n    def geturl(self):\n        \"\"\"\n        Returns the URL that was the source of this response.\n        If the request that generated this response redirected, this method\n        will return the final redirect location.\n        \"\"\"\n        if self.retries is not None and len(self.retries.history):\n            return self.retries.history[-1].redirect_location\n        else:\n            return self._request_url\n\n    def __iter__(self):\n        buffer = []\n        for chunk in self.stream(decode_content=True):\n            if b\"\\n\" in chunk:\n                chunk = chunk.split(b\"\\n\")\n                yield b\"\".join(buffer) + chunk[0] + b\"\\n\"\n                for x in chunk[1:-1]:\n                    yield x + b\"\\n\"\n                if chunk[-1]:\n                    buffer = [chunk[-1]]\n                else:\n                    buffer = []\n            else:\n                buffer.append(chunk)\n        if buffer:\n            yield b\"\".join(buffer)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse.drain_conn","title":"<code>drain_conn()</code>","text":"<p>Read and discard any remaining HTTP response data in the response connection.</p> <p>Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def drain_conn(self):\n    \"\"\"\n    Read and discard any remaining HTTP response data in the response connection.\n\n    Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.\n    \"\"\"\n    try:\n        self.read()\n    except (HTTPError, SocketError, BaseSSLError, HTTPException):\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse.from_httplib","title":"<code>from_httplib(ResponseCls, r, **response_kw)</code>  <code>classmethod</code>","text":"<p>Given an :class:<code>http.client.HTTPResponse</code> instance <code>r</code>, return a corresponding :class:<code>urllib3.response.HTTPResponse</code> object.</p> <p>Remaining parameters are passed to the HTTPResponse constructor, along with <code>original_response=r</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>@classmethod\ndef from_httplib(ResponseCls, r, **response_kw):\n    \"\"\"\n    Given an :class:`http.client.HTTPResponse` instance ``r``, return a\n    corresponding :class:`urllib3.response.HTTPResponse` object.\n\n    Remaining parameters are passed to the HTTPResponse constructor, along\n    with ``original_response=r``.\n    \"\"\"\n    headers = r.msg\n\n    if not isinstance(headers, HTTPHeaderDict):\n        if six.PY2:\n            # Python 2.7\n            headers = HTTPHeaderDict.from_httplib(headers)\n        else:\n            headers = HTTPHeaderDict(headers.items())\n\n    # HTTPResponse objects in Python 3 don't have a .strict attribute\n    strict = getattr(r, \"strict\", 0)\n    resp = ResponseCls(\n        body=r,\n        headers=headers,\n        status=r.status,\n        version=r.version,\n        reason=r.reason,\n        strict=strict,\n        original_response=r,\n        **response_kw\n    )\n    return resp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse.get_redirect_location","title":"<code>get_redirect_location()</code>","text":"<p>Should we redirect and where to?</p> <p>:returns: Truthy redirect location string if we got a redirect status     code and valid location. <code>None</code> if redirect status and no     location. <code>False</code> if not a redirect status code.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def get_redirect_location(self):\n    \"\"\"\n    Should we redirect and where to?\n\n    :returns: Truthy redirect location string if we got a redirect status\n        code and valid location. ``None`` if redirect status and no\n        location. ``False`` if not a redirect status code.\n    \"\"\"\n    if self.status in self.REDIRECT_STATUSES:\n        return self.headers.get(\"location\")\n\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse.geturl","title":"<code>geturl()</code>","text":"<p>Returns the URL that was the source of this response. If the request that generated this response redirected, this method will return the final redirect location.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def geturl(self):\n    \"\"\"\n    Returns the URL that was the source of this response.\n    If the request that generated this response redirected, this method\n    will return the final redirect location.\n    \"\"\"\n    if self.retries is not None and len(self.retries.history):\n        return self.retries.history[-1].redirect_location\n    else:\n        return self._request_url\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse.read","title":"<code>read(amt=None, decode_content=None, cache_content=False)</code>","text":"<p>Similar to :meth:<code>http.client.HTTPResponse.read</code>, but with two additional parameters: <code>decode_content</code> and <code>cache_content</code>.</p> <p>:param amt:     How much of the content to read. If specified, caching is skipped     because it doesn't make sense to cache partial content as the full     response.</p> <p>:param decode_content:     If True, will attempt to decode the body based on the     'content-encoding' header.</p> <p>:param cache_content:     If True, will save the returned data such that the same result is     returned despite of the state of the underlying file object. This     is useful if you want the <code>.data</code> property to continue working     after having <code>.read()</code> the file object. (Overridden if <code>amt</code> is     set.)</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def read(self, amt=None, decode_content=None, cache_content=False):\n    \"\"\"\n    Similar to :meth:`http.client.HTTPResponse.read`, but with two additional\n    parameters: ``decode_content`` and ``cache_content``.\n\n    :param amt:\n        How much of the content to read. If specified, caching is skipped\n        because it doesn't make sense to cache partial content as the full\n        response.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n\n    :param cache_content:\n        If True, will save the returned data such that the same result is\n        returned despite of the state of the underlying file object. This\n        is useful if you want the ``.data`` property to continue working\n        after having ``.read()`` the file object. (Overridden if ``amt`` is\n        set.)\n    \"\"\"\n    self._init_decoder()\n    if decode_content is None:\n        decode_content = self.decode_content\n\n    if self._fp is None:\n        return\n\n    flush_decoder = False\n    fp_closed = getattr(self._fp, \"closed\", False)\n\n    with self._error_catcher():\n        if amt is None:\n            # cStringIO doesn't like amt=None\n            data = self._fp.read() if not fp_closed else b\"\"\n            flush_decoder = True\n        else:\n            cache_content = False\n            data = self._fp.read(amt) if not fp_closed else b\"\"\n            if (\n                amt != 0 and not data\n            ):  # Platform-specific: Buggy versions of Python.\n                # Close the connection when no data is returned\n                #\n                # This is redundant to what httplib/http.client _should_\n                # already do.  However, versions of python released before\n                # December 15, 2012 (http://bugs.python.org/issue16298) do\n                # not properly close the connection in all cases. There is\n                # no harm in redundantly calling close.\n                self._fp.close()\n                flush_decoder = True\n                if self.enforce_content_length and self.length_remaining not in (\n                    0,\n                    None,\n                ):\n                    # This is an edge case that httplib failed to cover due\n                    # to concerns of backward compatibility. We're\n                    # addressing it here to make sure IncompleteRead is\n                    # raised during streaming, so all calls with incorrect\n                    # Content-Length are caught.\n                    raise IncompleteRead(self._fp_bytes_read, self.length_remaining)\n\n    if data:\n        self._fp_bytes_read += len(data)\n        if self.length_remaining is not None:\n            self.length_remaining -= len(data)\n\n        data = self._decode(data, decode_content, flush_decoder)\n\n        if cache_content:\n            self._body = data\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse.read_chunked","title":"<code>read_chunked(amt=None, decode_content=None)</code>","text":"<p>Similar to :meth:<code>HTTPResponse.read</code>, but with an additional parameter: <code>decode_content</code>.</p> <p>:param amt:     How much of the content to read. If specified, caching is skipped     because it doesn't make sense to cache partial content as the full     response.</p> <p>:param decode_content:     If True, will attempt to decode the body based on the     'content-encoding' header.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def read_chunked(self, amt=None, decode_content=None):\n    \"\"\"\n    Similar to :meth:`HTTPResponse.read`, but with an additional\n    parameter: ``decode_content``.\n\n    :param amt:\n        How much of the content to read. If specified, caching is skipped\n        because it doesn't make sense to cache partial content as the full\n        response.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n    \"\"\"\n    self._init_decoder()\n    # FIXME: Rewrite this method and make it a class with a better structured logic.\n    if not self.chunked:\n        raise ResponseNotChunked(\n            \"Response is not chunked. \"\n            \"Header 'transfer-encoding: chunked' is missing.\"\n        )\n    if not self.supports_chunked_reads():\n        raise BodyNotHttplibCompatible(\n            \"Body should be http.client.HTTPResponse like. \"\n            \"It should have have an fp attribute which returns raw chunks.\"\n        )\n\n    with self._error_catcher():\n        # Don't bother reading the body of a HEAD request.\n        if self._original_response and is_response_to_head(self._original_response):\n            self._original_response.close()\n            return\n\n        # If a response is already read and closed\n        # then return immediately.\n        if self._fp.fp is None:\n            return\n\n        while True:\n            self._update_chunk_length()\n            if self.chunk_left == 0:\n                break\n            chunk = self._handle_chunk(amt)\n            decoded = self._decode(\n                chunk, decode_content=decode_content, flush_decoder=False\n            )\n            if decoded:\n                yield decoded\n\n        if decode_content:\n            # On CPython and PyPy, we should never need to flush the\n            # decoder. However, on Jython we *might* need to, so\n            # lets defensively do it anyway.\n            decoded = self._flush_decoder()\n            if decoded:  # Platform-specific: Jython.\n                yield decoded\n\n        # Chunk content ends with \\r\\n: discard it.\n        while True:\n            line = self._fp.fp.readline()\n            if not line:\n                # Some sites may not end with '\\r\\n'.\n                break\n            if line == b\"\\r\\n\":\n                break\n\n        # We read everything; close the \"file\".\n        if self._original_response:\n            self._original_response.close()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse.stream","title":"<code>stream(amt=2 ** 16, decode_content=None)</code>","text":"<p>A generator wrapper for the read() method. A call will block until <code>amt</code> bytes have been read from the connection or until the connection is closed.</p> <p>:param amt:     How much of the content to read. The generator will return up to     much data per iteration, but may return less. This is particularly     likely when using compressed data. However, the empty string will     never be returned.</p> <p>:param decode_content:     If True, will attempt to decode the body based on the     'content-encoding' header.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def stream(self, amt=2 ** 16, decode_content=None):\n    \"\"\"\n    A generator wrapper for the read() method. A call will block until\n    ``amt`` bytes have been read from the connection or until the\n    connection is closed.\n\n    :param amt:\n        How much of the content to read. The generator will return up to\n        much data per iteration, but may return less. This is particularly\n        likely when using compressed data. However, the empty string will\n        never be returned.\n\n    :param decode_content:\n        If True, will attempt to decode the body based on the\n        'content-encoding' header.\n    \"\"\"\n    if self.chunked and self.supports_chunked_reads():\n        for line in self.read_chunked(amt, decode_content=decode_content):\n            yield line\n    else:\n        while not is_fp_closed(self._fp):\n            data = self.read(amt=amt, decode_content=decode_content)\n\n            if data:\n                yield data\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse.supports_chunked_reads","title":"<code>supports_chunked_reads()</code>","text":"<p>Checks if the underlying file-like object looks like a :class:<code>http.client.HTTPResponse</code> object. We do this by testing for the fp attribute. If it is present we assume it returns raw chunks as processed by read_chunked().</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def supports_chunked_reads(self):\n    \"\"\"\n    Checks if the underlying file-like object looks like a\n    :class:`http.client.HTTPResponse` object. We do this by testing for\n    the fp attribute. If it is present we assume it returns raw chunks as\n    processed by read_chunked().\n    \"\"\"\n    return hasattr(self._fp, \"fp\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.HTTPResponse.tell","title":"<code>tell()</code>","text":"<p>Obtain the number of bytes pulled over the wire so far. May differ from the amount of content returned by :meth:<code>urllib3.response.HTTPResponse.read</code> if bytes are encoded on the wire (e.g, compressed).</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>def tell(self):\n    \"\"\"\n    Obtain the number of bytes pulled over the wire so far. May differ from\n    the amount of content returned by :meth:``urllib3.response.HTTPResponse.read``\n    if bytes are encoded on the wire (e.g, compressed).\n    \"\"\"\n    return self._fp_bytes_read\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/response.html#client.ayon_fusion.vendor.urllib3.response.MultiDecoder","title":"<code>MultiDecoder</code>","text":"<p>               Bases: <code>object</code></p> From RFC7231 <p>If one or more encodings have been applied to a representation, the sender that applied the encodings MUST generate a Content-Encoding header field that lists the content codings in the order in which they were applied.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/response.py</code> <pre><code>class MultiDecoder(object):\n    \"\"\"\n    From RFC7231:\n        If one or more encodings have been applied to a representation, the\n        sender that applied the encodings MUST generate a Content-Encoding\n        header field that lists the content codings in the order in which\n        they were applied.\n    \"\"\"\n\n    def __init__(self, modes):\n        self._decoders = [_get_decoder(m.strip()) for m in modes.split(\",\")]\n\n    def flush(self):\n        return self._decoders[0].flush()\n\n    def decompress(self, data):\n        for d in reversed(self._decoders):\n            data = d.decompress(data)\n        return data\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/index.html","title":"contrib","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/_appengine_environ.html","title":"_appengine_environ","text":"<p>This module provides means to detect the App Engine environment.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/_appengine_environ.html#client.ayon_fusion.vendor.urllib3.contrib._appengine_environ.is_appengine_sandbox","title":"<code>is_appengine_sandbox()</code>","text":"<p>Reports if the app is running in the first generation sandbox.</p> <p>The second generation runtimes are technically still in a sandbox, but it is much less restrictive, so generally you shouldn't need to check for it. see https://cloud.google.com/appengine/docs/standard/runtimes</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/_appengine_environ.py</code> <pre><code>def is_appengine_sandbox():\n    \"\"\"Reports if the app is running in the first generation sandbox.\n\n    The second generation runtimes are technically still in a sandbox, but it\n    is much less restrictive, so generally you shouldn't need to check for it.\n    see https://cloud.google.com/appengine/docs/standard/runtimes\n    \"\"\"\n    return is_appengine() and os.environ[\"APPENGINE_RUNTIME\"] == \"python27\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/_appengine_environ.html#client.ayon_fusion.vendor.urllib3.contrib._appengine_environ.is_prod_appengine_mvms","title":"<code>is_prod_appengine_mvms()</code>","text":"<p>Deprecated.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/_appengine_environ.py</code> <pre><code>def is_prod_appengine_mvms():\n    \"\"\"Deprecated.\"\"\"\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/appengine.html","title":"appengine","text":"<p>This module provides a pool manager that uses Google App Engine's <code>URLFetch Service &lt;https://cloud.google.com/appengine/docs/python/urlfetch&gt;</code>_.</p> <p>Example usage::</p> <pre><code>from urllib3 import PoolManager\nfrom urllib3.contrib.appengine import AppEngineManager, is_appengine_sandbox\n\nif is_appengine_sandbox():\n    # AppEngineManager uses AppEngine's URLFetch API behind the scenes\n    http = AppEngineManager()\nelse:\n    # PoolManager uses a socket-level API behind the scenes\n    http = PoolManager()\n\nr = http.request('GET', 'https://google.com/')\n</code></pre> <p>There are <code>limitations &lt;https://cloud.google.com/appengine/docs/python/urlfetch/#Python_Quotas_and_limits&gt;</code>_ to the URLFetch service and it may not be the best choice for your application. There are three options for using urllib3 on Google App Engine:</p> <ol> <li>You can use :class:<code>AppEngineManager</code> with URLFetch. URLFetch is    cost-effective in many circumstances as long as your usage is within the    limitations.</li> <li> <p>You can use a normal :class:<code>~urllib3.PoolManager</code> by enabling sockets.    Sockets also have <code>limitations and restrictions    &lt;https://cloud.google.com/appengine/docs/python/sockets/   #limitations-and-restrictions&gt;</code>_ and have a lower free quota than URLFetch.    To use sockets, be sure to specify the following in your <code>app.yaml</code>::</p> <pre><code>env_variables:\n    GAE_USE_SOCKETS_HTTPLIB : 'true'\n</code></pre> </li> <li> <p>If you are using <code>App Engine Flexible &lt;https://cloud.google.com/appengine/docs/flexible/&gt;</code>_, you can use the standard :class:<code>PoolManager</code> without any configuration or special environment variables.</p> </li> </ol>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/appengine.html#client.ayon_fusion.vendor.urllib3.contrib.appengine.AppEngineManager","title":"<code>AppEngineManager</code>","text":"<p>               Bases: <code>RequestMethods</code></p> <p>Connection manager for Google App Engine sandbox applications.</p> <p>This manager uses the URLFetch service directly instead of using the emulated httplib, and is subject to URLFetch limitations as described in the App Engine documentation <code>here &lt;https://cloud.google.com/appengine/docs/python/urlfetch&gt;</code>_.</p> <p>Notably it will raise an :class:<code>AppEnginePlatformError</code> if:     * URLFetch is not available.     * If you attempt to use this on App Engine Flexible, as full socket       support is available.     * If a request size is more than 10 megabytes.     * If a response size is more than 32 megabytes.     * If you use an unsupported request method such as OPTIONS.</p> <p>Beyond those cases, it will raise normal urllib3 errors.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/appengine.py</code> <pre><code>class AppEngineManager(RequestMethods):\n    \"\"\"\n    Connection manager for Google App Engine sandbox applications.\n\n    This manager uses the URLFetch service directly instead of using the\n    emulated httplib, and is subject to URLFetch limitations as described in\n    the App Engine documentation `here\n    &lt;https://cloud.google.com/appengine/docs/python/urlfetch&gt;`_.\n\n    Notably it will raise an :class:`AppEnginePlatformError` if:\n        * URLFetch is not available.\n        * If you attempt to use this on App Engine Flexible, as full socket\n          support is available.\n        * If a request size is more than 10 megabytes.\n        * If a response size is more than 32 megabytes.\n        * If you use an unsupported request method such as OPTIONS.\n\n    Beyond those cases, it will raise normal urllib3 errors.\n    \"\"\"\n\n    def __init__(\n        self,\n        headers=None,\n        retries=None,\n        validate_certificate=True,\n        urlfetch_retries=True,\n    ):\n        if not urlfetch:\n            raise AppEnginePlatformError(\n                \"URLFetch is not available in this environment.\"\n            )\n\n        warnings.warn(\n            \"urllib3 is using URLFetch on Google App Engine sandbox instead \"\n            \"of sockets. To use sockets directly instead of URLFetch see \"\n            \"https://urllib3.readthedocs.io/en/1.26.x/reference/urllib3.contrib.html.\",\n            AppEnginePlatformWarning,\n        )\n\n        RequestMethods.__init__(self, headers)\n        self.validate_certificate = validate_certificate\n        self.urlfetch_retries = urlfetch_retries\n\n        self.retries = retries or Retry.DEFAULT\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # Return False to re-raise any potential exceptions\n        return False\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=None,\n        redirect=True,\n        timeout=Timeout.DEFAULT_TIMEOUT,\n        **response_kw\n    ):\n\n        retries = self._get_retries(retries, redirect)\n\n        try:\n            follow_redirects = redirect and retries.redirect != 0 and retries.total\n            response = urlfetch.fetch(\n                url,\n                payload=body,\n                method=method,\n                headers=headers or {},\n                allow_truncated=False,\n                follow_redirects=self.urlfetch_retries and follow_redirects,\n                deadline=self._get_absolute_timeout(timeout),\n                validate_certificate=self.validate_certificate,\n            )\n        except urlfetch.DeadlineExceededError as e:\n            raise TimeoutError(self, e)\n\n        except urlfetch.InvalidURLError as e:\n            if \"too large\" in str(e):\n                raise AppEnginePlatformError(\n                    \"URLFetch request too large, URLFetch only \"\n                    \"supports requests up to 10mb in size.\",\n                    e,\n                )\n            raise ProtocolError(e)\n\n        except urlfetch.DownloadError as e:\n            if \"Too many redirects\" in str(e):\n                raise MaxRetryError(self, url, reason=e)\n            raise ProtocolError(e)\n\n        except urlfetch.ResponseTooLargeError as e:\n            raise AppEnginePlatformError(\n                \"URLFetch response too large, URLFetch only supports\"\n                \"responses up to 32mb in size.\",\n                e,\n            )\n\n        except urlfetch.SSLCertificateError as e:\n            raise SSLError(e)\n\n        except urlfetch.InvalidMethodError as e:\n            raise AppEnginePlatformError(\n                \"URLFetch does not support method: %s\" % method, e\n            )\n\n        http_response = self._urlfetch_response_to_http_response(\n            response, retries=retries, **response_kw\n        )\n\n        # Handle redirect?\n        redirect_location = redirect and http_response.get_redirect_location()\n        if redirect_location:\n            # Check for redirect response\n            if self.urlfetch_retries and retries.raise_on_redirect:\n                raise MaxRetryError(self, url, \"too many redirects\")\n            else:\n                if http_response.status == 303:\n                    method = \"GET\"\n\n                try:\n                    retries = retries.increment(\n                        method, url, response=http_response, _pool=self\n                    )\n                except MaxRetryError:\n                    if retries.raise_on_redirect:\n                        raise MaxRetryError(self, url, \"too many redirects\")\n                    return http_response\n\n                retries.sleep_for_retry(http_response)\n                log.debug(\"Redirecting %s -&gt; %s\", url, redirect_location)\n                redirect_url = urljoin(url, redirect_location)\n                return self.urlopen(\n                    method,\n                    redirect_url,\n                    body,\n                    headers,\n                    retries=retries,\n                    redirect=redirect,\n                    timeout=timeout,\n                    **response_kw\n                )\n\n        # Check if we should retry the HTTP response.\n        has_retry_after = bool(http_response.getheader(\"Retry-After\"))\n        if retries.is_retry(method, http_response.status, has_retry_after):\n            retries = retries.increment(method, url, response=http_response, _pool=self)\n            log.debug(\"Retry: %s\", url)\n            retries.sleep(http_response)\n            return self.urlopen(\n                method,\n                url,\n                body=body,\n                headers=headers,\n                retries=retries,\n                redirect=redirect,\n                timeout=timeout,\n                **response_kw\n            )\n\n        return http_response\n\n    def _urlfetch_response_to_http_response(self, urlfetch_resp, **response_kw):\n\n        if is_prod_appengine():\n            # Production GAE handles deflate encoding automatically, but does\n            # not remove the encoding header.\n            content_encoding = urlfetch_resp.headers.get(\"content-encoding\")\n\n            if content_encoding == \"deflate\":\n                del urlfetch_resp.headers[\"content-encoding\"]\n\n        transfer_encoding = urlfetch_resp.headers.get(\"transfer-encoding\")\n        # We have a full response's content,\n        # so let's make sure we don't report ourselves as chunked data.\n        if transfer_encoding == \"chunked\":\n            encodings = transfer_encoding.split(\",\")\n            encodings.remove(\"chunked\")\n            urlfetch_resp.headers[\"transfer-encoding\"] = \",\".join(encodings)\n\n        original_response = HTTPResponse(\n            # In order for decoding to work, we must present the content as\n            # a file-like object.\n            body=io.BytesIO(urlfetch_resp.content),\n            msg=urlfetch_resp.header_msg,\n            headers=urlfetch_resp.headers,\n            status=urlfetch_resp.status_code,\n            **response_kw\n        )\n\n        return HTTPResponse(\n            body=io.BytesIO(urlfetch_resp.content),\n            headers=urlfetch_resp.headers,\n            status=urlfetch_resp.status_code,\n            original_response=original_response,\n            **response_kw\n        )\n\n    def _get_absolute_timeout(self, timeout):\n        if timeout is Timeout.DEFAULT_TIMEOUT:\n            return None  # Defer to URLFetch's default.\n        if isinstance(timeout, Timeout):\n            if timeout._read is not None or timeout._connect is not None:\n                warnings.warn(\n                    \"URLFetch does not support granular timeout settings, \"\n                    \"reverting to total or default URLFetch timeout.\",\n                    AppEnginePlatformWarning,\n                )\n            return timeout.total\n        return timeout\n\n    def _get_retries(self, retries, redirect):\n        if not isinstance(retries, Retry):\n            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)\n\n        if retries.connect or retries.read or retries.redirect:\n            warnings.warn(\n                \"URLFetch only supports total retries and does not \"\n                \"recognize connect, read, or redirect retry parameters.\",\n                AppEnginePlatformWarning,\n            )\n\n        return retries\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/ntlmpool.html","title":"ntlmpool","text":"<p>NTLM authenticating pool, contributed by erikcederstran</p> <p>Issue #10, see: http://code.google.com/p/urllib3/issues/detail?id=10</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/ntlmpool.html#client.ayon_fusion.vendor.urllib3.contrib.ntlmpool.NTLMConnectionPool","title":"<code>NTLMConnectionPool</code>","text":"<p>               Bases: <code>HTTPSConnectionPool</code></p> <p>Implements an NTLM authentication version of an urllib3 connection pool</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/ntlmpool.py</code> <pre><code>class NTLMConnectionPool(HTTPSConnectionPool):\n    \"\"\"\n    Implements an NTLM authentication version of an urllib3 connection pool\n    \"\"\"\n\n    scheme = \"https\"\n\n    def __init__(self, user, pw, authurl, *args, **kwargs):\n        \"\"\"\n        authurl is a random URL on the server that is protected by NTLM.\n        user is the Windows user, probably in the DOMAIN\\\\username format.\n        pw is the password for the user.\n        \"\"\"\n        super(NTLMConnectionPool, self).__init__(*args, **kwargs)\n        self.authurl = authurl\n        self.rawuser = user\n        user_parts = user.split(\"\\\\\", 1)\n        self.domain = user_parts[0].upper()\n        self.user = user_parts[1]\n        self.pw = pw\n\n    def _new_conn(self):\n        # Performs the NTLM handshake that secures the connection. The socket\n        # must be kept open while requests are performed.\n        self.num_connections += 1\n        log.debug(\n            \"Starting NTLM HTTPS connection no. %d: https://%s%s\",\n            self.num_connections,\n            self.host,\n            self.authurl,\n        )\n\n        headers = {\"Connection\": \"Keep-Alive\"}\n        req_header = \"Authorization\"\n        resp_header = \"www-authenticate\"\n\n        conn = HTTPSConnection(host=self.host, port=self.port)\n\n        # Send negotiation message\n        headers[req_header] = \"NTLM %s\" % ntlm.create_NTLM_NEGOTIATE_MESSAGE(\n            self.rawuser\n        )\n        log.debug(\"Request headers: %s\", headers)\n        conn.request(\"GET\", self.authurl, None, headers)\n        res = conn.getresponse()\n        reshdr = dict(res.getheaders())\n        log.debug(\"Response status: %s %s\", res.status, res.reason)\n        log.debug(\"Response headers: %s\", reshdr)\n        log.debug(\"Response data: %s [...]\", res.read(100))\n\n        # Remove the reference to the socket, so that it can not be closed by\n        # the response object (we want to keep the socket open)\n        res.fp = None\n\n        # Server should respond with a challenge message\n        auth_header_values = reshdr[resp_header].split(\", \")\n        auth_header_value = None\n        for s in auth_header_values:\n            if s[:5] == \"NTLM \":\n                auth_header_value = s[5:]\n        if auth_header_value is None:\n            raise Exception(\n                \"Unexpected %s response header: %s\" % (resp_header, reshdr[resp_header])\n            )\n\n        # Send authentication message\n        ServerChallenge, NegotiateFlags = ntlm.parse_NTLM_CHALLENGE_MESSAGE(\n            auth_header_value\n        )\n        auth_msg = ntlm.create_NTLM_AUTHENTICATE_MESSAGE(\n            ServerChallenge, self.user, self.domain, self.pw, NegotiateFlags\n        )\n        headers[req_header] = \"NTLM %s\" % auth_msg\n        log.debug(\"Request headers: %s\", headers)\n        conn.request(\"GET\", self.authurl, None, headers)\n        res = conn.getresponse()\n        log.debug(\"Response status: %s %s\", res.status, res.reason)\n        log.debug(\"Response headers: %s\", dict(res.getheaders()))\n        log.debug(\"Response data: %s [...]\", res.read()[:100])\n        if res.status != 200:\n            if res.status == 401:\n                raise Exception(\"Server rejected request: wrong username or password\")\n            raise Exception(\"Wrong server response: %s %s\" % (res.status, res.reason))\n\n        res.fp = None\n        log.debug(\"Connection established\")\n        return conn\n\n    def urlopen(\n        self,\n        method,\n        url,\n        body=None,\n        headers=None,\n        retries=3,\n        redirect=True,\n        assert_same_host=True,\n    ):\n        if headers is None:\n            headers = {}\n        headers[\"Connection\"] = \"Keep-Alive\"\n        return super(NTLMConnectionPool, self).urlopen(\n            method, url, body, headers, retries, redirect, assert_same_host\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/ntlmpool.html#client.ayon_fusion.vendor.urllib3.contrib.ntlmpool.NTLMConnectionPool.__init__","title":"<code>__init__(user, pw, authurl, *args, **kwargs)</code>","text":"<p>authurl is a random URL on the server that is protected by NTLM. user is the Windows user, probably in the DOMAIN\\username format. pw is the password for the user.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/ntlmpool.py</code> <pre><code>def __init__(self, user, pw, authurl, *args, **kwargs):\n    \"\"\"\n    authurl is a random URL on the server that is protected by NTLM.\n    user is the Windows user, probably in the DOMAIN\\\\username format.\n    pw is the password for the user.\n    \"\"\"\n    super(NTLMConnectionPool, self).__init__(*args, **kwargs)\n    self.authurl = authurl\n    self.rawuser = user\n    user_parts = user.split(\"\\\\\", 1)\n    self.domain = user_parts[0].upper()\n    self.user = user_parts[1]\n    self.pw = pw\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.html","title":"pyopenssl","text":"<p>TLS with SNI_-support for Python 2. Follow these instructions if you would like to verify TLS certificates in Python 2. Note, the default libraries do not do certificate checking; you need to do additional work to validate certificates yourself.</p> <p>This needs the following packages installed:</p> <ul> <li><code>pyOpenSSL</code>_ (tested with 16.0.0)</li> <li><code>cryptography</code>_ (minimum 1.3.4, from pyopenssl)</li> <li><code>idna</code>_ (minimum 2.0, from cryptography)</li> </ul> <p>However, pyopenssl depends on cryptography, which depends on idna, so while we use all three directly here we end up having relatively few packages required.</p> <p>You can install them with the following command:</p> <p>.. code-block:: bash</p> <pre><code>$ python -m pip install pyopenssl cryptography idna\n</code></pre> <p>To activate certificate checking, call :func:<code>~urllib3.contrib.pyopenssl.inject_into_urllib3</code> from your Python code before you begin making HTTP requests. This can be done in a <code>sitecustomize</code> module, or at any other time before your application begins using <code>urllib3</code>, like this:</p> <p>.. code-block:: python</p> <pre><code>try:\n    import urllib3.contrib.pyopenssl\n    urllib3.contrib.pyopenssl.inject_into_urllib3()\nexcept ImportError:\n    pass\n</code></pre> <p>Now you can use :mod:<code>urllib3</code> as you normally would, and it will support SNI when the required modules are installed.</p> <p>Activating this module also has the positive side effect of disabling SSL/TLS compression in Python 2 (see <code>CRIME attack</code>_).</p> <p>.. sni: https://en.wikipedia.org/wiki/Server_Name_Indication .. _crime attack: https://en.wikipedia.org/wiki/CRIME(security_exploit) .. _pyopenssl: https://www.pyopenssl.org .. _cryptography: https://cryptography.io .. _idna: https://github.com/kjd/idna</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.html#client.ayon_fusion.vendor.urllib3.contrib.pyopenssl.PyOpenSSLContext","title":"<code>PyOpenSSLContext</code>","text":"<p>               Bases: <code>object</code></p> <p>I am a wrapper class for the PyOpenSSL <code>Context</code> object. I am responsible for translating the interface of the standard library <code>SSLContext</code> object to calls into PyOpenSSL.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.py</code> <pre><code>class PyOpenSSLContext(object):\n    \"\"\"\n    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible\n    for translating the interface of the standard library ``SSLContext`` object\n    to calls into PyOpenSSL.\n    \"\"\"\n\n    def __init__(self, protocol):\n        self.protocol = _openssl_versions[protocol]\n        self._ctx = OpenSSL.SSL.Context(self.protocol)\n        self._options = 0\n        self.check_hostname = False\n\n    @property\n    def options(self):\n        return self._options\n\n    @options.setter\n    def options(self, value):\n        self._options = value\n        self._ctx.set_options(value)\n\n    @property\n    def verify_mode(self):\n        return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]\n\n    @verify_mode.setter\n    def verify_mode(self, value):\n        self._ctx.set_verify(_stdlib_to_openssl_verify[value], _verify_callback)\n\n    def set_default_verify_paths(self):\n        self._ctx.set_default_verify_paths()\n\n    def set_ciphers(self, ciphers):\n        if isinstance(ciphers, six.text_type):\n            ciphers = ciphers.encode(\"utf-8\")\n        self._ctx.set_cipher_list(ciphers)\n\n    def load_verify_locations(self, cafile=None, capath=None, cadata=None):\n        if cafile is not None:\n            cafile = cafile.encode(\"utf-8\")\n        if capath is not None:\n            capath = capath.encode(\"utf-8\")\n        try:\n            self._ctx.load_verify_locations(cafile, capath)\n            if cadata is not None:\n                self._ctx.load_verify_locations(BytesIO(cadata))\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(\"unable to load trusted certificates: %r\" % e)\n\n    def load_cert_chain(self, certfile, keyfile=None, password=None):\n        self._ctx.use_certificate_chain_file(certfile)\n        if password is not None:\n            if not isinstance(password, six.binary_type):\n                password = password.encode(\"utf-8\")\n            self._ctx.set_passwd_cb(lambda *_: password)\n        self._ctx.use_privatekey_file(keyfile or certfile)\n\n    def set_alpn_protocols(self, protocols):\n        protocols = [six.ensure_binary(p) for p in protocols]\n        return self._ctx.set_alpn_protos(protocols)\n\n    def wrap_socket(\n        self,\n        sock,\n        server_side=False,\n        do_handshake_on_connect=True,\n        suppress_ragged_eofs=True,\n        server_hostname=None,\n    ):\n        cnx = OpenSSL.SSL.Connection(self._ctx, sock)\n\n        if isinstance(server_hostname, six.text_type):  # Platform-specific: Python 3\n            server_hostname = server_hostname.encode(\"utf-8\")\n\n        if server_hostname is not None:\n            cnx.set_tlsext_host_name(server_hostname)\n\n        cnx.set_connect_state()\n\n        while True:\n            try:\n                cnx.do_handshake()\n            except OpenSSL.SSL.WantReadError:\n                if not util.wait_for_read(sock, sock.gettimeout()):\n                    raise timeout(\"select timed out\")\n                continue\n            except OpenSSL.SSL.Error as e:\n                raise ssl.SSLError(\"bad handshake: %r\" % e)\n            break\n\n        return WrappedSocket(cnx, sock)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.html#client.ayon_fusion.vendor.urllib3.contrib.pyopenssl.WrappedSocket","title":"<code>WrappedSocket</code>","text":"<p>               Bases: <code>object</code></p> <p>API-compatibility wrapper for Python OpenSSL's Connection-class.</p> <p>Note: _makefile_refs, _drop() and _reuse() are needed for the garbage collector of pypy.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.py</code> <pre><code>class WrappedSocket(object):\n    \"\"\"API-compatibility wrapper for Python OpenSSL's Connection-class.\n\n    Note: _makefile_refs, _drop() and _reuse() are needed for the garbage\n    collector of pypy.\n    \"\"\"\n\n    def __init__(self, connection, socket, suppress_ragged_eofs=True):\n        self.connection = connection\n        self.socket = socket\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n        self._makefile_refs = 0\n        self._closed = False\n\n    def fileno(self):\n        return self.socket.fileno()\n\n    # Copy-pasted from Python 3.5 source code\n    def _decref_socketios(self):\n        if self._makefile_refs &gt; 0:\n            self._makefile_refs -= 1\n        if self._closed:\n            self.close()\n\n    def recv(self, *args, **kwargs):\n        try:\n            data = self.connection.recv(*args, **kwargs)\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return b\"\"\n            else:\n                raise SocketError(str(e))\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return b\"\"\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\")\n            else:\n                return self.recv(*args, **kwargs)\n\n        # TLS 1.3 post-handshake authentication\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(\"read error: %r\" % e)\n        else:\n            return data\n\n    def recv_into(self, *args, **kwargs):\n        try:\n            return self.connection.recv_into(*args, **kwargs)\n        except OpenSSL.SSL.SysCallError as e:\n            if self.suppress_ragged_eofs and e.args == (-1, \"Unexpected EOF\"):\n                return 0\n            else:\n                raise SocketError(str(e))\n        except OpenSSL.SSL.ZeroReturnError:\n            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:\n                return 0\n            else:\n                raise\n        except OpenSSL.SSL.WantReadError:\n            if not util.wait_for_read(self.socket, self.socket.gettimeout()):\n                raise timeout(\"The read operation timed out\")\n            else:\n                return self.recv_into(*args, **kwargs)\n\n        # TLS 1.3 post-handshake authentication\n        except OpenSSL.SSL.Error as e:\n            raise ssl.SSLError(\"read error: %r\" % e)\n\n    def settimeout(self, timeout):\n        return self.socket.settimeout(timeout)\n\n    def _send_until_done(self, data):\n        while True:\n            try:\n                return self.connection.send(data)\n            except OpenSSL.SSL.WantWriteError:\n                if not util.wait_for_write(self.socket, self.socket.gettimeout()):\n                    raise timeout()\n                continue\n            except OpenSSL.SSL.SysCallError as e:\n                raise SocketError(str(e))\n\n    def sendall(self, data):\n        total_sent = 0\n        while total_sent &lt; len(data):\n            sent = self._send_until_done(\n                data[total_sent : total_sent + SSL_WRITE_BLOCKSIZE]\n            )\n            total_sent += sent\n\n    def shutdown(self):\n        # FIXME rethrow compatible exceptions should we ever use this\n        self.connection.shutdown()\n\n    def close(self):\n        if self._makefile_refs &lt; 1:\n            try:\n                self._closed = True\n                return self.connection.close()\n            except OpenSSL.SSL.Error:\n                return\n        else:\n            self._makefile_refs -= 1\n\n    def getpeercert(self, binary_form=False):\n        x509 = self.connection.get_peer_certificate()\n\n        if not x509:\n            return x509\n\n        if binary_form:\n            return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_ASN1, x509)\n\n        return {\n            \"subject\": (((\"commonName\", x509.get_subject().CN),),),\n            \"subjectAltName\": get_subj_alt_name(x509),\n        }\n\n    def version(self):\n        return self.connection.get_protocol_version_name()\n\n    def _reuse(self):\n        self._makefile_refs += 1\n\n    def _drop(self):\n        if self._makefile_refs &lt; 1:\n            self.close()\n        else:\n            self._makefile_refs -= 1\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.html#client.ayon_fusion.vendor.urllib3.contrib.pyopenssl.extract_from_urllib3","title":"<code>extract_from_urllib3()</code>","text":"<p>Undo monkey-patching by :func:<code>inject_into_urllib3</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.py</code> <pre><code>def extract_from_urllib3():\n    \"Undo monkey-patching by :func:`inject_into_urllib3`.\"\n\n    util.SSLContext = orig_util_SSLContext\n    util.ssl_.SSLContext = orig_util_SSLContext\n    util.HAS_SNI = orig_util_HAS_SNI\n    util.ssl_.HAS_SNI = orig_util_HAS_SNI\n    util.IS_PYOPENSSL = False\n    util.ssl_.IS_PYOPENSSL = False\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.html#client.ayon_fusion.vendor.urllib3.contrib.pyopenssl.get_subj_alt_name","title":"<code>get_subj_alt_name(peer_cert)</code>","text":"<p>Given an PyOpenSSL certificate, provides all the subject alternative names.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.py</code> <pre><code>def get_subj_alt_name(peer_cert):\n    \"\"\"\n    Given an PyOpenSSL certificate, provides all the subject alternative names.\n    \"\"\"\n    # Pass the cert to cryptography, which has much better APIs for this.\n    if hasattr(peer_cert, \"to_cryptography\"):\n        cert = peer_cert.to_cryptography()\n    else:\n        # This is technically using private APIs, but should work across all\n        # relevant versions before PyOpenSSL got a proper API for this.\n        cert = _Certificate(openssl_backend, peer_cert._x509)\n\n    # We want to find the SAN extension. Ask Cryptography to locate it (it's\n    # faster than looping in Python)\n    try:\n        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName).value\n    except x509.ExtensionNotFound:\n        # No such extension, return the empty list.\n        return []\n    except (\n        x509.DuplicateExtension,\n        UnsupportedExtension,\n        x509.UnsupportedGeneralNameType,\n        UnicodeError,\n    ) as e:\n        # A problem has been found with the quality of the certificate. Assume\n        # no SAN field is present.\n        log.warning(\n            \"A problem was encountered with the certificate that prevented \"\n            \"urllib3 from finding the SubjectAlternativeName field. This can \"\n            \"affect certificate validation. The error was %s\",\n            e,\n        )\n        return []\n\n    # We want to return dNSName and iPAddress fields. We need to cast the IPs\n    # back to strings because the match_hostname function wants them as\n    # strings.\n    # Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8\n    # decoded. This is pretty frustrating, but that's what the standard library\n    # does with certificates, and so we need to attempt to do the same.\n    # We also want to skip over names which cannot be idna encoded.\n    names = [\n        (\"DNS\", name)\n        for name in map(_dnsname_to_stdlib, ext.get_values_for_type(x509.DNSName))\n        if name is not None\n    ]\n    names.extend(\n        (\"IP Address\", str(name)) for name in ext.get_values_for_type(x509.IPAddress)\n    )\n\n    return names\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.html#client.ayon_fusion.vendor.urllib3.contrib.pyopenssl.inject_into_urllib3","title":"<code>inject_into_urllib3()</code>","text":"<p>Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/pyopenssl.py</code> <pre><code>def inject_into_urllib3():\n    \"Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.\"\n\n    _validate_dependencies_met()\n\n    util.SSLContext = PyOpenSSLContext\n    util.ssl_.SSLContext = PyOpenSSLContext\n    util.HAS_SNI = HAS_SNI\n    util.ssl_.HAS_SNI = HAS_SNI\n    util.IS_PYOPENSSL = True\n    util.ssl_.IS_PYOPENSSL = True\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/securetransport.html","title":"securetransport","text":"<p>SecureTranport support for urllib3 via ctypes.</p> <p>This makes platform-native TLS available to urllib3 users on macOS without the use of a compiler. This is an important feature because the Python Package Index is moving to become a TLSv1.2-or-higher server, and the default OpenSSL that ships with macOS is not capable of doing TLSv1.2. The only way to resolve this is to give macOS users an alternative solution to the problem, and that solution is to use SecureTransport.</p> <p>We use ctypes here because this solution must not require a compiler. That's because pip is not allowed to require a compiler either.</p> <p>This is not intended to be a seriously long-term solution to this problem. The hope is that PEP 543 will eventually solve this issue for us, at which point we can retire this contrib module. But in the short term, we need to solve the impending tire fire that is Python on Mac without this kind of contrib module. So...here we are.</p> <p>To use this module, simply import and inject it::</p> <pre><code>import urllib3.contrib.securetransport\nurllib3.contrib.securetransport.inject_into_urllib3()\n</code></pre> <p>Happy TLSing!</p> <p>This code is a bastardised version of the code found in Will Bond's oscrypto library. An enormous debt is owed to him for blazing this trail for us. For that reason, this code should be considered to be covered both by urllib3's license and by oscrypto's:</p> <p>.. code-block::</p> <pre><code>Copyright (c) 2015-2016 Will Bond &lt;will@wbond.net&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/securetransport.html#client.ayon_fusion.vendor.urllib3.contrib.securetransport.SecureTransportContext","title":"<code>SecureTransportContext</code>","text":"<p>               Bases: <code>object</code></p> <p>I am a wrapper class for the SecureTransport library, to translate the interface of the standard library <code>SSLContext</code> object to calls into SecureTransport.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/securetransport.py</code> <pre><code>class SecureTransportContext(object):\n    \"\"\"\n    I am a wrapper class for the SecureTransport library, to translate the\n    interface of the standard library ``SSLContext`` object to calls into\n    SecureTransport.\n    \"\"\"\n\n    def __init__(self, protocol):\n        self._min_version, self._max_version = _protocol_to_min_max[protocol]\n        self._options = 0\n        self._verify = False\n        self._trust_bundle = None\n        self._client_cert = None\n        self._client_key = None\n        self._client_key_passphrase = None\n        self._alpn_protocols = None\n\n    @property\n    def check_hostname(self):\n        \"\"\"\n        SecureTransport cannot have its hostname checking disabled. For more,\n        see the comment on getpeercert() in this file.\n        \"\"\"\n        return True\n\n    @check_hostname.setter\n    def check_hostname(self, value):\n        \"\"\"\n        SecureTransport cannot have its hostname checking disabled. For more,\n        see the comment on getpeercert() in this file.\n        \"\"\"\n        pass\n\n    @property\n    def options(self):\n        # TODO: Well, crap.\n        #\n        # So this is the bit of the code that is the most likely to cause us\n        # trouble. Essentially we need to enumerate all of the SSL options that\n        # users might want to use and try to see if we can sensibly translate\n        # them, or whether we should just ignore them.\n        return self._options\n\n    @options.setter\n    def options(self, value):\n        # TODO: Update in line with above.\n        self._options = value\n\n    @property\n    def verify_mode(self):\n        return ssl.CERT_REQUIRED if self._verify else ssl.CERT_NONE\n\n    @verify_mode.setter\n    def verify_mode(self, value):\n        self._verify = True if value == ssl.CERT_REQUIRED else False\n\n    def set_default_verify_paths(self):\n        # So, this has to do something a bit weird. Specifically, what it does\n        # is nothing.\n        #\n        # This means that, if we had previously had load_verify_locations\n        # called, this does not undo that. We need to do that because it turns\n        # out that the rest of the urllib3 code will attempt to load the\n        # default verify paths if it hasn't been told about any paths, even if\n        # the context itself was sometime earlier. We resolve that by just\n        # ignoring it.\n        pass\n\n    def load_default_certs(self):\n        return self.set_default_verify_paths()\n\n    def set_ciphers(self, ciphers):\n        # For now, we just require the default cipher string.\n        if ciphers != util.ssl_.DEFAULT_CIPHERS:\n            raise ValueError(\"SecureTransport doesn't support custom cipher strings\")\n\n    def load_verify_locations(self, cafile=None, capath=None, cadata=None):\n        # OK, we only really support cadata and cafile.\n        if capath is not None:\n            raise ValueError(\"SecureTransport does not support cert directories\")\n\n        # Raise if cafile does not exist.\n        if cafile is not None:\n            with open(cafile):\n                pass\n\n        self._trust_bundle = cafile or cadata\n\n    def load_cert_chain(self, certfile, keyfile=None, password=None):\n        self._client_cert = certfile\n        self._client_key = keyfile\n        self._client_cert_passphrase = password\n\n    def set_alpn_protocols(self, protocols):\n        \"\"\"\n        Sets the ALPN protocols that will later be set on the context.\n\n        Raises a NotImplementedError if ALPN is not supported.\n        \"\"\"\n        if not hasattr(Security, \"SSLSetALPNProtocols\"):\n            raise NotImplementedError(\n                \"SecureTransport supports ALPN only in macOS 10.12+\"\n            )\n        self._alpn_protocols = [six.ensure_binary(p) for p in protocols]\n\n    def wrap_socket(\n        self,\n        sock,\n        server_side=False,\n        do_handshake_on_connect=True,\n        suppress_ragged_eofs=True,\n        server_hostname=None,\n    ):\n        # So, what do we do here? Firstly, we assert some properties. This is a\n        # stripped down shim, so there is some functionality we don't support.\n        # See PEP 543 for the real deal.\n        assert not server_side\n        assert do_handshake_on_connect\n        assert suppress_ragged_eofs\n\n        # Ok, we're good to go. Now we want to create the wrapped socket object\n        # and store it in the appropriate place.\n        wrapped_socket = WrappedSocket(sock)\n\n        # Now we can handshake\n        wrapped_socket.handshake(\n            server_hostname,\n            self._verify,\n            self._trust_bundle,\n            self._min_version,\n            self._max_version,\n            self._client_cert,\n            self._client_key,\n            self._client_key_passphrase,\n            self._alpn_protocols,\n        )\n        return wrapped_socket\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/securetransport.html#client.ayon_fusion.vendor.urllib3.contrib.securetransport.SecureTransportContext.check_hostname","title":"<code>check_hostname</code>  <code>property</code> <code>writable</code>","text":"<p>SecureTransport cannot have its hostname checking disabled. For more, see the comment on getpeercert() in this file.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/securetransport.html#client.ayon_fusion.vendor.urllib3.contrib.securetransport.SecureTransportContext.set_alpn_protocols","title":"<code>set_alpn_protocols(protocols)</code>","text":"<p>Sets the ALPN protocols that will later be set on the context.</p> <p>Raises a NotImplementedError if ALPN is not supported.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/securetransport.py</code> <pre><code>def set_alpn_protocols(self, protocols):\n    \"\"\"\n    Sets the ALPN protocols that will later be set on the context.\n\n    Raises a NotImplementedError if ALPN is not supported.\n    \"\"\"\n    if not hasattr(Security, \"SSLSetALPNProtocols\"):\n        raise NotImplementedError(\n            \"SecureTransport supports ALPN only in macOS 10.12+\"\n        )\n    self._alpn_protocols = [six.ensure_binary(p) for p in protocols]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/securetransport.html#client.ayon_fusion.vendor.urllib3.contrib.securetransport.WrappedSocket","title":"<code>WrappedSocket</code>","text":"<p>               Bases: <code>object</code></p> <p>API-compatibility wrapper for Python's OpenSSL wrapped socket object.</p> <p>Note: _makefile_refs, _drop(), and _reuse() are needed for the garbage collector of PyPy.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/securetransport.py</code> <pre><code>class WrappedSocket(object):\n    \"\"\"\n    API-compatibility wrapper for Python's OpenSSL wrapped socket object.\n\n    Note: _makefile_refs, _drop(), and _reuse() are needed for the garbage\n    collector of PyPy.\n    \"\"\"\n\n    def __init__(self, socket):\n        self.socket = socket\n        self.context = None\n        self._makefile_refs = 0\n        self._closed = False\n        self._exception = None\n        self._keychain = None\n        self._keychain_dir = None\n        self._client_cert_chain = None\n\n        # We save off the previously-configured timeout and then set it to\n        # zero. This is done because we use select and friends to handle the\n        # timeouts, but if we leave the timeout set on the lower socket then\n        # Python will \"kindly\" call select on that socket again for us. Avoid\n        # that by forcing the timeout to zero.\n        self._timeout = self.socket.gettimeout()\n        self.socket.settimeout(0)\n\n    @contextlib.contextmanager\n    def _raise_on_error(self):\n        \"\"\"\n        A context manager that can be used to wrap calls that do I/O from\n        SecureTransport. If any of the I/O callbacks hit an exception, this\n        context manager will correctly propagate the exception after the fact.\n        This avoids silently swallowing those exceptions.\n\n        It also correctly forces the socket closed.\n        \"\"\"\n        self._exception = None\n\n        # We explicitly don't catch around this yield because in the unlikely\n        # event that an exception was hit in the block we don't want to swallow\n        # it.\n        yield\n        if self._exception is not None:\n            exception, self._exception = self._exception, None\n            self.close()\n            raise exception\n\n    def _set_ciphers(self):\n        \"\"\"\n        Sets up the allowed ciphers. By default this matches the set in\n        util.ssl_.DEFAULT_CIPHERS, at least as supported by macOS. This is done\n        custom and doesn't allow changing at this time, mostly because parsing\n        OpenSSL cipher strings is going to be a freaking nightmare.\n        \"\"\"\n        ciphers = (Security.SSLCipherSuite * len(CIPHER_SUITES))(*CIPHER_SUITES)\n        result = Security.SSLSetEnabledCiphers(\n            self.context, ciphers, len(CIPHER_SUITES)\n        )\n        _assert_no_error(result)\n\n    def _set_alpn_protocols(self, protocols):\n        \"\"\"\n        Sets up the ALPN protocols on the context.\n        \"\"\"\n        if not protocols:\n            return\n        protocols_arr = _create_cfstring_array(protocols)\n        try:\n            result = Security.SSLSetALPNProtocols(self.context, protocols_arr)\n            _assert_no_error(result)\n        finally:\n            CoreFoundation.CFRelease(protocols_arr)\n\n    def _custom_validate(self, verify, trust_bundle):\n        \"\"\"\n        Called when we have set custom validation. We do this in two cases:\n        first, when cert validation is entirely disabled; and second, when\n        using a custom trust DB.\n        Raises an SSLError if the connection is not trusted.\n        \"\"\"\n        # If we disabled cert validation, just say: cool.\n        if not verify:\n            return\n\n        successes = (\n            SecurityConst.kSecTrustResultUnspecified,\n            SecurityConst.kSecTrustResultProceed,\n        )\n        try:\n            trust_result = self._evaluate_trust(trust_bundle)\n            if trust_result in successes:\n                return\n            reason = \"error code: %d\" % (trust_result,)\n        except Exception as e:\n            # Do not trust on error\n            reason = \"exception: %r\" % (e,)\n\n        # SecureTransport does not send an alert nor shuts down the connection.\n        rec = _build_tls_unknown_ca_alert(self.version())\n        self.socket.sendall(rec)\n        # close the connection immediately\n        # l_onoff = 1, activate linger\n        # l_linger = 0, linger for 0 seoncds\n        opts = struct.pack(\"ii\", 1, 0)\n        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, opts)\n        self.close()\n        raise ssl.SSLError(\"certificate verify failed, %s\" % reason)\n\n    def _evaluate_trust(self, trust_bundle):\n        # We want data in memory, so load it up.\n        if os.path.isfile(trust_bundle):\n            with open(trust_bundle, \"rb\") as f:\n                trust_bundle = f.read()\n\n        cert_array = None\n        trust = Security.SecTrustRef()\n\n        try:\n            # Get a CFArray that contains the certs we want.\n            cert_array = _cert_array_from_pem(trust_bundle)\n\n            # Ok, now the hard part. We want to get the SecTrustRef that ST has\n            # created for this connection, shove our CAs into it, tell ST to\n            # ignore everything else it knows, and then ask if it can build a\n            # chain. This is a buuuunch of code.\n            result = Security.SSLCopyPeerTrust(self.context, ctypes.byref(trust))\n            _assert_no_error(result)\n            if not trust:\n                raise ssl.SSLError(\"Failed to copy trust reference\")\n\n            result = Security.SecTrustSetAnchorCertificates(trust, cert_array)\n            _assert_no_error(result)\n\n            result = Security.SecTrustSetAnchorCertificatesOnly(trust, True)\n            _assert_no_error(result)\n\n            trust_result = Security.SecTrustResultType()\n            result = Security.SecTrustEvaluate(trust, ctypes.byref(trust_result))\n            _assert_no_error(result)\n        finally:\n            if trust:\n                CoreFoundation.CFRelease(trust)\n\n            if cert_array is not None:\n                CoreFoundation.CFRelease(cert_array)\n\n        return trust_result.value\n\n    def handshake(\n        self,\n        server_hostname,\n        verify,\n        trust_bundle,\n        min_version,\n        max_version,\n        client_cert,\n        client_key,\n        client_key_passphrase,\n        alpn_protocols,\n    ):\n        \"\"\"\n        Actually performs the TLS handshake. This is run automatically by\n        wrapped socket, and shouldn't be needed in user code.\n        \"\"\"\n        # First, we do the initial bits of connection setup. We need to create\n        # a context, set its I/O funcs, and set the connection reference.\n        self.context = Security.SSLCreateContext(\n            None, SecurityConst.kSSLClientSide, SecurityConst.kSSLStreamType\n        )\n        result = Security.SSLSetIOFuncs(\n            self.context, _read_callback_pointer, _write_callback_pointer\n        )\n        _assert_no_error(result)\n\n        # Here we need to compute the handle to use. We do this by taking the\n        # id of self modulo 2**31 - 1. If this is already in the dictionary, we\n        # just keep incrementing by one until we find a free space.\n        with _connection_ref_lock:\n            handle = id(self) % 2147483647\n            while handle in _connection_refs:\n                handle = (handle + 1) % 2147483647\n            _connection_refs[handle] = self\n\n        result = Security.SSLSetConnection(self.context, handle)\n        _assert_no_error(result)\n\n        # If we have a server hostname, we should set that too.\n        if server_hostname:\n            if not isinstance(server_hostname, bytes):\n                server_hostname = server_hostname.encode(\"utf-8\")\n\n            result = Security.SSLSetPeerDomainName(\n                self.context, server_hostname, len(server_hostname)\n            )\n            _assert_no_error(result)\n\n        # Setup the ciphers.\n        self._set_ciphers()\n\n        # Setup the ALPN protocols.\n        self._set_alpn_protocols(alpn_protocols)\n\n        # Set the minimum and maximum TLS versions.\n        result = Security.SSLSetProtocolVersionMin(self.context, min_version)\n        _assert_no_error(result)\n\n        result = Security.SSLSetProtocolVersionMax(self.context, max_version)\n        _assert_no_error(result)\n\n        # If there's a trust DB, we need to use it. We do that by telling\n        # SecureTransport to break on server auth. We also do that if we don't\n        # want to validate the certs at all: we just won't actually do any\n        # authing in that case.\n        if not verify or trust_bundle is not None:\n            result = Security.SSLSetSessionOption(\n                self.context, SecurityConst.kSSLSessionOptionBreakOnServerAuth, True\n            )\n            _assert_no_error(result)\n\n        # If there's a client cert, we need to use it.\n        if client_cert:\n            self._keychain, self._keychain_dir = _temporary_keychain()\n            self._client_cert_chain = _load_client_cert_chain(\n                self._keychain, client_cert, client_key\n            )\n            result = Security.SSLSetCertificate(self.context, self._client_cert_chain)\n            _assert_no_error(result)\n\n        while True:\n            with self._raise_on_error():\n                result = Security.SSLHandshake(self.context)\n\n                if result == SecurityConst.errSSLWouldBlock:\n                    raise socket.timeout(\"handshake timed out\")\n                elif result == SecurityConst.errSSLServerAuthCompleted:\n                    self._custom_validate(verify, trust_bundle)\n                    continue\n                else:\n                    _assert_no_error(result)\n                    break\n\n    def fileno(self):\n        return self.socket.fileno()\n\n    # Copy-pasted from Python 3.5 source code\n    def _decref_socketios(self):\n        if self._makefile_refs &gt; 0:\n            self._makefile_refs -= 1\n        if self._closed:\n            self.close()\n\n    def recv(self, bufsiz):\n        buffer = ctypes.create_string_buffer(bufsiz)\n        bytes_read = self.recv_into(buffer, bufsiz)\n        data = buffer[:bytes_read]\n        return data\n\n    def recv_into(self, buffer, nbytes=None):\n        # Read short on EOF.\n        if self._closed:\n            return 0\n\n        if nbytes is None:\n            nbytes = len(buffer)\n\n        buffer = (ctypes.c_char * nbytes).from_buffer(buffer)\n        processed_bytes = ctypes.c_size_t(0)\n\n        with self._raise_on_error():\n            result = Security.SSLRead(\n                self.context, buffer, nbytes, ctypes.byref(processed_bytes)\n            )\n\n        # There are some result codes that we want to treat as \"not always\n        # errors\". Specifically, those are errSSLWouldBlock,\n        # errSSLClosedGraceful, and errSSLClosedNoNotify.\n        if result == SecurityConst.errSSLWouldBlock:\n            # If we didn't process any bytes, then this was just a time out.\n            # However, we can get errSSLWouldBlock in situations when we *did*\n            # read some data, and in those cases we should just read \"short\"\n            # and return.\n            if processed_bytes.value == 0:\n                # Timed out, no data read.\n                raise socket.timeout(\"recv timed out\")\n        elif result in (\n            SecurityConst.errSSLClosedGraceful,\n            SecurityConst.errSSLClosedNoNotify,\n        ):\n            # The remote peer has closed this connection. We should do so as\n            # well. Note that we don't actually return here because in\n            # principle this could actually be fired along with return data.\n            # It's unlikely though.\n            self.close()\n        else:\n            _assert_no_error(result)\n\n        # Ok, we read and probably succeeded. We should return whatever data\n        # was actually read.\n        return processed_bytes.value\n\n    def settimeout(self, timeout):\n        self._timeout = timeout\n\n    def gettimeout(self):\n        return self._timeout\n\n    def send(self, data):\n        processed_bytes = ctypes.c_size_t(0)\n\n        with self._raise_on_error():\n            result = Security.SSLWrite(\n                self.context, data, len(data), ctypes.byref(processed_bytes)\n            )\n\n        if result == SecurityConst.errSSLWouldBlock and processed_bytes.value == 0:\n            # Timed out\n            raise socket.timeout(\"send timed out\")\n        else:\n            _assert_no_error(result)\n\n        # We sent, and probably succeeded. Tell them how much we sent.\n        return processed_bytes.value\n\n    def sendall(self, data):\n        total_sent = 0\n        while total_sent &lt; len(data):\n            sent = self.send(data[total_sent : total_sent + SSL_WRITE_BLOCKSIZE])\n            total_sent += sent\n\n    def shutdown(self):\n        with self._raise_on_error():\n            Security.SSLClose(self.context)\n\n    def close(self):\n        # TODO: should I do clean shutdown here? Do I have to?\n        if self._makefile_refs &lt; 1:\n            self._closed = True\n            if self.context:\n                CoreFoundation.CFRelease(self.context)\n                self.context = None\n            if self._client_cert_chain:\n                CoreFoundation.CFRelease(self._client_cert_chain)\n                self._client_cert_chain = None\n            if self._keychain:\n                Security.SecKeychainDelete(self._keychain)\n                CoreFoundation.CFRelease(self._keychain)\n                shutil.rmtree(self._keychain_dir)\n                self._keychain = self._keychain_dir = None\n            return self.socket.close()\n        else:\n            self._makefile_refs -= 1\n\n    def getpeercert(self, binary_form=False):\n        # Urgh, annoying.\n        #\n        # Here's how we do this:\n        #\n        # 1. Call SSLCopyPeerTrust to get hold of the trust object for this\n        #    connection.\n        # 2. Call SecTrustGetCertificateAtIndex for index 0 to get the leaf.\n        # 3. To get the CN, call SecCertificateCopyCommonName and process that\n        #    string so that it's of the appropriate type.\n        # 4. To get the SAN, we need to do something a bit more complex:\n        #    a. Call SecCertificateCopyValues to get the data, requesting\n        #       kSecOIDSubjectAltName.\n        #    b. Mess about with this dictionary to try to get the SANs out.\n        #\n        # This is gross. Really gross. It's going to be a few hundred LoC extra\n        # just to repeat something that SecureTransport can *already do*. So my\n        # operating assumption at this time is that what we want to do is\n        # instead to just flag to urllib3 that it shouldn't do its own hostname\n        # validation when using SecureTransport.\n        if not binary_form:\n            raise ValueError(\"SecureTransport only supports dumping binary certs\")\n        trust = Security.SecTrustRef()\n        certdata = None\n        der_bytes = None\n\n        try:\n            # Grab the trust store.\n            result = Security.SSLCopyPeerTrust(self.context, ctypes.byref(trust))\n            _assert_no_error(result)\n            if not trust:\n                # Probably we haven't done the handshake yet. No biggie.\n                return None\n\n            cert_count = Security.SecTrustGetCertificateCount(trust)\n            if not cert_count:\n                # Also a case that might happen if we haven't handshaked.\n                # Handshook? Handshaken?\n                return None\n\n            leaf = Security.SecTrustGetCertificateAtIndex(trust, 0)\n            assert leaf\n\n            # Ok, now we want the DER bytes.\n            certdata = Security.SecCertificateCopyData(leaf)\n            assert certdata\n\n            data_length = CoreFoundation.CFDataGetLength(certdata)\n            data_buffer = CoreFoundation.CFDataGetBytePtr(certdata)\n            der_bytes = ctypes.string_at(data_buffer, data_length)\n        finally:\n            if certdata:\n                CoreFoundation.CFRelease(certdata)\n            if trust:\n                CoreFoundation.CFRelease(trust)\n\n        return der_bytes\n\n    def version(self):\n        protocol = Security.SSLProtocol()\n        result = Security.SSLGetNegotiatedProtocolVersion(\n            self.context, ctypes.byref(protocol)\n        )\n        _assert_no_error(result)\n        if protocol.value == SecurityConst.kTLSProtocol13:\n            raise ssl.SSLError(\"SecureTransport does not support TLS 1.3\")\n        elif protocol.value == SecurityConst.kTLSProtocol12:\n            return \"TLSv1.2\"\n        elif protocol.value == SecurityConst.kTLSProtocol11:\n            return \"TLSv1.1\"\n        elif protocol.value == SecurityConst.kTLSProtocol1:\n            return \"TLSv1\"\n        elif protocol.value == SecurityConst.kSSLProtocol3:\n            return \"SSLv3\"\n        elif protocol.value == SecurityConst.kSSLProtocol2:\n            return \"SSLv2\"\n        else:\n            raise ssl.SSLError(\"Unknown TLS version: %r\" % protocol)\n\n    def _reuse(self):\n        self._makefile_refs += 1\n\n    def _drop(self):\n        if self._makefile_refs &lt; 1:\n            self.close()\n        else:\n            self._makefile_refs -= 1\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/securetransport.html#client.ayon_fusion.vendor.urllib3.contrib.securetransport.WrappedSocket.handshake","title":"<code>handshake(server_hostname, verify, trust_bundle, min_version, max_version, client_cert, client_key, client_key_passphrase, alpn_protocols)</code>","text":"<p>Actually performs the TLS handshake. This is run automatically by wrapped socket, and shouldn't be needed in user code.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/securetransport.py</code> <pre><code>def handshake(\n    self,\n    server_hostname,\n    verify,\n    trust_bundle,\n    min_version,\n    max_version,\n    client_cert,\n    client_key,\n    client_key_passphrase,\n    alpn_protocols,\n):\n    \"\"\"\n    Actually performs the TLS handshake. This is run automatically by\n    wrapped socket, and shouldn't be needed in user code.\n    \"\"\"\n    # First, we do the initial bits of connection setup. We need to create\n    # a context, set its I/O funcs, and set the connection reference.\n    self.context = Security.SSLCreateContext(\n        None, SecurityConst.kSSLClientSide, SecurityConst.kSSLStreamType\n    )\n    result = Security.SSLSetIOFuncs(\n        self.context, _read_callback_pointer, _write_callback_pointer\n    )\n    _assert_no_error(result)\n\n    # Here we need to compute the handle to use. We do this by taking the\n    # id of self modulo 2**31 - 1. If this is already in the dictionary, we\n    # just keep incrementing by one until we find a free space.\n    with _connection_ref_lock:\n        handle = id(self) % 2147483647\n        while handle in _connection_refs:\n            handle = (handle + 1) % 2147483647\n        _connection_refs[handle] = self\n\n    result = Security.SSLSetConnection(self.context, handle)\n    _assert_no_error(result)\n\n    # If we have a server hostname, we should set that too.\n    if server_hostname:\n        if not isinstance(server_hostname, bytes):\n            server_hostname = server_hostname.encode(\"utf-8\")\n\n        result = Security.SSLSetPeerDomainName(\n            self.context, server_hostname, len(server_hostname)\n        )\n        _assert_no_error(result)\n\n    # Setup the ciphers.\n    self._set_ciphers()\n\n    # Setup the ALPN protocols.\n    self._set_alpn_protocols(alpn_protocols)\n\n    # Set the minimum and maximum TLS versions.\n    result = Security.SSLSetProtocolVersionMin(self.context, min_version)\n    _assert_no_error(result)\n\n    result = Security.SSLSetProtocolVersionMax(self.context, max_version)\n    _assert_no_error(result)\n\n    # If there's a trust DB, we need to use it. We do that by telling\n    # SecureTransport to break on server auth. We also do that if we don't\n    # want to validate the certs at all: we just won't actually do any\n    # authing in that case.\n    if not verify or trust_bundle is not None:\n        result = Security.SSLSetSessionOption(\n            self.context, SecurityConst.kSSLSessionOptionBreakOnServerAuth, True\n        )\n        _assert_no_error(result)\n\n    # If there's a client cert, we need to use it.\n    if client_cert:\n        self._keychain, self._keychain_dir = _temporary_keychain()\n        self._client_cert_chain = _load_client_cert_chain(\n            self._keychain, client_cert, client_key\n        )\n        result = Security.SSLSetCertificate(self.context, self._client_cert_chain)\n        _assert_no_error(result)\n\n    while True:\n        with self._raise_on_error():\n            result = Security.SSLHandshake(self.context)\n\n            if result == SecurityConst.errSSLWouldBlock:\n                raise socket.timeout(\"handshake timed out\")\n            elif result == SecurityConst.errSSLServerAuthCompleted:\n                self._custom_validate(verify, trust_bundle)\n                continue\n            else:\n                _assert_no_error(result)\n                break\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/securetransport.html#client.ayon_fusion.vendor.urllib3.contrib.securetransport.extract_from_urllib3","title":"<code>extract_from_urllib3()</code>","text":"<p>Undo monkey-patching by :func:<code>inject_into_urllib3</code>.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/securetransport.py</code> <pre><code>def extract_from_urllib3():\n    \"\"\"\n    Undo monkey-patching by :func:`inject_into_urllib3`.\n    \"\"\"\n    util.SSLContext = orig_util_SSLContext\n    util.ssl_.SSLContext = orig_util_SSLContext\n    util.HAS_SNI = orig_util_HAS_SNI\n    util.ssl_.HAS_SNI = orig_util_HAS_SNI\n    util.IS_SECURETRANSPORT = False\n    util.ssl_.IS_SECURETRANSPORT = False\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/securetransport.html#client.ayon_fusion.vendor.urllib3.contrib.securetransport.inject_into_urllib3","title":"<code>inject_into_urllib3()</code>","text":"<p>Monkey-patch urllib3 with SecureTransport-backed SSL-support.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/securetransport.py</code> <pre><code>def inject_into_urllib3():\n    \"\"\"\n    Monkey-patch urllib3 with SecureTransport-backed SSL-support.\n    \"\"\"\n    util.SSLContext = SecureTransportContext\n    util.ssl_.SSLContext = SecureTransportContext\n    util.HAS_SNI = HAS_SNI\n    util.ssl_.HAS_SNI = HAS_SNI\n    util.IS_SECURETRANSPORT = True\n    util.ssl_.IS_SECURETRANSPORT = True\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/socks.html","title":"socks","text":"<p>This module contains provisional support for SOCKS proxies from within urllib3. This module supports SOCKS4, SOCKS4A (an extension of SOCKS4), and SOCKS5. To enable its functionality, either install PySocks or install this module with the <code>socks</code> extra.</p> <p>The SOCKS implementation supports the full range of urllib3 features. It also supports the following SOCKS features:</p> <ul> <li>SOCKS4A (<code>proxy_url='socks4a://...</code>)</li> <li>SOCKS4 (<code>proxy_url='socks4://...</code>)</li> <li>SOCKS5 with remote DNS (<code>proxy_url='socks5h://...</code>)</li> <li>SOCKS5 with local DNS (<code>proxy_url='socks5://...</code>)</li> <li>Usernames and passwords for the SOCKS proxy</li> </ul> <p>.. note::    It is recommended to use <code>socks5h://</code> or <code>socks4a://</code> schemes in    your <code>proxy_url</code> to ensure that DNS resolution is done from the remote    server instead of client-side when connecting to a domain name.</p> <p>SOCKS4 supports IPv4 and domain names with the SOCKS4A extension. SOCKS5 supports IPv4, IPv6, and domain names.</p> <p>When connecting to a SOCKS4 proxy the <code>username</code> portion of the <code>proxy_url</code> will be sent as the <code>userid</code> section of the SOCKS request:</p> <p>.. code-block:: python</p> <pre><code>proxy_url=\"socks4a://&lt;userid&gt;@proxy-host\"\n</code></pre> <p>When connecting to a SOCKS5 proxy the <code>username</code> and <code>password</code> portion of the <code>proxy_url</code> will be sent as the username/password to authenticate with the proxy:</p> <p>.. code-block:: python</p> <pre><code>proxy_url=\"socks5h://&lt;username&gt;:&lt;password&gt;@proxy-host\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/socks.html#client.ayon_fusion.vendor.urllib3.contrib.socks.SOCKSConnection","title":"<code>SOCKSConnection</code>","text":"<p>               Bases: <code>HTTPConnection</code></p> <p>A plain-text HTTP connection that connects via a SOCKS proxy.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/socks.py</code> <pre><code>class SOCKSConnection(HTTPConnection):\n    \"\"\"\n    A plain-text HTTP connection that connects via a SOCKS proxy.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._socks_options = kwargs.pop(\"_socks_options\")\n        super(SOCKSConnection, self).__init__(*args, **kwargs)\n\n    def _new_conn(self):\n        \"\"\"\n        Establish a new connection via the SOCKS proxy.\n        \"\"\"\n        extra_kw = {}\n        if self.source_address:\n            extra_kw[\"source_address\"] = self.source_address\n\n        if self.socket_options:\n            extra_kw[\"socket_options\"] = self.socket_options\n\n        try:\n            conn = socks.create_connection(\n                (self.host, self.port),\n                proxy_type=self._socks_options[\"socks_version\"],\n                proxy_addr=self._socks_options[\"proxy_host\"],\n                proxy_port=self._socks_options[\"proxy_port\"],\n                proxy_username=self._socks_options[\"username\"],\n                proxy_password=self._socks_options[\"password\"],\n                proxy_rdns=self._socks_options[\"rdns\"],\n                timeout=self.timeout,\n                **extra_kw\n            )\n\n        except SocketTimeout:\n            raise ConnectTimeoutError(\n                self,\n                \"Connection to %s timed out. (connect timeout=%s)\"\n                % (self.host, self.timeout),\n            )\n\n        except socks.ProxyError as e:\n            # This is fragile as hell, but it seems to be the only way to raise\n            # useful errors here.\n            if e.socket_err:\n                error = e.socket_err\n                if isinstance(error, SocketTimeout):\n                    raise ConnectTimeoutError(\n                        self,\n                        \"Connection to %s timed out. (connect timeout=%s)\"\n                        % (self.host, self.timeout),\n                    )\n                else:\n                    raise NewConnectionError(\n                        self, \"Failed to establish a new connection: %s\" % error\n                    )\n            else:\n                raise NewConnectionError(\n                    self, \"Failed to establish a new connection: %s\" % e\n                )\n\n        except SocketError as e:  # Defensive: PySocks should catch all these.\n            raise NewConnectionError(\n                self, \"Failed to establish a new connection: %s\" % e\n            )\n\n        return conn\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/socks.html#client.ayon_fusion.vendor.urllib3.contrib.socks.SOCKSProxyManager","title":"<code>SOCKSProxyManager</code>","text":"<p>               Bases: <code>PoolManager</code></p> <p>A version of the urllib3 ProxyManager that routes connections via the defined SOCKS proxy.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/socks.py</code> <pre><code>class SOCKSProxyManager(PoolManager):\n    \"\"\"\n    A version of the urllib3 ProxyManager that routes connections via the\n    defined SOCKS proxy.\n    \"\"\"\n\n    pool_classes_by_scheme = {\n        \"http\": SOCKSHTTPConnectionPool,\n        \"https\": SOCKSHTTPSConnectionPool,\n    }\n\n    def __init__(\n        self,\n        proxy_url,\n        username=None,\n        password=None,\n        num_pools=10,\n        headers=None,\n        **connection_pool_kw\n    ):\n        parsed = parse_url(proxy_url)\n\n        if username is None and password is None and parsed.auth is not None:\n            split = parsed.auth.split(\":\")\n            if len(split) == 2:\n                username, password = split\n        if parsed.scheme == \"socks5\":\n            socks_version = socks.PROXY_TYPE_SOCKS5\n            rdns = False\n        elif parsed.scheme == \"socks5h\":\n            socks_version = socks.PROXY_TYPE_SOCKS5\n            rdns = True\n        elif parsed.scheme == \"socks4\":\n            socks_version = socks.PROXY_TYPE_SOCKS4\n            rdns = False\n        elif parsed.scheme == \"socks4a\":\n            socks_version = socks.PROXY_TYPE_SOCKS4\n            rdns = True\n        else:\n            raise ValueError(\"Unable to determine SOCKS version from %s\" % proxy_url)\n\n        self.proxy_url = proxy_url\n\n        socks_options = {\n            \"socks_version\": socks_version,\n            \"proxy_host\": parsed.host,\n            \"proxy_port\": parsed.port,\n            \"username\": username,\n            \"password\": password,\n            \"rdns\": rdns,\n        }\n        connection_pool_kw[\"_socks_options\"] = socks_options\n\n        super(SOCKSProxyManager, self).__init__(\n            num_pools, headers, **connection_pool_kw\n        )\n\n        self.pool_classes_by_scheme = SOCKSProxyManager.pool_classes_by_scheme\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/_securetransport/index.html","title":"_securetransport","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/_securetransport/bindings.html","title":"bindings","text":"<p>This module uses ctypes to bind a whole bunch of functions and constants from SecureTransport. The goal here is to provide the low-level API to SecureTransport. These are essentially the C-level functions and constants, and they're pretty gross to work with.</p> <p>This code is a bastardised version of the code found in Will Bond's oscrypto library. An enormous debt is owed to him for blazing this trail for us. For that reason, this code should be considered to be covered both by urllib3's license and by oscrypto's:</p> <pre><code>Copyright (c) 2015-2016 Will Bond &lt;will@wbond.net&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the \"Software\"),\nto deal in the Software without restriction, including without limitation\nthe rights to use, copy, modify, merge, publish, distribute, sublicense,\nand/or sell copies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/_securetransport/bindings.html#client.ayon_fusion.vendor.urllib3.contrib._securetransport.bindings.CFConst","title":"<code>CFConst</code>","text":"<p>               Bases: <code>object</code></p> <p>A class object that acts as essentially a namespace for CoreFoundation constants.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/_securetransport/bindings.py</code> <pre><code>class CFConst(object):\n    \"\"\"\n    A class object that acts as essentially a namespace for CoreFoundation\n    constants.\n    \"\"\"\n\n    kCFStringEncodingUTF8 = CFStringEncoding(0x08000100)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/_securetransport/bindings.html#client.ayon_fusion.vendor.urllib3.contrib._securetransport.bindings.SecurityConst","title":"<code>SecurityConst</code>","text":"<p>               Bases: <code>object</code></p> <p>A class object that acts as essentially a namespace for Security constants.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/_securetransport/bindings.py</code> <pre><code>class SecurityConst(object):\n    \"\"\"\n    A class object that acts as essentially a namespace for Security constants.\n    \"\"\"\n\n    kSSLSessionOptionBreakOnServerAuth = 0\n\n    kSSLProtocol2 = 1\n    kSSLProtocol3 = 2\n    kTLSProtocol1 = 4\n    kTLSProtocol11 = 7\n    kTLSProtocol12 = 8\n    # SecureTransport does not support TLS 1.3 even if there's a constant for it\n    kTLSProtocol13 = 10\n    kTLSProtocolMaxSupported = 999\n\n    kSSLClientSide = 1\n    kSSLStreamType = 0\n\n    kSecFormatPEMSequence = 10\n\n    kSecTrustResultInvalid = 0\n    kSecTrustResultProceed = 1\n    # This gap is present on purpose: this was kSecTrustResultConfirm, which\n    # is deprecated.\n    kSecTrustResultDeny = 3\n    kSecTrustResultUnspecified = 4\n    kSecTrustResultRecoverableTrustFailure = 5\n    kSecTrustResultFatalTrustFailure = 6\n    kSecTrustResultOtherError = 7\n\n    errSSLProtocol = -9800\n    errSSLWouldBlock = -9803\n    errSSLClosedGraceful = -9805\n    errSSLClosedNoNotify = -9816\n    errSSLClosedAbort = -9806\n\n    errSSLXCertChainInvalid = -9807\n    errSSLCrypto = -9809\n    errSSLInternal = -9810\n    errSSLCertExpired = -9814\n    errSSLCertNotYetValid = -9815\n    errSSLUnknownRootCert = -9812\n    errSSLNoRootCert = -9813\n    errSSLHostNameMismatch = -9843\n    errSSLPeerHandshakeFail = -9824\n    errSSLPeerUserCancelled = -9839\n    errSSLWeakPeerEphemeralDHKey = -9850\n    errSSLServerAuthCompleted = -9841\n    errSSLRecordOverflow = -9847\n\n    errSecVerifyFailed = -67808\n    errSecNoTrustSettings = -25263\n    errSecItemNotFound = -25300\n    errSecInvalidTrustSettings = -25262\n\n    # Cipher suites. We only pick the ones our default cipher string allows.\n    # Source: https://developer.apple.com/documentation/security/1550981-ssl_cipher_suite_values\n    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 = 0xC02C\n    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 = 0xC030\n    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 = 0xC02B\n    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 = 0xC02F\n    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA9\n    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 = 0xCCA8\n    TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 = 0x009F\n    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 = 0x009E\n    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 = 0xC024\n    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 = 0xC028\n    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA = 0xC00A\n    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA = 0xC014\n    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256 = 0x006B\n    TLS_DHE_RSA_WITH_AES_256_CBC_SHA = 0x0039\n    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 = 0xC023\n    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 = 0xC027\n    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA = 0xC009\n    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA = 0xC013\n    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256 = 0x0067\n    TLS_DHE_RSA_WITH_AES_128_CBC_SHA = 0x0033\n    TLS_RSA_WITH_AES_256_GCM_SHA384 = 0x009D\n    TLS_RSA_WITH_AES_128_GCM_SHA256 = 0x009C\n    TLS_RSA_WITH_AES_256_CBC_SHA256 = 0x003D\n    TLS_RSA_WITH_AES_128_CBC_SHA256 = 0x003C\n    TLS_RSA_WITH_AES_256_CBC_SHA = 0x0035\n    TLS_RSA_WITH_AES_128_CBC_SHA = 0x002F\n    TLS_AES_128_GCM_SHA256 = 0x1301\n    TLS_AES_256_GCM_SHA384 = 0x1302\n    TLS_AES_128_CCM_8_SHA256 = 0x1305\n    TLS_AES_128_CCM_SHA256 = 0x1304\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/_securetransport/bindings.html#client.ayon_fusion.vendor.urllib3.contrib._securetransport.bindings.load_cdll","title":"<code>load_cdll(name, macos10_16_path)</code>","text":"<p>Loads a CDLL by name, falling back to known path on 10.16+</p> Source code in <code>client/ayon_fusion/vendor/urllib3/contrib/_securetransport/bindings.py</code> <pre><code>def load_cdll(name, macos10_16_path):\n    \"\"\"Loads a CDLL by name, falling back to known path on 10.16+\"\"\"\n    try:\n        # Big Sur is technically 11 but we use 10.16 due to the Big Sur\n        # beta being labeled as 10.16.\n        if version_info &gt;= (10, 16):\n            path = macos10_16_path\n        else:\n            path = find_library(name)\n        if not path:\n            raise OSError  # Caught and reraised as 'ImportError'\n        return CDLL(path, use_errno=True)\n    except OSError:\n        raise_from(ImportError(\"The library %s failed to load\" % name), None)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/contrib/_securetransport/low_level.html","title":"low_level","text":"<p>Low-level helpers for the SecureTransport bindings.</p> <p>These are Python functions that are not directly related to the high-level APIs but are necessary to get them to work. They include a whole bunch of low-level CoreFoundation messing about and memory management. The concerns in this module are almost entirely about trying to avoid memory leaks and providing appropriate and useful assistance to the higher-level code.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/index.html","title":"packages","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html","title":"six","text":"<p>Utilities for writing code that runs on Python 2 and 3</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.Module_six_moves_urllib","title":"<code>Module_six_moves_urllib</code>","text":"<p>               Bases: <code>ModuleType</code></p> <p>Create a six.moves.urllib namespace that resembles the Python 3 namespace</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>class Module_six_moves_urllib(types.ModuleType):\n\n    \"\"\"Create a six.moves.urllib namespace that resembles the Python 3 namespace\"\"\"\n\n    __path__ = []  # mark as package\n    parse = _importer._get_module(\"moves.urllib_parse\")\n    error = _importer._get_module(\"moves.urllib_error\")\n    request = _importer._get_module(\"moves.urllib_request\")\n    response = _importer._get_module(\"moves.urllib_response\")\n    robotparser = _importer._get_module(\"moves.urllib_robotparser\")\n\n    def __dir__(self):\n        return [\"parse\", \"error\", \"request\", \"response\", \"robotparser\"]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.Module_six_moves_urllib_error","title":"<code>Module_six_moves_urllib_error</code>","text":"<p>               Bases: <code>_LazyModule</code></p> <p>Lazy loading of moved objects in six.moves.urllib_error</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>class Module_six_moves_urllib_error(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_error\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.Module_six_moves_urllib_parse","title":"<code>Module_six_moves_urllib_parse</code>","text":"<p>               Bases: <code>_LazyModule</code></p> <p>Lazy loading of moved objects in six.moves.urllib_parse</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>class Module_six_moves_urllib_parse(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_parse\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.Module_six_moves_urllib_request","title":"<code>Module_six_moves_urllib_request</code>","text":"<p>               Bases: <code>_LazyModule</code></p> <p>Lazy loading of moved objects in six.moves.urllib_request</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>class Module_six_moves_urllib_request(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_request\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.Module_six_moves_urllib_response","title":"<code>Module_six_moves_urllib_response</code>","text":"<p>               Bases: <code>_LazyModule</code></p> <p>Lazy loading of moved objects in six.moves.urllib_response</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>class Module_six_moves_urllib_response(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_response\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.Module_six_moves_urllib_robotparser","title":"<code>Module_six_moves_urllib_robotparser</code>","text":"<p>               Bases: <code>_LazyModule</code></p> <p>Lazy loading of moved objects in six.moves.urllib_robotparser</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>class Module_six_moves_urllib_robotparser(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_robotparser\"\"\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.add_metaclass","title":"<code>add_metaclass(metaclass)</code>","text":"<p>Class decorator for creating a class with a metaclass.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>def add_metaclass(metaclass):\n    \"\"\"Class decorator for creating a class with a metaclass.\"\"\"\n\n    def wrapper(cls):\n        orig_vars = cls.__dict__.copy()\n        slots = orig_vars.get(\"__slots__\")\n        if slots is not None:\n            if isinstance(slots, str):\n                slots = [slots]\n            for slots_var in slots:\n                orig_vars.pop(slots_var)\n        orig_vars.pop(\"__dict__\", None)\n        orig_vars.pop(\"__weakref__\", None)\n        if hasattr(cls, \"__qualname__\"):\n            orig_vars[\"__qualname__\"] = cls.__qualname__\n        return metaclass(cls.__name__, cls.__bases__, orig_vars)\n\n    return wrapper\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.add_move","title":"<code>add_move(move)</code>","text":"<p>Add an item to six.moves.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>def add_move(move):\n    \"\"\"Add an item to six.moves.\"\"\"\n    setattr(_MovedItems, move.name, move)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.ensure_binary","title":"<code>ensure_binary(s, encoding='utf-8', errors='strict')</code>","text":"<p>Coerce s to six.binary_type.</p> For Python 2 <ul> <li><code>unicode</code> -&gt; encoded to <code>str</code></li> <li><code>str</code> -&gt; <code>str</code></li> </ul> For Python 3 <ul> <li><code>str</code> -&gt; encoded to <code>bytes</code></li> <li><code>bytes</code> -&gt; <code>bytes</code></li> </ul> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>def ensure_binary(s, encoding=\"utf-8\", errors=\"strict\"):\n    \"\"\"Coerce **s** to six.binary_type.\n\n    For Python 2:\n      - `unicode` -&gt; encoded to `str`\n      - `str` -&gt; `str`\n\n    For Python 3:\n      - `str` -&gt; encoded to `bytes`\n      - `bytes` -&gt; `bytes`\n    \"\"\"\n    if isinstance(s, binary_type):\n        return s\n    if isinstance(s, text_type):\n        return s.encode(encoding, errors)\n    raise TypeError(\"not expecting type '%s'\" % type(s))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.ensure_str","title":"<code>ensure_str(s, encoding='utf-8', errors='strict')</code>","text":"<p>Coerce s to <code>str</code>.</p> For Python 2 <ul> <li><code>unicode</code> -&gt; encoded to <code>str</code></li> <li><code>str</code> -&gt; <code>str</code></li> </ul> For Python 3 <ul> <li><code>str</code> -&gt; <code>str</code></li> <li><code>bytes</code> -&gt; decoded to <code>str</code></li> </ul> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>def ensure_str(s, encoding=\"utf-8\", errors=\"strict\"):\n    \"\"\"Coerce *s* to `str`.\n\n    For Python 2:\n      - `unicode` -&gt; encoded to `str`\n      - `str` -&gt; `str`\n\n    For Python 3:\n      - `str` -&gt; `str`\n      - `bytes` -&gt; decoded to `str`\n    \"\"\"\n    # Optimization: Fast return for the common case.\n    if type(s) is str:\n        return s\n    if PY2 and isinstance(s, text_type):\n        return s.encode(encoding, errors)\n    elif PY3 and isinstance(s, binary_type):\n        return s.decode(encoding, errors)\n    elif not isinstance(s, (text_type, binary_type)):\n        raise TypeError(\"not expecting type '%s'\" % type(s))\n    return s\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.ensure_text","title":"<code>ensure_text(s, encoding='utf-8', errors='strict')</code>","text":"<p>Coerce s to six.text_type.</p> For Python 2 <ul> <li><code>unicode</code> -&gt; <code>unicode</code></li> <li><code>str</code> -&gt; <code>unicode</code></li> </ul> For Python 3 <ul> <li><code>str</code> -&gt; <code>str</code></li> <li><code>bytes</code> -&gt; decoded to <code>str</code></li> </ul> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>def ensure_text(s, encoding=\"utf-8\", errors=\"strict\"):\n    \"\"\"Coerce *s* to six.text_type.\n\n    For Python 2:\n      - `unicode` -&gt; `unicode`\n      - `str` -&gt; `unicode`\n\n    For Python 3:\n      - `str` -&gt; `str`\n      - `bytes` -&gt; decoded to `str`\n    \"\"\"\n    if isinstance(s, binary_type):\n        return s.decode(encoding, errors)\n    elif isinstance(s, text_type):\n        return s\n    else:\n        raise TypeError(\"not expecting type '%s'\" % type(s))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.exec_","title":"<code>exec_(_code_, _globs_=None, _locs_=None)</code>","text":"<p>Execute code in a namespace.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>def exec_(_code_, _globs_=None, _locs_=None):\n    \"\"\"Execute code in a namespace.\"\"\"\n    if _globs_ is None:\n        frame = sys._getframe(1)\n        _globs_ = frame.f_globals\n        if _locs_ is None:\n            _locs_ = frame.f_locals\n        del frame\n    elif _locs_ is None:\n        _locs_ = _globs_\n    exec (\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.python_2_unicode_compatible","title":"<code>python_2_unicode_compatible(klass)</code>","text":"<p>A class decorator that defines unicode and str methods under Python 2. Under Python 3 it does nothing.</p> <p>To support Python 2 and 3 with a single code base, define a str method returning text and apply this decorator to the class.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>def python_2_unicode_compatible(klass):\n    \"\"\"\n    A class decorator that defines __unicode__ and __str__ methods under Python 2.\n    Under Python 3 it does nothing.\n\n    To support Python 2 and 3 with a single code base, define a __str__ method\n    returning text and apply this decorator to the class.\n    \"\"\"\n    if PY2:\n        if \"__str__\" not in klass.__dict__:\n            raise ValueError(\n                \"@python_2_unicode_compatible cannot be applied \"\n                \"to %s because it doesn't define __str__().\" % klass.__name__\n            )\n        klass.__unicode__ = klass.__str__\n        klass.__str__ = lambda self: self.__unicode__().encode(\"utf-8\")\n    return klass\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.remove_move","title":"<code>remove_move(name)</code>","text":"<p>Remove item from six.moves.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>def remove_move(name):\n    \"\"\"Remove item from six.moves.\"\"\"\n    try:\n        delattr(_MovedItems, name)\n    except AttributeError:\n        try:\n            del moves.__dict__[name]\n        except KeyError:\n            raise AttributeError(\"no such move, %r\" % (name,))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/six.html#client.ayon_fusion.vendor.urllib3.packages.six.with_metaclass","title":"<code>with_metaclass(meta, *bases)</code>","text":"<p>Create a base class with a metaclass.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/six.py</code> <pre><code>def with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    # This requires a bit of explanation: the basic idea is to make a dummy\n    # metaclass for one level of class instantiation that replaces itself with\n    # the actual metaclass.\n    class metaclass(type):\n        def __new__(cls, name, this_bases, d):\n            if sys.version_info[:2] &gt;= (3, 7):\n                # This version introduced PEP 560 that requires a bit\n                # of extra care (we mimic what is done by __build_class__).\n                resolved_bases = types.resolve_bases(bases)\n                if resolved_bases is not bases:\n                    d[\"__orig_bases__\"] = bases\n            else:\n                resolved_bases = bases\n            return meta(name, resolved_bases, d)\n\n        @classmethod\n        def __prepare__(cls, name, this_bases):\n            return meta.__prepare__(name, bases)\n\n    return type.__new__(metaclass, \"temporary_class\", (), {})\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/backports/index.html","title":"backports","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/backports/makefile.html","title":"makefile","text":"<p>backports.makefile ~~~~~~~~~~~~~~~~~~</p> <p>Backports the Python 3 <code>socket.makefile</code> method for use with anything that wants to create a \"fake\" socket object.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/backports/makefile.html#client.ayon_fusion.vendor.urllib3.packages.backports.makefile.backport_makefile","title":"<code>backport_makefile(self, mode='r', buffering=None, encoding=None, errors=None, newline=None)</code>","text":"<p>Backport of <code>socket.makefile</code> from Python 3.5.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/backports/makefile.py</code> <pre><code>def backport_makefile(\n    self, mode=\"r\", buffering=None, encoding=None, errors=None, newline=None\n):\n    \"\"\"\n    Backport of ``socket.makefile`` from Python 3.5.\n    \"\"\"\n    if not set(mode) &lt;= {\"r\", \"w\", \"b\"}:\n        raise ValueError(\"invalid mode %r (only r, w, b allowed)\" % (mode,))\n    writing = \"w\" in mode\n    reading = \"r\" in mode or not writing\n    assert reading or writing\n    binary = \"b\" in mode\n    rawmode = \"\"\n    if reading:\n        rawmode += \"r\"\n    if writing:\n        rawmode += \"w\"\n    raw = SocketIO(self, rawmode)\n    self._makefile_refs += 1\n    if buffering is None:\n        buffering = -1\n    if buffering &lt; 0:\n        buffering = io.DEFAULT_BUFFER_SIZE\n    if buffering == 0:\n        if not binary:\n            raise ValueError(\"unbuffered streams must be binary\")\n        return raw\n    if reading and writing:\n        buffer = io.BufferedRWPair(raw, raw, buffering)\n    elif reading:\n        buffer = io.BufferedReader(raw, buffering)\n    else:\n        assert writing\n        buffer = io.BufferedWriter(raw, buffering)\n    if binary:\n        return buffer\n    text = io.TextIOWrapper(buffer, encoding, errors, newline)\n    text.mode = mode\n    return text\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/ssl_match_hostname/index.html","title":"ssl_match_hostname","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/ssl_match_hostname/index.html#client.ayon_fusion.vendor.urllib3.packages.ssl_match_hostname.match_hostname","title":"<code>match_hostname(cert, hostname)</code>","text":"<p>Verify that cert (in decoded format as returned by SSLSocket.getpeercert()) matches the hostname.  RFC 2818 and RFC 6125 rules are followed, but IP addresses are not accepted for hostname.</p> <p>CertificateError is raised on failure. On success, the function returns nothing.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/ssl_match_hostname/_implementation.py</code> <pre><code>def match_hostname(cert, hostname):\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n\n    CertificateError is raised on failure. On success, the function\n    returns nothing.\n    \"\"\"\n    if not cert:\n        raise ValueError(\n            \"empty or no certificate, match_hostname needs a \"\n            \"SSL socket or SSL context with either \"\n            \"CERT_OPTIONAL or CERT_REQUIRED\"\n        )\n    try:\n        # Divergence from upstream: ipaddress can't handle byte str\n        host_ip = ipaddress.ip_address(_to_unicode(hostname))\n    except ValueError:\n        # Not an IP address (common case)\n        host_ip = None\n    except UnicodeError:\n        # Divergence from upstream: Have to deal with ipaddress not taking\n        # byte strings.  addresses should be all ascii, so we consider it not\n        # an ipaddress in this case\n        host_ip = None\n    except AttributeError:\n        # Divergence from upstream: Make ipaddress library optional\n        if ipaddress is None:\n            host_ip = None\n        else:\n            raise\n    dnsnames = []\n    san = cert.get(\"subjectAltName\", ())\n    for key, value in san:\n        if key == \"DNS\":\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == \"IP Address\":\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if not dnsnames:\n        # The subject is only checked when there is no dNSName entry\n        # in subjectAltName\n        for sub in cert.get(\"subject\", ()):\n            for key, value in sub:\n                # XXX according to RFC 2818, the most specific Common Name\n                # must be used.\n                if key == \"commonName\":\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) &gt; 1:\n        raise CertificateError(\n            \"hostname %r \"\n            \"doesn't match either of %s\" % (hostname, \", \".join(map(repr, dnsnames)))\n        )\n    elif len(dnsnames) == 1:\n        raise CertificateError(\"hostname %r doesn't match %r\" % (hostname, dnsnames[0]))\n    else:\n        raise CertificateError(\n            \"no appropriate commonName or subjectAltName fields were found\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/ssl_match_hostname/_implementation.html","title":"_implementation","text":"<p>The match_hostname() function from Python 3.3.3, essential when using SSL.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/packages/ssl_match_hostname/_implementation.html#client.ayon_fusion.vendor.urllib3.packages.ssl_match_hostname._implementation.match_hostname","title":"<code>match_hostname(cert, hostname)</code>","text":"<p>Verify that cert (in decoded format as returned by SSLSocket.getpeercert()) matches the hostname.  RFC 2818 and RFC 6125 rules are followed, but IP addresses are not accepted for hostname.</p> <p>CertificateError is raised on failure. On success, the function returns nothing.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/packages/ssl_match_hostname/_implementation.py</code> <pre><code>def match_hostname(cert, hostname):\n    \"\"\"Verify that *cert* (in decoded format as returned by\n    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125\n    rules are followed, but IP addresses are not accepted for *hostname*.\n\n    CertificateError is raised on failure. On success, the function\n    returns nothing.\n    \"\"\"\n    if not cert:\n        raise ValueError(\n            \"empty or no certificate, match_hostname needs a \"\n            \"SSL socket or SSL context with either \"\n            \"CERT_OPTIONAL or CERT_REQUIRED\"\n        )\n    try:\n        # Divergence from upstream: ipaddress can't handle byte str\n        host_ip = ipaddress.ip_address(_to_unicode(hostname))\n    except ValueError:\n        # Not an IP address (common case)\n        host_ip = None\n    except UnicodeError:\n        # Divergence from upstream: Have to deal with ipaddress not taking\n        # byte strings.  addresses should be all ascii, so we consider it not\n        # an ipaddress in this case\n        host_ip = None\n    except AttributeError:\n        # Divergence from upstream: Make ipaddress library optional\n        if ipaddress is None:\n            host_ip = None\n        else:\n            raise\n    dnsnames = []\n    san = cert.get(\"subjectAltName\", ())\n    for key, value in san:\n        if key == \"DNS\":\n            if host_ip is None and _dnsname_match(value, hostname):\n                return\n            dnsnames.append(value)\n        elif key == \"IP Address\":\n            if host_ip is not None and _ipaddress_match(value, host_ip):\n                return\n            dnsnames.append(value)\n    if not dnsnames:\n        # The subject is only checked when there is no dNSName entry\n        # in subjectAltName\n        for sub in cert.get(\"subject\", ()):\n            for key, value in sub:\n                # XXX according to RFC 2818, the most specific Common Name\n                # must be used.\n                if key == \"commonName\":\n                    if _dnsname_match(value, hostname):\n                        return\n                    dnsnames.append(value)\n    if len(dnsnames) &gt; 1:\n        raise CertificateError(\n            \"hostname %r \"\n            \"doesn't match either of %s\" % (hostname, \", \".join(map(repr, dnsnames)))\n        )\n    elif len(dnsnames) == 1:\n        raise CertificateError(\"hostname %r doesn't match %r\" % (hostname, dnsnames[0]))\n    else:\n        raise CertificateError(\n            \"no appropriate commonName or subjectAltName fields were found\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html","title":"util","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Retry","title":"<code>Retry</code>","text":"<p>               Bases: <code>object</code></p> <p>Retry configuration.</p> <p>Each retry attempt will create a new Retry object with updated values, so they can be safely reused.</p> <p>Retries can be defined as a default for a pool::</p> <pre><code>retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n</code></pre> <p>Or per-request (which overrides the default for the pool)::</p> <pre><code>response = http.request('GET', 'http://example.com/', retries=Retry(10))\n</code></pre> <p>Retries can be disabled by passing <code>False</code>::</p> <pre><code>response = http.request('GET', 'http://example.com/', retries=False)\n</code></pre> <p>Errors will be wrapped in :class:<code>~urllib3.exceptions.MaxRetryError</code> unless retries are disabled, in which case the causing exception will be raised.</p> <p>:param int total:     Total number of retries to allow. Takes precedence over other counts.</p> <pre><code>Set to ``None`` to remove this constraint and fall back on other\ncounts.\n\nSet to ``0`` to fail on the first retry.\n\nSet to ``False`` to disable and imply ``raise_on_redirect=False``.\n</code></pre> <p>:param int connect:     How many connection-related errors to retry on.</p> <pre><code>These are errors raised before the request is sent to the remote server,\nwhich we assume has not triggered the server to process the request.\n\nSet to ``0`` to fail on the first retry of this type.\n</code></pre> <p>:param int read:     How many times to retry on read errors.</p> <pre><code>These errors are raised after the request was sent to the server, so the\nrequest may have side-effects.\n\nSet to ``0`` to fail on the first retry of this type.\n</code></pre> <p>:param int redirect:     How many redirects to perform. Limit this to avoid infinite redirect     loops.</p> <pre><code>A redirect is a HTTP response with a status code 301, 302, 303, 307 or\n308.\n\nSet to ``0`` to fail on the first retry of this type.\n\nSet to ``False`` to disable and imply ``raise_on_redirect=False``.\n</code></pre> <p>:param int status:     How many times to retry on bad status codes.</p> <pre><code>These are retries made on responses, where status code matches\n``status_forcelist``.\n\nSet to ``0`` to fail on the first retry of this type.\n</code></pre> <p>:param int other:     How many times to retry on other errors.</p> <pre><code>Other errors are errors that are not connect, read, redirect or status errors.\nThese errors might be raised after the request was sent to the server, so the\nrequest might have side-effects.\n\nSet to ``0`` to fail on the first retry of this type.\n\nIf ``total`` is not set, it's a good idea to set this to 0 to account\nfor unexpected edge cases and avoid infinite retry loops.\n</code></pre> <p>:param iterable allowed_methods:     Set of uppercased HTTP method verbs that we should retry on.</p> <pre><code>By default, we only retry on methods which are considered to be\nidempotent (multiple requests with the same parameters end with the\nsame state). See :attr:`Retry.DEFAULT_ALLOWED_METHODS`.\n\nSet to a ``False`` value to retry on any verb.\n\n.. warning::\n\n    Previously this parameter was named ``method_whitelist``, that\n    usage is deprecated in v1.26.0 and will be removed in v2.0.\n</code></pre> <p>:param iterable status_forcelist:     A set of integer HTTP status codes that we should force a retry on.     A retry is initiated if the request method is in <code>allowed_methods</code>     and the response status code is in <code>status_forcelist</code>.</p> <pre><code>By default, this is disabled with ``None``.\n</code></pre> <p>:param float backoff_factor:     A backoff factor to apply between attempts after the second try     (most errors are resolved immediately by a second try without a     delay). urllib3 will sleep for::</p> <pre><code>    {backoff factor} * (2 ** ({number of total retries} - 1))\n\nseconds. If the backoff_factor is 0.1, then :func:`.sleep` will sleep\nfor [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer\nthan :attr:`Retry.BACKOFF_MAX`.\n\nBy default, backoff is disabled (set to 0).\n</code></pre> <p>:param bool raise_on_redirect: Whether, if the number of redirects is     exhausted, to raise a MaxRetryError, or to return a response with a     response code in the 3xx range.</p> <p>:param bool raise_on_status: Similar meaning to <code>raise_on_redirect</code>:     whether we should raise an exception, or return a response,     if status falls in <code>status_forcelist</code> range and retries have     been exhausted.</p> <p>:param tuple history: The history of the request encountered during     each call to :meth:<code>~Retry.increment</code>. The list is in the order     the requests occurred. Each list item is of class :class:<code>RequestHistory</code>.</p> <p>:param bool respect_retry_after_header:     Whether to respect Retry-After header on status codes defined as     :attr:<code>Retry.RETRY_AFTER_STATUS_CODES</code> or not.</p> <p>:param iterable remove_headers_on_redirect:     Sequence of headers to remove from the request when a response     indicating a redirect is returned before firing off the redirected     request.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>@six.add_metaclass(_RetryMeta)\nclass Retry(object):\n    \"\"\"Retry configuration.\n\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.\n\n    Retries can be defined as a default for a pool::\n\n        retries = Retry(connect=5, read=2, redirect=5)\n        http = PoolManager(retries=retries)\n        response = http.request('GET', 'http://example.com/')\n\n    Or per-request (which overrides the default for the pool)::\n\n        response = http.request('GET', 'http://example.com/', retries=Retry(10))\n\n    Retries can be disabled by passing ``False``::\n\n        response = http.request('GET', 'http://example.com/', retries=False)\n\n    Errors will be wrapped in :class:`~urllib3.exceptions.MaxRetryError` unless\n    retries are disabled, in which case the causing exception will be raised.\n\n    :param int total:\n        Total number of retries to allow. Takes precedence over other counts.\n\n        Set to ``None`` to remove this constraint and fall back on other\n        counts.\n\n        Set to ``0`` to fail on the first retry.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int connect:\n        How many connection-related errors to retry on.\n\n        These are errors raised before the request is sent to the remote server,\n        which we assume has not triggered the server to process the request.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int read:\n        How many times to retry on read errors.\n\n        These errors are raised after the request was sent to the server, so the\n        request may have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int redirect:\n        How many redirects to perform. Limit this to avoid infinite redirect\n        loops.\n\n        A redirect is a HTTP response with a status code 301, 302, 303, 307 or\n        308.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int status:\n        How many times to retry on bad status codes.\n\n        These are retries made on responses, where status code matches\n        ``status_forcelist``.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int other:\n        How many times to retry on other errors.\n\n        Other errors are errors that are not connect, read, redirect or status errors.\n        These errors might be raised after the request was sent to the server, so the\n        request might have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        If ``total`` is not set, it's a good idea to set this to 0 to account\n        for unexpected edge cases and avoid infinite retry loops.\n\n    :param iterable allowed_methods:\n        Set of uppercased HTTP method verbs that we should retry on.\n\n        By default, we only retry on methods which are considered to be\n        idempotent (multiple requests with the same parameters end with the\n        same state). See :attr:`Retry.DEFAULT_ALLOWED_METHODS`.\n\n        Set to a ``False`` value to retry on any verb.\n\n        .. warning::\n\n            Previously this parameter was named ``method_whitelist``, that\n            usage is deprecated in v1.26.0 and will be removed in v2.0.\n\n    :param iterable status_forcelist:\n        A set of integer HTTP status codes that we should force a retry on.\n        A retry is initiated if the request method is in ``allowed_methods``\n        and the response status code is in ``status_forcelist``.\n\n        By default, this is disabled with ``None``.\n\n    :param float backoff_factor:\n        A backoff factor to apply between attempts after the second try\n        (most errors are resolved immediately by a second try without a\n        delay). urllib3 will sleep for::\n\n            {backoff factor} * (2 ** ({number of total retries} - 1))\n\n        seconds. If the backoff_factor is 0.1, then :func:`.sleep` will sleep\n        for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer\n        than :attr:`Retry.BACKOFF_MAX`.\n\n        By default, backoff is disabled (set to 0).\n\n    :param bool raise_on_redirect: Whether, if the number of redirects is\n        exhausted, to raise a MaxRetryError, or to return a response with a\n        response code in the 3xx range.\n\n    :param bool raise_on_status: Similar meaning to ``raise_on_redirect``:\n        whether we should raise an exception, or return a response,\n        if status falls in ``status_forcelist`` range and retries have\n        been exhausted.\n\n    :param tuple history: The history of the request encountered during\n        each call to :meth:`~Retry.increment`. The list is in the order\n        the requests occurred. Each list item is of class :class:`RequestHistory`.\n\n    :param bool respect_retry_after_header:\n        Whether to respect Retry-After header on status codes defined as\n        :attr:`Retry.RETRY_AFTER_STATUS_CODES` or not.\n\n    :param iterable remove_headers_on_redirect:\n        Sequence of headers to remove from the request when a response\n        indicating a redirect is returned before firing off the redirected\n        request.\n    \"\"\"\n\n    #: Default methods to be used for ``allowed_methods``\n    DEFAULT_ALLOWED_METHODS = frozenset(\n        [\"HEAD\", \"GET\", \"PUT\", \"DELETE\", \"OPTIONS\", \"TRACE\"]\n    )\n\n    #: Default status codes to be used for ``status_forcelist``\n    RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])\n\n    #: Default headers to be used for ``remove_headers_on_redirect``\n    DEFAULT_REMOVE_HEADERS_ON_REDIRECT = frozenset([\"Authorization\"])\n\n    #: Maximum backoff time.\n    BACKOFF_MAX = 120\n\n    def __init__(\n        self,\n        total=10,\n        connect=None,\n        read=None,\n        redirect=None,\n        status=None,\n        other=None,\n        allowed_methods=_Default,\n        status_forcelist=None,\n        backoff_factor=0,\n        raise_on_redirect=True,\n        raise_on_status=True,\n        history=None,\n        respect_retry_after_header=True,\n        remove_headers_on_redirect=_Default,\n        # TODO: Deprecated, remove in v2.0\n        method_whitelist=_Default,\n    ):\n\n        if method_whitelist is not _Default:\n            if allowed_methods is not _Default:\n                raise ValueError(\n                    \"Using both 'allowed_methods' and \"\n                    \"'method_whitelist' together is not allowed. \"\n                    \"Instead only use 'allowed_methods'\"\n                )\n            warnings.warn(\n                \"Using 'method_whitelist' with Retry is deprecated and \"\n                \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            allowed_methods = method_whitelist\n        if allowed_methods is _Default:\n            allowed_methods = self.DEFAULT_ALLOWED_METHODS\n        if remove_headers_on_redirect is _Default:\n            remove_headers_on_redirect = self.DEFAULT_REMOVE_HEADERS_ON_REDIRECT\n\n        self.total = total\n        self.connect = connect\n        self.read = read\n        self.status = status\n        self.other = other\n\n        if redirect is False or total is False:\n            redirect = 0\n            raise_on_redirect = False\n\n        self.redirect = redirect\n        self.status_forcelist = status_forcelist or set()\n        self.allowed_methods = allowed_methods\n        self.backoff_factor = backoff_factor\n        self.raise_on_redirect = raise_on_redirect\n        self.raise_on_status = raise_on_status\n        self.history = history or tuple()\n        self.respect_retry_after_header = respect_retry_after_header\n        self.remove_headers_on_redirect = frozenset(\n            [h.lower() for h in remove_headers_on_redirect]\n        )\n\n    def new(self, **kw):\n        params = dict(\n            total=self.total,\n            connect=self.connect,\n            read=self.read,\n            redirect=self.redirect,\n            status=self.status,\n            other=self.other,\n            status_forcelist=self.status_forcelist,\n            backoff_factor=self.backoff_factor,\n            raise_on_redirect=self.raise_on_redirect,\n            raise_on_status=self.raise_on_status,\n            history=self.history,\n            remove_headers_on_redirect=self.remove_headers_on_redirect,\n            respect_retry_after_header=self.respect_retry_after_header,\n        )\n\n        # TODO: If already given in **kw we use what's given to us\n        # If not given we need to figure out what to pass. We decide\n        # based on whether our class has the 'method_whitelist' property\n        # and if so we pass the deprecated 'method_whitelist' otherwise\n        # we use 'allowed_methods'. Remove in v2.0\n        if \"method_whitelist\" not in kw and \"allowed_methods\" not in kw:\n            if \"method_whitelist\" in self.__dict__:\n                warnings.warn(\n                    \"Using 'method_whitelist' with Retry is deprecated and \"\n                    \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                    DeprecationWarning,\n                )\n                params[\"method_whitelist\"] = self.allowed_methods\n            else:\n                params[\"allowed_methods\"] = self.allowed_methods\n\n        params.update(kw)\n        return type(self)(**params)\n\n    @classmethod\n    def from_int(cls, retries, redirect=True, default=None):\n        \"\"\"Backwards-compatibility for the old retries format.\"\"\"\n        if retries is None:\n            retries = default if default is not None else cls.DEFAULT\n\n        if isinstance(retries, Retry):\n            return retries\n\n        redirect = bool(redirect) and None\n        new_retries = cls(retries, redirect=redirect)\n        log.debug(\"Converted retries value: %r -&gt; %r\", retries, new_retries)\n        return new_retries\n\n    def get_backoff_time(self):\n        \"\"\"Formula for computing the current backoff\n\n        :rtype: float\n        \"\"\"\n        # We want to consider only the last consecutive errors sequence (Ignore redirects).\n        consecutive_errors_len = len(\n            list(\n                takewhile(lambda x: x.redirect_location is None, reversed(self.history))\n            )\n        )\n        if consecutive_errors_len &lt;= 1:\n            return 0\n\n        backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))\n        return min(self.BACKOFF_MAX, backoff_value)\n\n    def parse_retry_after(self, retry_after):\n        # Whitespace: https://tools.ietf.org/html/rfc7230#section-3.2.4\n        if re.match(r\"^\\s*[0-9]+\\s*$\", retry_after):\n            seconds = int(retry_after)\n        else:\n            retry_date_tuple = email.utils.parsedate_tz(retry_after)\n            if retry_date_tuple is None:\n                raise InvalidHeader(\"Invalid Retry-After header: %s\" % retry_after)\n            if retry_date_tuple[9] is None:  # Python 2\n                # Assume UTC if no timezone was specified\n                # On Python2.7, parsedate_tz returns None for a timezone offset\n                # instead of 0 if no timezone is given, where mktime_tz treats\n                # a None timezone offset as local time.\n                retry_date_tuple = retry_date_tuple[:9] + (0,) + retry_date_tuple[10:]\n\n            retry_date = email.utils.mktime_tz(retry_date_tuple)\n            seconds = retry_date - time.time()\n\n        if seconds &lt; 0:\n            seconds = 0\n\n        return seconds\n\n    def get_retry_after(self, response):\n        \"\"\"Get the value of Retry-After in seconds.\"\"\"\n\n        retry_after = response.getheader(\"Retry-After\")\n\n        if retry_after is None:\n            return None\n\n        return self.parse_retry_after(retry_after)\n\n    def sleep_for_retry(self, response=None):\n        retry_after = self.get_retry_after(response)\n        if retry_after:\n            time.sleep(retry_after)\n            return True\n\n        return False\n\n    def _sleep_backoff(self):\n        backoff = self.get_backoff_time()\n        if backoff &lt;= 0:\n            return\n        time.sleep(backoff)\n\n    def sleep(self, response=None):\n        \"\"\"Sleep between retry attempts.\n\n        This method will respect a server's ``Retry-After`` response header\n        and sleep the duration of the time requested. If that is not present, it\n        will use an exponential backoff. By default, the backoff factor is 0 and\n        this method will return immediately.\n        \"\"\"\n\n        if self.respect_retry_after_header and response:\n            slept = self.sleep_for_retry(response)\n            if slept:\n                return\n\n        self._sleep_backoff()\n\n    def _is_connection_error(self, err):\n        \"\"\"Errors when we're fairly sure that the server did not receive the\n        request, so it should be safe to retry.\n        \"\"\"\n        if isinstance(err, ProxyError):\n            err = err.original_error\n        return isinstance(err, ConnectTimeoutError)\n\n    def _is_read_error(self, err):\n        \"\"\"Errors that occur after the request has been started, so we should\n        assume that the server began processing it.\n        \"\"\"\n        return isinstance(err, (ReadTimeoutError, ProtocolError))\n\n    def _is_method_retryable(self, method):\n        \"\"\"Checks if a given HTTP method should be retried upon, depending if\n        it is included in the allowed_methods\n        \"\"\"\n        # TODO: For now favor if the Retry implementation sets its own method_whitelist\n        # property outside of our constructor to avoid breaking custom implementations.\n        if \"method_whitelist\" in self.__dict__:\n            warnings.warn(\n                \"Using 'method_whitelist' with Retry is deprecated and \"\n                \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                DeprecationWarning,\n            )\n            allowed_methods = self.method_whitelist\n        else:\n            allowed_methods = self.allowed_methods\n\n        if allowed_methods and method.upper() not in allowed_methods:\n            return False\n        return True\n\n    def is_retry(self, method, status_code, has_retry_after=False):\n        \"\"\"Is this method/status code retryable? (Based on allowlists and control\n        variables such as the number of total retries to allow, whether to\n        respect the Retry-After header, whether this header is present, and\n        whether the returned status code is on the list of status codes to\n        be retried upon on the presence of the aforementioned header)\n        \"\"\"\n        if not self._is_method_retryable(method):\n            return False\n\n        if self.status_forcelist and status_code in self.status_forcelist:\n            return True\n\n        return (\n            self.total\n            and self.respect_retry_after_header\n            and has_retry_after\n            and (status_code in self.RETRY_AFTER_STATUS_CODES)\n        )\n\n    def is_exhausted(self):\n        \"\"\"Are we out of retries?\"\"\"\n        retry_counts = (\n            self.total,\n            self.connect,\n            self.read,\n            self.redirect,\n            self.status,\n            self.other,\n        )\n        retry_counts = list(filter(None, retry_counts))\n        if not retry_counts:\n            return False\n\n        return min(retry_counts) &lt; 0\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n\n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n\n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n\n        total = self.total\n        if total is not None:\n            total -= 1\n\n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n\n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n\n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n\n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n\n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n\n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n\n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n\n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n\n        if new_retry.is_exhausted():\n            raise MaxRetryError(_pool, url, error or ResponseError(cause))\n\n        log.debug(\"Incremented Retry for (url='%s'): %r\", url, new_retry)\n\n        return new_retry\n\n    def __repr__(self):\n        return (\n            \"{cls.__name__}(total={self.total}, connect={self.connect}, \"\n            \"read={self.read}, redirect={self.redirect}, status={self.status})\"\n        ).format(cls=type(self), self=self)\n\n    def __getattr__(self, item):\n        if item == \"method_whitelist\":\n            # TODO: Remove this deprecated alias in v2.0\n            warnings.warn(\n                \"Using 'method_whitelist' with Retry is deprecated and \"\n                \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                DeprecationWarning,\n            )\n            return self.allowed_methods\n        try:\n            return getattr(super(Retry, self), item)\n        except AttributeError:\n            return getattr(Retry, item)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Retry.from_int","title":"<code>from_int(retries, redirect=True, default=None)</code>  <code>classmethod</code>","text":"<p>Backwards-compatibility for the old retries format.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>@classmethod\ndef from_int(cls, retries, redirect=True, default=None):\n    \"\"\"Backwards-compatibility for the old retries format.\"\"\"\n    if retries is None:\n        retries = default if default is not None else cls.DEFAULT\n\n    if isinstance(retries, Retry):\n        return retries\n\n    redirect = bool(redirect) and None\n    new_retries = cls(retries, redirect=redirect)\n    log.debug(\"Converted retries value: %r -&gt; %r\", retries, new_retries)\n    return new_retries\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Retry.get_backoff_time","title":"<code>get_backoff_time()</code>","text":"<p>Formula for computing the current backoff</p> <p>:rtype: float</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def get_backoff_time(self):\n    \"\"\"Formula for computing the current backoff\n\n    :rtype: float\n    \"\"\"\n    # We want to consider only the last consecutive errors sequence (Ignore redirects).\n    consecutive_errors_len = len(\n        list(\n            takewhile(lambda x: x.redirect_location is None, reversed(self.history))\n        )\n    )\n    if consecutive_errors_len &lt;= 1:\n        return 0\n\n    backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))\n    return min(self.BACKOFF_MAX, backoff_value)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Retry.get_retry_after","title":"<code>get_retry_after(response)</code>","text":"<p>Get the value of Retry-After in seconds.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def get_retry_after(self, response):\n    \"\"\"Get the value of Retry-After in seconds.\"\"\"\n\n    retry_after = response.getheader(\"Retry-After\")\n\n    if retry_after is None:\n        return None\n\n    return self.parse_retry_after(retry_after)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Retry.increment","title":"<code>increment(method=None, url=None, response=None, error=None, _pool=None, _stacktrace=None)</code>","text":"<p>Return a new Retry object with incremented retry counters.</p> <p>:param response: A response object, or None, if the server did not     return a response. :type response: :class:<code>~urllib3.response.HTTPResponse</code> :param Exception error: An error encountered during the request, or     None if the response was received successfully.</p> <p>:return: A new <code>Retry</code> object.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def increment(\n    self,\n    method=None,\n    url=None,\n    response=None,\n    error=None,\n    _pool=None,\n    _stacktrace=None,\n):\n    \"\"\"Return a new Retry object with incremented retry counters.\n\n    :param response: A response object, or None, if the server did not\n        return a response.\n    :type response: :class:`~urllib3.response.HTTPResponse`\n    :param Exception error: An error encountered during the request, or\n        None if the response was received successfully.\n\n    :return: A new ``Retry`` object.\n    \"\"\"\n    if self.total is False and error:\n        # Disabled, indicate to re-raise the error.\n        raise six.reraise(type(error), error, _stacktrace)\n\n    total = self.total\n    if total is not None:\n        total -= 1\n\n    connect = self.connect\n    read = self.read\n    redirect = self.redirect\n    status_count = self.status\n    other = self.other\n    cause = \"unknown\"\n    status = None\n    redirect_location = None\n\n    if error and self._is_connection_error(error):\n        # Connect retry?\n        if connect is False:\n            raise six.reraise(type(error), error, _stacktrace)\n        elif connect is not None:\n            connect -= 1\n\n    elif error and self._is_read_error(error):\n        # Read retry?\n        if read is False or not self._is_method_retryable(method):\n            raise six.reraise(type(error), error, _stacktrace)\n        elif read is not None:\n            read -= 1\n\n    elif error:\n        # Other retry?\n        if other is not None:\n            other -= 1\n\n    elif response and response.get_redirect_location():\n        # Redirect retry?\n        if redirect is not None:\n            redirect -= 1\n        cause = \"too many redirects\"\n        redirect_location = response.get_redirect_location()\n        status = response.status\n\n    else:\n        # Incrementing because of a server error like a 500 in\n        # status_forcelist and the given method is in the allowed_methods\n        cause = ResponseError.GENERIC_ERROR\n        if response and response.status:\n            if status_count is not None:\n                status_count -= 1\n            cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n            status = response.status\n\n    history = self.history + (\n        RequestHistory(method, url, error, status, redirect_location),\n    )\n\n    new_retry = self.new(\n        total=total,\n        connect=connect,\n        read=read,\n        redirect=redirect,\n        status=status_count,\n        other=other,\n        history=history,\n    )\n\n    if new_retry.is_exhausted():\n        raise MaxRetryError(_pool, url, error or ResponseError(cause))\n\n    log.debug(\"Incremented Retry for (url='%s'): %r\", url, new_retry)\n\n    return new_retry\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Retry.is_exhausted","title":"<code>is_exhausted()</code>","text":"<p>Are we out of retries?</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def is_exhausted(self):\n    \"\"\"Are we out of retries?\"\"\"\n    retry_counts = (\n        self.total,\n        self.connect,\n        self.read,\n        self.redirect,\n        self.status,\n        self.other,\n    )\n    retry_counts = list(filter(None, retry_counts))\n    if not retry_counts:\n        return False\n\n    return min(retry_counts) &lt; 0\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Retry.is_retry","title":"<code>is_retry(method, status_code, has_retry_after=False)</code>","text":"<p>Is this method/status code retryable? (Based on allowlists and control variables such as the number of total retries to allow, whether to respect the Retry-After header, whether this header is present, and whether the returned status code is on the list of status codes to be retried upon on the presence of the aforementioned header)</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def is_retry(self, method, status_code, has_retry_after=False):\n    \"\"\"Is this method/status code retryable? (Based on allowlists and control\n    variables such as the number of total retries to allow, whether to\n    respect the Retry-After header, whether this header is present, and\n    whether the returned status code is on the list of status codes to\n    be retried upon on the presence of the aforementioned header)\n    \"\"\"\n    if not self._is_method_retryable(method):\n        return False\n\n    if self.status_forcelist and status_code in self.status_forcelist:\n        return True\n\n    return (\n        self.total\n        and self.respect_retry_after_header\n        and has_retry_after\n        and (status_code in self.RETRY_AFTER_STATUS_CODES)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Retry.sleep","title":"<code>sleep(response=None)</code>","text":"<p>Sleep between retry attempts.</p> <p>This method will respect a server's <code>Retry-After</code> response header and sleep the duration of the time requested. If that is not present, it will use an exponential backoff. By default, the backoff factor is 0 and this method will return immediately.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def sleep(self, response=None):\n    \"\"\"Sleep between retry attempts.\n\n    This method will respect a server's ``Retry-After`` response header\n    and sleep the duration of the time requested. If that is not present, it\n    will use an exponential backoff. By default, the backoff factor is 0 and\n    this method will return immediately.\n    \"\"\"\n\n    if self.respect_retry_after_header and response:\n        slept = self.sleep_for_retry(response)\n        if slept:\n            return\n\n    self._sleep_backoff()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Timeout","title":"<code>Timeout</code>","text":"<p>               Bases: <code>object</code></p> <p>Timeout configuration.</p> <p>Timeouts can be defined as a default for a pool:</p> <p>.. code-block:: python</p> <p>timeout = Timeout(connect=2.0, read=7.0)    http = PoolManager(timeout=timeout)    response = http.request('GET', 'http://example.com/')</p> <p>Or per-request (which overrides the default for the pool):</p> <p>.. code-block:: python</p> <p>response = http.request('GET', 'http://example.com/', timeout=Timeout(10))</p> <p>Timeouts can be disabled by setting all the parameters to <code>None</code>:</p> <p>.. code-block:: python</p> <p>no_timeout = Timeout(connect=None, read=None)    response = http.request('GET', 'http://example.com/, timeout=no_timeout)</p> <p>:param total:     This combines the connect and read timeouts into one; the read timeout     will be set to the time leftover from the connect attempt. In the     event that both a connect timeout and a total are specified, or a read     timeout and a total are specified, the shorter timeout will be applied.</p> <pre><code>Defaults to None.\n</code></pre> <p>:type total: int, float, or None</p> <p>:param connect:     The maximum amount of time (in seconds) to wait for a connection     attempt to a server to succeed. Omitting the parameter will default the     connect timeout to the system default, probably <code>the global default     timeout in socket.py     &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;</code>_.     None will set an infinite timeout for connection attempts.</p> <p>:type connect: int, float, or None</p> <p>:param read:     The maximum amount of time (in seconds) to wait between consecutive     read operations for a response from the server. Omitting the parameter     will default the read timeout to the system default, probably <code>the     global default timeout in socket.py     &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;</code>_.     None will set an infinite timeout.</p> <p>:type read: int, float, or None</p> <p>.. note::</p> <pre><code>Many factors can affect the total amount of time for urllib3 to return\nan HTTP response.\n\nFor example, Python's DNS resolver does not obey the timeout specified\non the socket. Other factors that can affect total request time include\nhigh CPU load, high swap, the program running at a low priority level,\nor other behaviors.\n\nIn addition, the read and total timeouts only measure the time between\nread operations on the socket connecting the client and the server,\nnot the total amount of time for the request to return a complete\nresponse. For most requests, the timeout is raised because the server\nhas not sent the first byte in the specified time. This is not always\nthe case; if a server streams one byte every fifteen seconds, a timeout\nof 20 seconds will not trigger, even though the request will take\nseveral minutes to complete.\n\nIf your goal is to cut off any request after a set amount of wall clock\ntime, consider having a second \"watcher\" thread to cut off a slow\nrequest.\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>class Timeout(object):\n    \"\"\"Timeout configuration.\n\n    Timeouts can be defined as a default for a pool:\n\n    .. code-block:: python\n\n       timeout = Timeout(connect=2.0, read=7.0)\n       http = PoolManager(timeout=timeout)\n       response = http.request('GET', 'http://example.com/')\n\n    Or per-request (which overrides the default for the pool):\n\n    .. code-block:: python\n\n       response = http.request('GET', 'http://example.com/', timeout=Timeout(10))\n\n    Timeouts can be disabled by setting all the parameters to ``None``:\n\n    .. code-block:: python\n\n       no_timeout = Timeout(connect=None, read=None)\n       response = http.request('GET', 'http://example.com/, timeout=no_timeout)\n\n\n    :param total:\n        This combines the connect and read timeouts into one; the read timeout\n        will be set to the time leftover from the connect attempt. In the\n        event that both a connect timeout and a total are specified, or a read\n        timeout and a total are specified, the shorter timeout will be applied.\n\n        Defaults to None.\n\n    :type total: int, float, or None\n\n    :param connect:\n        The maximum amount of time (in seconds) to wait for a connection\n        attempt to a server to succeed. Omitting the parameter will default the\n        connect timeout to the system default, probably `the global default\n        timeout in socket.py\n        &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;`_.\n        None will set an infinite timeout for connection attempts.\n\n    :type connect: int, float, or None\n\n    :param read:\n        The maximum amount of time (in seconds) to wait between consecutive\n        read operations for a response from the server. Omitting the parameter\n        will default the read timeout to the system default, probably `the\n        global default timeout in socket.py\n        &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;`_.\n        None will set an infinite timeout.\n\n    :type read: int, float, or None\n\n    .. note::\n\n        Many factors can affect the total amount of time for urllib3 to return\n        an HTTP response.\n\n        For example, Python's DNS resolver does not obey the timeout specified\n        on the socket. Other factors that can affect total request time include\n        high CPU load, high swap, the program running at a low priority level,\n        or other behaviors.\n\n        In addition, the read and total timeouts only measure the time between\n        read operations on the socket connecting the client and the server,\n        not the total amount of time for the request to return a complete\n        response. For most requests, the timeout is raised because the server\n        has not sent the first byte in the specified time. This is not always\n        the case; if a server streams one byte every fifteen seconds, a timeout\n        of 20 seconds will not trigger, even though the request will take\n        several minutes to complete.\n\n        If your goal is to cut off any request after a set amount of wall clock\n        time, consider having a second \"watcher\" thread to cut off a slow\n        request.\n    \"\"\"\n\n    #: A sentinel object representing the default timeout value\n    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT\n\n    def __init__(self, total=None, connect=_Default, read=_Default):\n        self._connect = self._validate_timeout(connect, \"connect\")\n        self._read = self._validate_timeout(read, \"read\")\n        self.total = self._validate_timeout(total, \"total\")\n        self._start_connect = None\n\n    def __repr__(self):\n        return \"%s(connect=%r, read=%r, total=%r)\" % (\n            type(self).__name__,\n            self._connect,\n            self._read,\n            self.total,\n        )\n\n    # __str__ provided for backwards compatibility\n    __str__ = __repr__\n\n    @classmethod\n    def _validate_timeout(cls, value, name):\n        \"\"\"Check that a timeout attribute is valid.\n\n        :param value: The timeout value to validate\n        :param name: The name of the timeout attribute to validate. This is\n            used to specify in error messages.\n        :return: The validated and casted version of the given value.\n        :raises ValueError: If it is a numeric value less than or equal to\n            zero, or the type is not an integer, float, or None.\n        \"\"\"\n        if value is _Default:\n            return cls.DEFAULT_TIMEOUT\n\n        if value is None or value is cls.DEFAULT_TIMEOUT:\n            return value\n\n        if isinstance(value, bool):\n            raise ValueError(\n                \"Timeout cannot be a boolean value. It must \"\n                \"be an int, float or None.\"\n            )\n        try:\n            float(value)\n        except (TypeError, ValueError):\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            )\n\n        try:\n            if value &lt;= 0:\n                raise ValueError(\n                    \"Attempted to set %s timeout to %s, but the \"\n                    \"timeout cannot be set to a value less \"\n                    \"than or equal to 0.\" % (name, value)\n                )\n        except TypeError:\n            # Python 3\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            )\n\n        return value\n\n    @classmethod\n    def from_float(cls, timeout):\n        \"\"\"Create a new Timeout from a legacy timeout value.\n\n        The timeout value used by httplib.py sets the same timeout on the\n        connect(), and recv() socket requests. This creates a :class:`Timeout`\n        object that sets the individual timeouts to the ``timeout`` value\n        passed to this function.\n\n        :param timeout: The legacy timeout value.\n        :type timeout: integer, float, sentinel default object, or None\n        :return: Timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        return Timeout(read=timeout, connect=timeout)\n\n    def clone(self):\n        \"\"\"Create a copy of the timeout object\n\n        Timeout properties are stored per-pool but each request needs a fresh\n        Timeout object to ensure each one has its own start/stop configured.\n\n        :return: a copy of the timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        # We can't use copy.deepcopy because that will also create a new object\n        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to\n        # detect the user default.\n        return Timeout(connect=self._connect, read=self._read, total=self.total)\n\n    def start_connect(self):\n        \"\"\"Start the timeout clock, used during a connect() attempt\n\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to start a timer that has been started already.\n        \"\"\"\n        if self._start_connect is not None:\n            raise TimeoutStateError(\"Timeout timer has already been started.\")\n        self._start_connect = current_time()\n        return self._start_connect\n\n    def get_connect_duration(self):\n        \"\"\"Gets the time elapsed since the call to :meth:`start_connect`.\n\n        :return: Elapsed time in seconds.\n        :rtype: float\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to get duration for a timer that hasn't been started.\n        \"\"\"\n        if self._start_connect is None:\n            raise TimeoutStateError(\n                \"Can't get connect duration for timer that has not started.\"\n            )\n        return current_time() - self._start_connect\n\n    @property\n    def connect_timeout(self):\n        \"\"\"Get the value to use when setting a connection timeout.\n\n        This will be a positive float or integer, the value None\n        (never timeout), or the default system timeout.\n\n        :return: Connect timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        \"\"\"\n        if self.total is None:\n            return self._connect\n\n        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:\n            return self.total\n\n        return min(self._connect, self.total)\n\n    @property\n    def read_timeout(self):\n        \"\"\"Get the value for the read timeout.\n\n        This assumes some time has elapsed in the connection timeout and\n        computes the read timeout appropriately.\n\n        If self.total is set, the read timeout is dependent on the amount of\n        time taken by the connect timeout. If the connection time has not been\n        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be\n        raised.\n\n        :return: Value to use for the read timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`\n            has not yet been called on this object.\n        \"\"\"\n        if (\n            self.total is not None\n            and self.total is not self.DEFAULT_TIMEOUT\n            and self._read is not None\n            and self._read is not self.DEFAULT_TIMEOUT\n        ):\n            # In case the connect timeout has not yet been established.\n            if self._start_connect is None:\n                return self._read\n            return max(0, min(self.total - self.get_connect_duration(), self._read))\n        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:\n            return max(0, self.total - self.get_connect_duration())\n        else:\n            return self._read\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Timeout.connect_timeout","title":"<code>connect_timeout</code>  <code>property</code>","text":"<p>Get the value to use when setting a connection timeout.</p> <p>This will be a positive float or integer, the value None (never timeout), or the default system timeout.</p> <p>:return: Connect timeout. :rtype: int, float, :attr:<code>Timeout.DEFAULT_TIMEOUT</code> or None</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Timeout.read_timeout","title":"<code>read_timeout</code>  <code>property</code>","text":"<p>Get the value for the read timeout.</p> <p>This assumes some time has elapsed in the connection timeout and computes the read timeout appropriately.</p> <p>If self.total is set, the read timeout is dependent on the amount of time taken by the connect timeout. If the connection time has not been established, a :exc:<code>~urllib3.exceptions.TimeoutStateError</code> will be raised.</p> <p>:return: Value to use for the read timeout. :rtype: int, float, :attr:<code>Timeout.DEFAULT_TIMEOUT</code> or None :raises urllib3.exceptions.TimeoutStateError: If :meth:<code>start_connect</code>     has not yet been called on this object.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Timeout.clone","title":"<code>clone()</code>","text":"<p>Create a copy of the timeout object</p> <p>Timeout properties are stored per-pool but each request needs a fresh Timeout object to ensure each one has its own start/stop configured.</p> <p>:return: a copy of the timeout object :rtype: :class:<code>Timeout</code></p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>def clone(self):\n    \"\"\"Create a copy of the timeout object\n\n    Timeout properties are stored per-pool but each request needs a fresh\n    Timeout object to ensure each one has its own start/stop configured.\n\n    :return: a copy of the timeout object\n    :rtype: :class:`Timeout`\n    \"\"\"\n    # We can't use copy.deepcopy because that will also create a new object\n    # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to\n    # detect the user default.\n    return Timeout(connect=self._connect, read=self._read, total=self.total)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Timeout.from_float","title":"<code>from_float(timeout)</code>  <code>classmethod</code>","text":"<p>Create a new Timeout from a legacy timeout value.</p> <p>The timeout value used by httplib.py sets the same timeout on the connect(), and recv() socket requests. This creates a :class:<code>Timeout</code> object that sets the individual timeouts to the <code>timeout</code> value passed to this function.</p> <p>:param timeout: The legacy timeout value. :type timeout: integer, float, sentinel default object, or None :return: Timeout object :rtype: :class:<code>Timeout</code></p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>@classmethod\ndef from_float(cls, timeout):\n    \"\"\"Create a new Timeout from a legacy timeout value.\n\n    The timeout value used by httplib.py sets the same timeout on the\n    connect(), and recv() socket requests. This creates a :class:`Timeout`\n    object that sets the individual timeouts to the ``timeout`` value\n    passed to this function.\n\n    :param timeout: The legacy timeout value.\n    :type timeout: integer, float, sentinel default object, or None\n    :return: Timeout object\n    :rtype: :class:`Timeout`\n    \"\"\"\n    return Timeout(read=timeout, connect=timeout)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Timeout.get_connect_duration","title":"<code>get_connect_duration()</code>","text":"<p>Gets the time elapsed since the call to :meth:<code>start_connect</code>.</p> <p>:return: Elapsed time in seconds. :rtype: float :raises urllib3.exceptions.TimeoutStateError: if you attempt     to get duration for a timer that hasn't been started.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>def get_connect_duration(self):\n    \"\"\"Gets the time elapsed since the call to :meth:`start_connect`.\n\n    :return: Elapsed time in seconds.\n    :rtype: float\n    :raises urllib3.exceptions.TimeoutStateError: if you attempt\n        to get duration for a timer that hasn't been started.\n    \"\"\"\n    if self._start_connect is None:\n        raise TimeoutStateError(\n            \"Can't get connect duration for timer that has not started.\"\n        )\n    return current_time() - self._start_connect\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Timeout.start_connect","title":"<code>start_connect()</code>","text":"<p>Start the timeout clock, used during a connect() attempt</p> <p>:raises urllib3.exceptions.TimeoutStateError: if you attempt     to start a timer that has been started already.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>def start_connect(self):\n    \"\"\"Start the timeout clock, used during a connect() attempt\n\n    :raises urllib3.exceptions.TimeoutStateError: if you attempt\n        to start a timer that has been started already.\n    \"\"\"\n    if self._start_connect is not None:\n        raise TimeoutStateError(\"Timeout timer has already been started.\")\n    self._start_connect = current_time()\n    return self._start_connect\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Url","title":"<code>Url</code>","text":"<p>               Bases: <code>namedtuple('Url', url_attrs)</code></p> <p>Data structure for representing an HTTP URL. Used as a return value for :func:<code>parse_url</code>. Both the scheme and host are normalized as they are both case-insensitive according to RFC 3986.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/url.py</code> <pre><code>class Url(namedtuple(\"Url\", url_attrs)):\n    \"\"\"\n    Data structure for representing an HTTP URL. Used as a return value for\n    :func:`parse_url`. Both the scheme and host are normalized as they are\n    both case-insensitive according to RFC 3986.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __new__(\n        cls,\n        scheme=None,\n        auth=None,\n        host=None,\n        port=None,\n        path=None,\n        query=None,\n        fragment=None,\n    ):\n        if path and not path.startswith(\"/\"):\n            path = \"/\" + path\n        if scheme is not None:\n            scheme = scheme.lower()\n        return super(Url, cls).__new__(\n            cls, scheme, auth, host, port, path, query, fragment\n        )\n\n    @property\n    def hostname(self):\n        \"\"\"For backwards-compatibility with urlparse. We're nice like that.\"\"\"\n        return self.host\n\n    @property\n    def request_uri(self):\n        \"\"\"Absolute path including the query string.\"\"\"\n        uri = self.path or \"/\"\n\n        if self.query is not None:\n            uri += \"?\" + self.query\n\n        return uri\n\n    @property\n    def netloc(self):\n        \"\"\"Network location including host and port\"\"\"\n        if self.port:\n            return \"%s:%d\" % (self.host, self.port)\n        return self.host\n\n    @property\n    def url(self):\n        \"\"\"\n        Convert self into a url\n\n        This function should more or less round-trip with :func:`.parse_url`. The\n        returned url may not be exactly the same as the url inputted to\n        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls\n        with a blank port will have : removed).\n\n        Example: ::\n\n            &gt;&gt;&gt; U = parse_url('http://google.com/mail/')\n            &gt;&gt;&gt; U.url\n            'http://google.com/mail/'\n            &gt;&gt;&gt; Url('http', 'username:password', 'host.com', 80,\n            ... '/path', 'query', 'fragment').url\n            'http://username:password@host.com:80/path?query#fragment'\n        \"\"\"\n        scheme, auth, host, port, path, query, fragment = self\n        url = u\"\"\n\n        # We use \"is not None\" we want things to happen with empty strings (or 0 port)\n        if scheme is not None:\n            url += scheme + u\"://\"\n        if auth is not None:\n            url += auth + u\"@\"\n        if host is not None:\n            url += host\n        if port is not None:\n            url += u\":\" + str(port)\n        if path is not None:\n            url += path\n        if query is not None:\n            url += u\"?\" + query\n        if fragment is not None:\n            url += u\"#\" + fragment\n\n        return url\n\n    def __str__(self):\n        return self.url\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Url.hostname","title":"<code>hostname</code>  <code>property</code>","text":"<p>For backwards-compatibility with urlparse. We're nice like that.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Url.netloc","title":"<code>netloc</code>  <code>property</code>","text":"<p>Network location including host and port</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Url.request_uri","title":"<code>request_uri</code>  <code>property</code>","text":"<p>Absolute path including the query string.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.Url.url","title":"<code>url</code>  <code>property</code>","text":"<p>Convert self into a url</p> <p>This function should more or less round-trip with :func:<code>.parse_url</code>. The returned url may not be exactly the same as the url inputted to :func:<code>.parse_url</code>, but it should be equivalent by the RFC (e.g., urls with a blank port will have : removed).</p> <p>Example: ::</p> <pre><code>&gt;&gt;&gt; U = parse_url('http://google.com/mail/')\n&gt;&gt;&gt; U.url\n'http://google.com/mail/'\n&gt;&gt;&gt; Url('http', 'username:password', 'host.com', 80,\n... '/path', 'query', 'fragment').url\n'http://username:password@host.com:80/path?query#fragment'\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.assert_fingerprint","title":"<code>assert_fingerprint(cert, fingerprint)</code>","text":"<p>Checks if given fingerprint matches the supplied certificate.</p> <p>:param cert:     Certificate as bytes object. :param fingerprint:     Fingerprint as string of hexdigits, can be interspersed by colons.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def assert_fingerprint(cert, fingerprint):\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n\n    fingerprint = fingerprint.replace(\":\", \"\").lower()\n    digest_length = len(fingerprint)\n    hashfunc = HASHFUNC_MAP.get(digest_length)\n    if not hashfunc:\n        raise SSLError(\"Fingerprint of invalid length: {0}\".format(fingerprint))\n\n    # We need encode() here for py32; works on py2 and p33.\n    fingerprint_bytes = unhexlify(fingerprint.encode())\n\n    cert_digest = hashfunc(cert).digest()\n\n    if not _const_compare_digest(cert_digest, fingerprint_bytes):\n        raise SSLError(\n            'Fingerprints did not match. Expected \"{0}\", got \"{1}\".'.format(\n                fingerprint, hexlify(cert_digest)\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.get_host","title":"<code>get_host(url)</code>","text":"<p>Deprecated. Use :func:<code>parse_url</code> instead.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/url.py</code> <pre><code>def get_host(url):\n    \"\"\"\n    Deprecated. Use :func:`parse_url` instead.\n    \"\"\"\n    p = parse_url(url)\n    return p.scheme or \"http\", p.hostname, p.port\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.is_connection_dropped","title":"<code>is_connection_dropped(conn)</code>","text":"<p>Returns True if the connection is dropped and should be closed.</p> <p>:param conn:     :class:<code>http.client.HTTPConnection</code> object.</p> <p>Note: For platforms like AppEngine, this will always return <code>False</code> to let the platform handle connection recycling transparently for us.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/connection.py</code> <pre><code>def is_connection_dropped(conn):  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n\n    :param conn:\n        :class:`http.client.HTTPConnection` object.\n\n    Note: For platforms like AppEngine, this will always return ``False`` to\n    let the platform handle connection recycling transparently for us.\n    \"\"\"\n    sock = getattr(conn, \"sock\", False)\n    if sock is False:  # Platform-specific: AppEngine\n        return False\n    if sock is None:  # Connection already closed (such as by httplib).\n        return True\n    try:\n        # Returns True if readable, which here means it's been dropped\n        return wait_for_read(sock, timeout=0.0)\n    except NoWayToWaitForSocketError:  # Platform-specific: AppEngine\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.is_fp_closed","title":"<code>is_fp_closed(obj)</code>","text":"<p>Checks whether a given file-like object is closed.</p> <p>:param obj:     The file-like object to check.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/response.py</code> <pre><code>def is_fp_closed(obj):\n    \"\"\"\n    Checks whether a given file-like object is closed.\n\n    :param obj:\n        The file-like object to check.\n    \"\"\"\n\n    try:\n        # Check `isclosed()` first, in case Python3 doesn't set `closed`.\n        # GH Issue #928\n        return obj.isclosed()\n    except AttributeError:\n        pass\n\n    try:\n        # Check via the official file-like-object way.\n        return obj.closed\n    except AttributeError:\n        pass\n\n    try:\n        # Check if the object is a container for another file-like object that\n        # gets released on exhaustion (e.g. HTTPResponse).\n        return obj.fp is None\n    except AttributeError:\n        pass\n\n    raise ValueError(\"Unable to determine whether fp is closed.\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.make_headers","title":"<code>make_headers(keep_alive=None, accept_encoding=None, user_agent=None, basic_auth=None, proxy_basic_auth=None, disable_cache=None)</code>","text":"<p>Shortcuts for generating request headers.</p> <p>:param keep_alive:     If <code>True</code>, adds 'connection: keep-alive' header.</p> <p>:param accept_encoding:     Can be a boolean, list, or string.     <code>True</code> translates to 'gzip,deflate'.     List will get joined by comma.     String will be used as provided.</p> <p>:param user_agent:     String representing the user-agent you want, such as     \"python-urllib3/0.6\"</p> <p>:param basic_auth:     Colon-separated username:password string for 'authorization: basic ...'     auth header.</p> <p>:param proxy_basic_auth:     Colon-separated username:password string for 'proxy-authorization: basic ...'     auth header.</p> <p>:param disable_cache:     If <code>True</code>, adds 'cache-control: no-cache' header.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; make_headers(keep_alive=True, user_agent=\"Batman/1.0\")\n{'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n&gt;&gt;&gt; make_headers(accept_encoding=True)\n{'accept-encoding': 'gzip,deflate'}\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/util/request.py</code> <pre><code>def make_headers(\n    keep_alive=None,\n    accept_encoding=None,\n    user_agent=None,\n    basic_auth=None,\n    proxy_basic_auth=None,\n    disable_cache=None,\n):\n    \"\"\"\n    Shortcuts for generating request headers.\n\n    :param keep_alive:\n        If ``True``, adds 'connection: keep-alive' header.\n\n    :param accept_encoding:\n        Can be a boolean, list, or string.\n        ``True`` translates to 'gzip,deflate'.\n        List will get joined by comma.\n        String will be used as provided.\n\n    :param user_agent:\n        String representing the user-agent you want, such as\n        \"python-urllib3/0.6\"\n\n    :param basic_auth:\n        Colon-separated username:password string for 'authorization: basic ...'\n        auth header.\n\n    :param proxy_basic_auth:\n        Colon-separated username:password string for 'proxy-authorization: basic ...'\n        auth header.\n\n    :param disable_cache:\n        If ``True``, adds 'cache-control: no-cache' header.\n\n    Example::\n\n        &gt;&gt;&gt; make_headers(keep_alive=True, user_agent=\"Batman/1.0\")\n        {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n        &gt;&gt;&gt; make_headers(accept_encoding=True)\n        {'accept-encoding': 'gzip,deflate'}\n    \"\"\"\n    headers = {}\n    if accept_encoding:\n        if isinstance(accept_encoding, str):\n            pass\n        elif isinstance(accept_encoding, list):\n            accept_encoding = \",\".join(accept_encoding)\n        else:\n            accept_encoding = ACCEPT_ENCODING\n        headers[\"accept-encoding\"] = accept_encoding\n\n    if user_agent:\n        headers[\"user-agent\"] = user_agent\n\n    if keep_alive:\n        headers[\"connection\"] = \"keep-alive\"\n\n    if basic_auth:\n        headers[\"authorization\"] = \"Basic \" + b64encode(b(basic_auth)).decode(\"utf-8\")\n\n    if proxy_basic_auth:\n        headers[\"proxy-authorization\"] = \"Basic \" + b64encode(\n            b(proxy_basic_auth)\n        ).decode(\"utf-8\")\n\n    if disable_cache:\n        headers[\"cache-control\"] = \"no-cache\"\n\n    return headers\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.parse_url","title":"<code>parse_url(url)</code>","text":"<p>Given a url, return a parsed :class:<code>.Url</code> namedtuple. Best-effort is performed to parse incomplete urls. Fields not provided will be None. This parser is RFC 3986 compliant.</p> <p>The parser logic and helper functions are based heavily on work done in the <code>rfc3986</code> module.</p> <p>:param str url: URL to parse into a :class:<code>.Url</code> namedtuple.</p> <p>Partly backwards-compatible with :mod:<code>urlparse</code>.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; parse_url('http://google.com/mail/')\nUrl(scheme='http', host='google.com', port=None, path='/mail/', ...)\n&gt;&gt;&gt; parse_url('google.com:80')\nUrl(scheme=None, host='google.com', port=80, path=None, ...)\n&gt;&gt;&gt; parse_url('/foo?bar')\nUrl(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/util/url.py</code> <pre><code>def parse_url(url):\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 compliant.\n\n    The parser logic and helper functions are based heavily on\n    work done in the ``rfc3986`` module.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urlparse`.\n\n    Example::\n\n        &gt;&gt;&gt; parse_url('http://google.com/mail/')\n        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n        &gt;&gt;&gt; parse_url('google.com:80')\n        Url(scheme=None, host='google.com', port=80, path=None, ...)\n        &gt;&gt;&gt; parse_url('/foo?bar')\n        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    source_url = url\n    if not SCHEME_RE.search(url):\n        url = \"//\" + url\n\n    try:\n        scheme, authority, path, query, fragment = URI_RE.match(url).groups()\n        normalize_uri = scheme is None or scheme.lower() in NORMALIZABLE_SCHEMES\n\n        if scheme:\n            scheme = scheme.lower()\n\n        if authority:\n            auth, _, host_port = authority.rpartition(\"@\")\n            auth = auth or None\n            host, port = _HOST_PORT_RE.match(host_port).groups()\n            if auth and normalize_uri:\n                auth = _encode_invalid_chars(auth, USERINFO_CHARS)\n            if port == \"\":\n                port = None\n        else:\n            auth, host, port = None, None, None\n\n        if port is not None:\n            port = int(port)\n            if not (0 &lt;= port &lt;= 65535):\n                raise LocationParseError(url)\n\n        host = _normalize_host(host, scheme)\n\n        if normalize_uri and path:\n            path = _remove_path_dot_segments(path)\n            path = _encode_invalid_chars(path, PATH_CHARS)\n        if normalize_uri and query:\n            query = _encode_invalid_chars(query, QUERY_CHARS)\n        if normalize_uri and fragment:\n            fragment = _encode_invalid_chars(fragment, FRAGMENT_CHARS)\n\n    except (ValueError, AttributeError):\n        return six.raise_from(LocationParseError(source_url), None)\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    if not path:\n        if query is not None or fragment is not None:\n            path = \"\"\n        else:\n            path = None\n\n    # Ensure that each part of the URL is a `str` for\n    # backwards compatibility.\n    if isinstance(url, six.text_type):\n        ensure_func = six.ensure_text\n    else:\n        ensure_func = six.ensure_str\n\n    def ensure_type(x):\n        return x if x is None else ensure_func(x)\n\n    return Url(\n        scheme=ensure_type(scheme),\n        auth=ensure_type(auth),\n        host=ensure_type(host),\n        port=port,\n        path=ensure_type(path),\n        query=ensure_type(query),\n        fragment=ensure_type(fragment),\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.resolve_cert_reqs","title":"<code>resolve_cert_reqs(candidate)</code>","text":"<p>Resolves the argument to a numeric constant, which can be passed to the wrap_socket function/method from the ssl module. Defaults to :data:<code>ssl.CERT_REQUIRED</code>. If given a string it is assumed to be the name of the constant in the :mod:<code>ssl</code> module or its abbreviation. (So you can specify <code>REQUIRED</code> instead of <code>CERT_REQUIRED</code>. If it's neither <code>None</code> nor a string we assume it is already the numeric constant which can directly be passed to wrap_socket.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def resolve_cert_reqs(candidate):\n    \"\"\"\n    Resolves the argument to a numeric constant, which can be passed to\n    the wrap_socket function/method from the ssl module.\n    Defaults to :data:`ssl.CERT_REQUIRED`.\n    If given a string it is assumed to be the name of the constant in the\n    :mod:`ssl` module or its abbreviation.\n    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.\n    If it's neither `None` nor a string we assume it is already the numeric\n    constant which can directly be passed to wrap_socket.\n    \"\"\"\n    if candidate is None:\n        return CERT_REQUIRED\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"CERT_\" + candidate)\n        return res\n\n    return candidate\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.resolve_ssl_version","title":"<code>resolve_ssl_version(candidate)</code>","text":"<p>like resolve_cert_reqs</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def resolve_ssl_version(candidate):\n    \"\"\"\n    like resolve_cert_reqs\n    \"\"\"\n    if candidate is None:\n        return PROTOCOL_TLS\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"PROTOCOL_\" + candidate)\n        return res\n\n    return candidate\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.split_first","title":"<code>split_first(s, delims)</code>","text":"<p>.. deprecated:: 1.25</p> <p>Given a string and an iterable of delimiters, split on the first found delimiter. Return two split parts and the matched delimiter.</p> <p>If not found, then the first part is the full input string.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; split_first('foo/bar?baz', '?/=')\n('foo', 'bar?baz', '/')\n&gt;&gt;&gt; split_first('foo/bar?baz', '123')\n('foo/bar?baz', '', None)\n</code></pre> <p>Scales linearly with number of delims. Not ideal for large number of delims.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/url.py</code> <pre><code>def split_first(s, delims):\n    \"\"\"\n    .. deprecated:: 1.25\n\n    Given a string and an iterable of delimiters, split on the first found\n    delimiter. Return two split parts and the matched delimiter.\n\n    If not found, then the first part is the full input string.\n\n    Example::\n\n        &gt;&gt;&gt; split_first('foo/bar?baz', '?/=')\n        ('foo', 'bar?baz', '/')\n        &gt;&gt;&gt; split_first('foo/bar?baz', '123')\n        ('foo/bar?baz', '', None)\n\n    Scales linearly with number of delims. Not ideal for large number of delims.\n    \"\"\"\n    min_idx = None\n    min_delim = None\n    for d in delims:\n        idx = s.find(d)\n        if idx &lt; 0:\n            continue\n\n        if min_idx is None or idx &lt; min_idx:\n            min_idx = idx\n            min_delim = d\n\n    if min_idx is None or min_idx &lt; 0:\n        return s, \"\", None\n\n    return s[:min_idx], s[min_idx + 1 :], min_delim\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.ssl_wrap_socket","title":"<code>ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None, ca_certs=None, server_hostname=None, ssl_version=None, ciphers=None, ssl_context=None, ca_cert_dir=None, key_password=None, ca_cert_data=None, tls_in_tls=False)</code>","text":"<p>All arguments except for server_hostname, ssl_context, and ca_cert_dir have the same meaning as they do when using :func:<code>ssl.wrap_socket</code>.</p> <p>:param server_hostname:     When SNI is supported, the expected hostname of the certificate :param ssl_context:     A pre-made :class:<code>SSLContext</code> object. If none is provided, one will     be created using :func:<code>create_urllib3_context</code>. :param ciphers:     A string of ciphers we wish the client to support. :param ca_cert_dir:     A directory containing CA certificates in multiple separate files, as     supported by OpenSSL's -CApath flag or the capath argument to     SSLContext.load_verify_locations(). :param key_password:     Optional password if the keyfile is encrypted. :param ca_cert_data:     Optional string containing CA certificates in PEM format suitable for     passing as the cadata parameter to SSLContext.load_verify_locations() :param tls_in_tls:     Use SSLTransport to wrap the existing socket.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def ssl_wrap_socket(\n    sock,\n    keyfile=None,\n    certfile=None,\n    cert_reqs=None,\n    ca_certs=None,\n    server_hostname=None,\n    ssl_version=None,\n    ciphers=None,\n    ssl_context=None,\n    ca_cert_dir=None,\n    key_password=None,\n    ca_cert_data=None,\n    tls_in_tls=False,\n):\n    \"\"\"\n    All arguments except for server_hostname, ssl_context, and ca_cert_dir have\n    the same meaning as they do when using :func:`ssl.wrap_socket`.\n\n    :param server_hostname:\n        When SNI is supported, the expected hostname of the certificate\n    :param ssl_context:\n        A pre-made :class:`SSLContext` object. If none is provided, one will\n        be created using :func:`create_urllib3_context`.\n    :param ciphers:\n        A string of ciphers we wish the client to support.\n    :param ca_cert_dir:\n        A directory containing CA certificates in multiple separate files, as\n        supported by OpenSSL's -CApath flag or the capath argument to\n        SSLContext.load_verify_locations().\n    :param key_password:\n        Optional password if the keyfile is encrypted.\n    :param ca_cert_data:\n        Optional string containing CA certificates in PEM format suitable for\n        passing as the cadata parameter to SSLContext.load_verify_locations()\n    :param tls_in_tls:\n        Use SSLTransport to wrap the existing socket.\n    \"\"\"\n    context = ssl_context\n    if context is None:\n        # Note: This branch of code and all the variables in it are no longer\n        # used by urllib3 itself. We should consider deprecating and removing\n        # this code.\n        context = create_urllib3_context(ssl_version, cert_reqs, ciphers=ciphers)\n\n    if ca_certs or ca_cert_dir or ca_cert_data:\n        try:\n            context.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)\n        except (IOError, OSError) as e:\n            raise SSLError(e)\n\n    elif ssl_context is None and hasattr(context, \"load_default_certs\"):\n        # try to load OS default certs; works well on Windows (require Python3.4+)\n        context.load_default_certs()\n\n    # Attempt to detect if we get the goofy behavior of the\n    # keyfile being encrypted and OpenSSL asking for the\n    # passphrase via the terminal and instead error out.\n    if keyfile and key_password is None and _is_key_file_encrypted(keyfile):\n        raise SSLError(\"Client private key is encrypted, password is required\")\n\n    if certfile:\n        if key_password is None:\n            context.load_cert_chain(certfile, keyfile)\n        else:\n            context.load_cert_chain(certfile, keyfile, key_password)\n\n    try:\n        if hasattr(context, \"set_alpn_protocols\"):\n            context.set_alpn_protocols(ALPN_PROTOCOLS)\n    except NotImplementedError:  # Defensive: in CI, we always have set_alpn_protocols\n        pass\n\n    # If we detect server_hostname is an IP address then the SNI\n    # extension should not be used according to RFC3546 Section 3.1\n    use_sni_hostname = server_hostname and not is_ipaddress(server_hostname)\n    # SecureTransport uses server_hostname in certificate verification.\n    send_sni = (use_sni_hostname and HAS_SNI) or (\n        IS_SECURETRANSPORT and server_hostname\n    )\n    # Do not warn the user if server_hostname is an invalid SNI hostname.\n    if not HAS_SNI and use_sni_hostname:\n        warnings.warn(\n            \"An HTTPS request has been made, but the SNI (Server Name \"\n            \"Indication) extension to TLS is not available on this platform. \"\n            \"This may cause the server to present an incorrect TLS \"\n            \"certificate, which can cause validation failures. You can upgrade to \"\n            \"a newer version of Python to solve this. For more information, see \"\n            \"https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html\"\n            \"#ssl-warnings\",\n            SNIMissingWarning,\n        )\n\n    if send_sni:\n        ssl_sock = _ssl_wrap_socket_impl(\n            sock, context, tls_in_tls, server_hostname=server_hostname\n        )\n    else:\n        ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls)\n    return ssl_sock\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.wait_for_read","title":"<code>wait_for_read(sock, timeout=None)</code>","text":"<p>Waits for reading to be available on a given socket. Returns True if the socket is readable, or False if the timeout expired.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/wait.py</code> <pre><code>def wait_for_read(sock, timeout=None):\n    \"\"\"Waits for reading to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, read=True, timeout=timeout)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/index.html#client.ayon_fusion.vendor.urllib3.util.wait_for_write","title":"<code>wait_for_write(sock, timeout=None)</code>","text":"<p>Waits for writing to be available on a given socket. Returns True if the socket is readable, or False if the timeout expired.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/wait.py</code> <pre><code>def wait_for_write(sock, timeout=None):\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/connection.html","title":"connection","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/connection.html#client.ayon_fusion.vendor.urllib3.util.connection.allowed_gai_family","title":"<code>allowed_gai_family()</code>","text":"<p>This function is designed to work in the context of getaddrinfo, where family=socket.AF_UNSPEC is the default and will perform a DNS search for both IPv6 and IPv4 records.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/connection.py</code> <pre><code>def allowed_gai_family():\n    \"\"\"This function is designed to work in the context of\n    getaddrinfo, where family=socket.AF_UNSPEC is the default and\n    will perform a DNS search for both IPv6 and IPv4 records.\"\"\"\n\n    family = socket.AF_INET\n    if HAS_IPV6:\n        family = socket.AF_UNSPEC\n    return family\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/connection.html#client.ayon_fusion.vendor.urllib3.util.connection.create_connection","title":"<code>create_connection(address, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, source_address=None, socket_options=None)</code>","text":"<p>Connect to address and return the socket object.</p> <p>Convenience function.  Connect to address (a 2-tuple <code>(host, port)</code>) and return the socket object.  Passing the optional timeout parameter will set the timeout on the socket instance before attempting to connect.  If no timeout is supplied, the global default timeout setting returned by :func:<code>socket.getdefaulttimeout</code> is used.  If source_address is set it must be a tuple of (host, port) for the socket to bind as a source address before making the connection. An host of '' or port 0 tells the OS to use the default.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/connection.py</code> <pre><code>def create_connection(\n    address,\n    timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n    source_address=None,\n    socket_options=None,\n):\n    \"\"\"Connect to *address* and return the socket object.\n\n    Convenience function.  Connect to *address* (a 2-tuple ``(host,\n    port)``) and return the socket object.  Passing the optional\n    *timeout* parameter will set the timeout on the socket instance\n    before attempting to connect.  If no *timeout* is supplied, the\n    global default timeout setting returned by :func:`socket.getdefaulttimeout`\n    is used.  If *source_address* is set it must be a tuple of (host, port)\n    for the socket to bind as a source address before making the connection.\n    An host of '' or port 0 tells the OS to use the default.\n    \"\"\"\n\n    host, port = address\n    if host.startswith(\"[\"):\n        host = host.strip(\"[]\")\n    err = None\n\n    # Using the value from allowed_gai_family() in the context of getaddrinfo lets\n    # us select whether to work with IPv4 DNS records, IPv6 records, or both.\n    # The original create_connection function always returns all records.\n    family = allowed_gai_family()\n\n    try:\n        host.encode(\"idna\")\n    except UnicodeError:\n        return six.raise_from(\n            LocationParseError(u\"'%s', label empty or too long\" % host), None\n        )\n\n    for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):\n        af, socktype, proto, canonname, sa = res\n        sock = None\n        try:\n            sock = socket.socket(af, socktype, proto)\n\n            # If provided, set socket level options before connecting.\n            _set_socket_options(sock, socket_options)\n\n            if timeout is not socket._GLOBAL_DEFAULT_TIMEOUT:\n                sock.settimeout(timeout)\n            if source_address:\n                sock.bind(source_address)\n            sock.connect(sa)\n            return sock\n\n        except socket.error as e:\n            err = e\n            if sock is not None:\n                sock.close()\n                sock = None\n\n    if err is not None:\n        raise err\n\n    raise socket.error(\"getaddrinfo returns an empty list\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/connection.html#client.ayon_fusion.vendor.urllib3.util.connection.is_connection_dropped","title":"<code>is_connection_dropped(conn)</code>","text":"<p>Returns True if the connection is dropped and should be closed.</p> <p>:param conn:     :class:<code>http.client.HTTPConnection</code> object.</p> <p>Note: For platforms like AppEngine, this will always return <code>False</code> to let the platform handle connection recycling transparently for us.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/connection.py</code> <pre><code>def is_connection_dropped(conn):  # Platform-specific\n    \"\"\"\n    Returns True if the connection is dropped and should be closed.\n\n    :param conn:\n        :class:`http.client.HTTPConnection` object.\n\n    Note: For platforms like AppEngine, this will always return ``False`` to\n    let the platform handle connection recycling transparently for us.\n    \"\"\"\n    sock = getattr(conn, \"sock\", False)\n    if sock is False:  # Platform-specific: AppEngine\n        return False\n    if sock is None:  # Connection already closed (such as by httplib).\n        return True\n    try:\n        # Returns True if readable, which here means it's been dropped\n        return wait_for_read(sock, timeout=0.0)\n    except NoWayToWaitForSocketError:  # Platform-specific: AppEngine\n        return False\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/proxy.html","title":"proxy","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/proxy.html#client.ayon_fusion.vendor.urllib3.util.proxy.connection_requires_http_tunnel","title":"<code>connection_requires_http_tunnel(proxy_url=None, proxy_config=None, destination_scheme=None)</code>","text":"<p>Returns True if the connection requires an HTTP CONNECT through the proxy.</p> <p>:param URL proxy_url:     URL of the proxy. :param ProxyConfig proxy_config:     Proxy configuration from poolmanager.py :param str destination_scheme:     The scheme of the destination. (i.e https, http, etc)</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/proxy.py</code> <pre><code>def connection_requires_http_tunnel(\n    proxy_url=None, proxy_config=None, destination_scheme=None\n):\n    \"\"\"\n    Returns True if the connection requires an HTTP CONNECT through the proxy.\n\n    :param URL proxy_url:\n        URL of the proxy.\n    :param ProxyConfig proxy_config:\n        Proxy configuration from poolmanager.py\n    :param str destination_scheme:\n        The scheme of the destination. (i.e https, http, etc)\n    \"\"\"\n    # If we're not using a proxy, no way to use a tunnel.\n    if proxy_url is None:\n        return False\n\n    # HTTP destinations never require tunneling, we always forward.\n    if destination_scheme == \"http\":\n        return False\n\n    # Support for forwarding with HTTPS proxies and HTTPS destinations.\n    if (\n        proxy_url.scheme == \"https\"\n        and proxy_config\n        and proxy_config.use_forwarding_for_https\n    ):\n        return False\n\n    # Otherwise always use a tunnel.\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/proxy.html#client.ayon_fusion.vendor.urllib3.util.proxy.create_proxy_ssl_context","title":"<code>create_proxy_ssl_context(ssl_version, cert_reqs, ca_certs=None, ca_cert_dir=None, ca_cert_data=None)</code>","text":"<p>Generates a default proxy ssl context if one hasn't been provided by the user.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/proxy.py</code> <pre><code>def create_proxy_ssl_context(\n    ssl_version, cert_reqs, ca_certs=None, ca_cert_dir=None, ca_cert_data=None\n):\n    \"\"\"\n    Generates a default proxy ssl context if one hasn't been provided by the\n    user.\n    \"\"\"\n    ssl_context = create_urllib3_context(\n        ssl_version=resolve_ssl_version(ssl_version),\n        cert_reqs=resolve_cert_reqs(cert_reqs),\n    )\n    if (\n        not ca_certs\n        and not ca_cert_dir\n        and not ca_cert_data\n        and hasattr(ssl_context, \"load_default_certs\")\n    ):\n        ssl_context.load_default_certs()\n\n    return ssl_context\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/queue.html","title":"queue","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/request.html","title":"request","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/request.html#client.ayon_fusion.vendor.urllib3.util.request.make_headers","title":"<code>make_headers(keep_alive=None, accept_encoding=None, user_agent=None, basic_auth=None, proxy_basic_auth=None, disable_cache=None)</code>","text":"<p>Shortcuts for generating request headers.</p> <p>:param keep_alive:     If <code>True</code>, adds 'connection: keep-alive' header.</p> <p>:param accept_encoding:     Can be a boolean, list, or string.     <code>True</code> translates to 'gzip,deflate'.     List will get joined by comma.     String will be used as provided.</p> <p>:param user_agent:     String representing the user-agent you want, such as     \"python-urllib3/0.6\"</p> <p>:param basic_auth:     Colon-separated username:password string for 'authorization: basic ...'     auth header.</p> <p>:param proxy_basic_auth:     Colon-separated username:password string for 'proxy-authorization: basic ...'     auth header.</p> <p>:param disable_cache:     If <code>True</code>, adds 'cache-control: no-cache' header.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; make_headers(keep_alive=True, user_agent=\"Batman/1.0\")\n{'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n&gt;&gt;&gt; make_headers(accept_encoding=True)\n{'accept-encoding': 'gzip,deflate'}\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/util/request.py</code> <pre><code>def make_headers(\n    keep_alive=None,\n    accept_encoding=None,\n    user_agent=None,\n    basic_auth=None,\n    proxy_basic_auth=None,\n    disable_cache=None,\n):\n    \"\"\"\n    Shortcuts for generating request headers.\n\n    :param keep_alive:\n        If ``True``, adds 'connection: keep-alive' header.\n\n    :param accept_encoding:\n        Can be a boolean, list, or string.\n        ``True`` translates to 'gzip,deflate'.\n        List will get joined by comma.\n        String will be used as provided.\n\n    :param user_agent:\n        String representing the user-agent you want, such as\n        \"python-urllib3/0.6\"\n\n    :param basic_auth:\n        Colon-separated username:password string for 'authorization: basic ...'\n        auth header.\n\n    :param proxy_basic_auth:\n        Colon-separated username:password string for 'proxy-authorization: basic ...'\n        auth header.\n\n    :param disable_cache:\n        If ``True``, adds 'cache-control: no-cache' header.\n\n    Example::\n\n        &gt;&gt;&gt; make_headers(keep_alive=True, user_agent=\"Batman/1.0\")\n        {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}\n        &gt;&gt;&gt; make_headers(accept_encoding=True)\n        {'accept-encoding': 'gzip,deflate'}\n    \"\"\"\n    headers = {}\n    if accept_encoding:\n        if isinstance(accept_encoding, str):\n            pass\n        elif isinstance(accept_encoding, list):\n            accept_encoding = \",\".join(accept_encoding)\n        else:\n            accept_encoding = ACCEPT_ENCODING\n        headers[\"accept-encoding\"] = accept_encoding\n\n    if user_agent:\n        headers[\"user-agent\"] = user_agent\n\n    if keep_alive:\n        headers[\"connection\"] = \"keep-alive\"\n\n    if basic_auth:\n        headers[\"authorization\"] = \"Basic \" + b64encode(b(basic_auth)).decode(\"utf-8\")\n\n    if proxy_basic_auth:\n        headers[\"proxy-authorization\"] = \"Basic \" + b64encode(\n            b(proxy_basic_auth)\n        ).decode(\"utf-8\")\n\n    if disable_cache:\n        headers[\"cache-control\"] = \"no-cache\"\n\n    return headers\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/request.html#client.ayon_fusion.vendor.urllib3.util.request.rewind_body","title":"<code>rewind_body(body, body_pos)</code>","text":"<p>Attempt to rewind body to a certain position. Primarily used for request redirects and retries.</p> <p>:param body:     File-like object that supports seek.</p> <p>:param int pos:     Position to seek to in file.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/request.py</code> <pre><code>def rewind_body(body, body_pos):\n    \"\"\"\n    Attempt to rewind body to a certain position.\n    Primarily used for request redirects and retries.\n\n    :param body:\n        File-like object that supports seek.\n\n    :param int pos:\n        Position to seek to in file.\n    \"\"\"\n    body_seek = getattr(body, \"seek\", None)\n    if body_seek is not None and isinstance(body_pos, integer_types):\n        try:\n            body_seek(body_pos)\n        except (IOError, OSError):\n            raise UnrewindableBodyError(\n                \"An error occurred when rewinding request body for redirect/retry.\"\n            )\n    elif body_pos is _FAILEDTELL:\n        raise UnrewindableBodyError(\n            \"Unable to record file position for rewinding \"\n            \"request body during a redirect/retry.\"\n        )\n    else:\n        raise ValueError(\n            \"body_pos must be of type integer, instead it was %s.\" % type(body_pos)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/request.html#client.ayon_fusion.vendor.urllib3.util.request.set_file_position","title":"<code>set_file_position(body, pos)</code>","text":"<p>If a position is provided, move file to that point. Otherwise, we'll attempt to record a position for future use.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/request.py</code> <pre><code>def set_file_position(body, pos):\n    \"\"\"\n    If a position is provided, move file to that point.\n    Otherwise, we'll attempt to record a position for future use.\n    \"\"\"\n    if pos is not None:\n        rewind_body(body, pos)\n    elif getattr(body, \"tell\", None) is not None:\n        try:\n            pos = body.tell()\n        except (IOError, OSError):\n            # This differentiates from None, allowing us to catch\n            # a failed `tell()` later when trying to rewind the body.\n            pos = _FAILEDTELL\n\n    return pos\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/response.html","title":"response","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/response.html#client.ayon_fusion.vendor.urllib3.util.response.assert_header_parsing","title":"<code>assert_header_parsing(headers)</code>","text":"<p>Asserts whether all headers have been successfully parsed. Extracts encountered errors from the result of parsing headers.</p> <p>Only works on Python 3.</p> <p>:param http.client.HTTPMessage headers: Headers to verify.</p> <p>:raises urllib3.exceptions.HeaderParsingError:     If parsing errors are found.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/response.py</code> <pre><code>def assert_header_parsing(headers):\n    \"\"\"\n    Asserts whether all headers have been successfully parsed.\n    Extracts encountered errors from the result of parsing headers.\n\n    Only works on Python 3.\n\n    :param http.client.HTTPMessage headers: Headers to verify.\n\n    :raises urllib3.exceptions.HeaderParsingError:\n        If parsing errors are found.\n    \"\"\"\n\n    # This will fail silently if we pass in the wrong kind of parameter.\n    # To make debugging easier add an explicit check.\n    if not isinstance(headers, httplib.HTTPMessage):\n        raise TypeError(\"expected httplib.Message, got {0}.\".format(type(headers)))\n\n    defects = getattr(headers, \"defects\", None)\n    get_payload = getattr(headers, \"get_payload\", None)\n\n    unparsed_data = None\n    if get_payload:\n        # get_payload is actually email.message.Message.get_payload;\n        # we're only interested in the result if it's not a multipart message\n        if not headers.is_multipart():\n            payload = get_payload()\n\n            if isinstance(payload, (bytes, str)):\n                unparsed_data = payload\n    if defects:\n        # httplib is assuming a response body is available\n        # when parsing headers even when httplib only sends\n        # header data to parse_headers() This results in\n        # defects on multipart responses in particular.\n        # See: https://github.com/urllib3/urllib3/issues/800\n\n        # So we ignore the following defects:\n        # - StartBoundaryNotFoundDefect:\n        #     The claimed start boundary was never found.\n        # - MultipartInvariantViolationDefect:\n        #     A message claimed to be a multipart but no subparts were found.\n        defects = [\n            defect\n            for defect in defects\n            if not isinstance(\n                defect, (StartBoundaryNotFoundDefect, MultipartInvariantViolationDefect)\n            )\n        ]\n\n    if defects or unparsed_data:\n        raise HeaderParsingError(defects=defects, unparsed_data=unparsed_data)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/response.html#client.ayon_fusion.vendor.urllib3.util.response.is_fp_closed","title":"<code>is_fp_closed(obj)</code>","text":"<p>Checks whether a given file-like object is closed.</p> <p>:param obj:     The file-like object to check.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/response.py</code> <pre><code>def is_fp_closed(obj):\n    \"\"\"\n    Checks whether a given file-like object is closed.\n\n    :param obj:\n        The file-like object to check.\n    \"\"\"\n\n    try:\n        # Check `isclosed()` first, in case Python3 doesn't set `closed`.\n        # GH Issue #928\n        return obj.isclosed()\n    except AttributeError:\n        pass\n\n    try:\n        # Check via the official file-like-object way.\n        return obj.closed\n    except AttributeError:\n        pass\n\n    try:\n        # Check if the object is a container for another file-like object that\n        # gets released on exhaustion (e.g. HTTPResponse).\n        return obj.fp is None\n    except AttributeError:\n        pass\n\n    raise ValueError(\"Unable to determine whether fp is closed.\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/response.html#client.ayon_fusion.vendor.urllib3.util.response.is_response_to_head","title":"<code>is_response_to_head(response)</code>","text":"<p>Checks whether the request of a response has been a HEAD-request. Handles the quirks of AppEngine.</p> <p>:param http.client.HTTPResponse response:     Response to check if the originating request     used 'HEAD' as a method.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/response.py</code> <pre><code>def is_response_to_head(response):\n    \"\"\"\n    Checks whether the request of a response has been a HEAD-request.\n    Handles the quirks of AppEngine.\n\n    :param http.client.HTTPResponse response:\n        Response to check if the originating request\n        used 'HEAD' as a method.\n    \"\"\"\n    # FIXME: Can we do this somehow without accessing private httplib _method?\n    method = response._method\n    if isinstance(method, int):  # Platform-specific: Appengine\n        return method == 3\n    return method.upper() == \"HEAD\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/retry.html","title":"retry","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/retry.html#client.ayon_fusion.vendor.urllib3.util.retry.Retry","title":"<code>Retry</code>","text":"<p>               Bases: <code>object</code></p> <p>Retry configuration.</p> <p>Each retry attempt will create a new Retry object with updated values, so they can be safely reused.</p> <p>Retries can be defined as a default for a pool::</p> <pre><code>retries = Retry(connect=5, read=2, redirect=5)\nhttp = PoolManager(retries=retries)\nresponse = http.request('GET', 'http://example.com/')\n</code></pre> <p>Or per-request (which overrides the default for the pool)::</p> <pre><code>response = http.request('GET', 'http://example.com/', retries=Retry(10))\n</code></pre> <p>Retries can be disabled by passing <code>False</code>::</p> <pre><code>response = http.request('GET', 'http://example.com/', retries=False)\n</code></pre> <p>Errors will be wrapped in :class:<code>~urllib3.exceptions.MaxRetryError</code> unless retries are disabled, in which case the causing exception will be raised.</p> <p>:param int total:     Total number of retries to allow. Takes precedence over other counts.</p> <pre><code>Set to ``None`` to remove this constraint and fall back on other\ncounts.\n\nSet to ``0`` to fail on the first retry.\n\nSet to ``False`` to disable and imply ``raise_on_redirect=False``.\n</code></pre> <p>:param int connect:     How many connection-related errors to retry on.</p> <pre><code>These are errors raised before the request is sent to the remote server,\nwhich we assume has not triggered the server to process the request.\n\nSet to ``0`` to fail on the first retry of this type.\n</code></pre> <p>:param int read:     How many times to retry on read errors.</p> <pre><code>These errors are raised after the request was sent to the server, so the\nrequest may have side-effects.\n\nSet to ``0`` to fail on the first retry of this type.\n</code></pre> <p>:param int redirect:     How many redirects to perform. Limit this to avoid infinite redirect     loops.</p> <pre><code>A redirect is a HTTP response with a status code 301, 302, 303, 307 or\n308.\n\nSet to ``0`` to fail on the first retry of this type.\n\nSet to ``False`` to disable and imply ``raise_on_redirect=False``.\n</code></pre> <p>:param int status:     How many times to retry on bad status codes.</p> <pre><code>These are retries made on responses, where status code matches\n``status_forcelist``.\n\nSet to ``0`` to fail on the first retry of this type.\n</code></pre> <p>:param int other:     How many times to retry on other errors.</p> <pre><code>Other errors are errors that are not connect, read, redirect or status errors.\nThese errors might be raised after the request was sent to the server, so the\nrequest might have side-effects.\n\nSet to ``0`` to fail on the first retry of this type.\n\nIf ``total`` is not set, it's a good idea to set this to 0 to account\nfor unexpected edge cases and avoid infinite retry loops.\n</code></pre> <p>:param iterable allowed_methods:     Set of uppercased HTTP method verbs that we should retry on.</p> <pre><code>By default, we only retry on methods which are considered to be\nidempotent (multiple requests with the same parameters end with the\nsame state). See :attr:`Retry.DEFAULT_ALLOWED_METHODS`.\n\nSet to a ``False`` value to retry on any verb.\n\n.. warning::\n\n    Previously this parameter was named ``method_whitelist``, that\n    usage is deprecated in v1.26.0 and will be removed in v2.0.\n</code></pre> <p>:param iterable status_forcelist:     A set of integer HTTP status codes that we should force a retry on.     A retry is initiated if the request method is in <code>allowed_methods</code>     and the response status code is in <code>status_forcelist</code>.</p> <pre><code>By default, this is disabled with ``None``.\n</code></pre> <p>:param float backoff_factor:     A backoff factor to apply between attempts after the second try     (most errors are resolved immediately by a second try without a     delay). urllib3 will sleep for::</p> <pre><code>    {backoff factor} * (2 ** ({number of total retries} - 1))\n\nseconds. If the backoff_factor is 0.1, then :func:`.sleep` will sleep\nfor [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer\nthan :attr:`Retry.BACKOFF_MAX`.\n\nBy default, backoff is disabled (set to 0).\n</code></pre> <p>:param bool raise_on_redirect: Whether, if the number of redirects is     exhausted, to raise a MaxRetryError, or to return a response with a     response code in the 3xx range.</p> <p>:param bool raise_on_status: Similar meaning to <code>raise_on_redirect</code>:     whether we should raise an exception, or return a response,     if status falls in <code>status_forcelist</code> range and retries have     been exhausted.</p> <p>:param tuple history: The history of the request encountered during     each call to :meth:<code>~Retry.increment</code>. The list is in the order     the requests occurred. Each list item is of class :class:<code>RequestHistory</code>.</p> <p>:param bool respect_retry_after_header:     Whether to respect Retry-After header on status codes defined as     :attr:<code>Retry.RETRY_AFTER_STATUS_CODES</code> or not.</p> <p>:param iterable remove_headers_on_redirect:     Sequence of headers to remove from the request when a response     indicating a redirect is returned before firing off the redirected     request.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>@six.add_metaclass(_RetryMeta)\nclass Retry(object):\n    \"\"\"Retry configuration.\n\n    Each retry attempt will create a new Retry object with updated values, so\n    they can be safely reused.\n\n    Retries can be defined as a default for a pool::\n\n        retries = Retry(connect=5, read=2, redirect=5)\n        http = PoolManager(retries=retries)\n        response = http.request('GET', 'http://example.com/')\n\n    Or per-request (which overrides the default for the pool)::\n\n        response = http.request('GET', 'http://example.com/', retries=Retry(10))\n\n    Retries can be disabled by passing ``False``::\n\n        response = http.request('GET', 'http://example.com/', retries=False)\n\n    Errors will be wrapped in :class:`~urllib3.exceptions.MaxRetryError` unless\n    retries are disabled, in which case the causing exception will be raised.\n\n    :param int total:\n        Total number of retries to allow. Takes precedence over other counts.\n\n        Set to ``None`` to remove this constraint and fall back on other\n        counts.\n\n        Set to ``0`` to fail on the first retry.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int connect:\n        How many connection-related errors to retry on.\n\n        These are errors raised before the request is sent to the remote server,\n        which we assume has not triggered the server to process the request.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int read:\n        How many times to retry on read errors.\n\n        These errors are raised after the request was sent to the server, so the\n        request may have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int redirect:\n        How many redirects to perform. Limit this to avoid infinite redirect\n        loops.\n\n        A redirect is a HTTP response with a status code 301, 302, 303, 307 or\n        308.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        Set to ``False`` to disable and imply ``raise_on_redirect=False``.\n\n    :param int status:\n        How many times to retry on bad status codes.\n\n        These are retries made on responses, where status code matches\n        ``status_forcelist``.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n    :param int other:\n        How many times to retry on other errors.\n\n        Other errors are errors that are not connect, read, redirect or status errors.\n        These errors might be raised after the request was sent to the server, so the\n        request might have side-effects.\n\n        Set to ``0`` to fail on the first retry of this type.\n\n        If ``total`` is not set, it's a good idea to set this to 0 to account\n        for unexpected edge cases and avoid infinite retry loops.\n\n    :param iterable allowed_methods:\n        Set of uppercased HTTP method verbs that we should retry on.\n\n        By default, we only retry on methods which are considered to be\n        idempotent (multiple requests with the same parameters end with the\n        same state). See :attr:`Retry.DEFAULT_ALLOWED_METHODS`.\n\n        Set to a ``False`` value to retry on any verb.\n\n        .. warning::\n\n            Previously this parameter was named ``method_whitelist``, that\n            usage is deprecated in v1.26.0 and will be removed in v2.0.\n\n    :param iterable status_forcelist:\n        A set of integer HTTP status codes that we should force a retry on.\n        A retry is initiated if the request method is in ``allowed_methods``\n        and the response status code is in ``status_forcelist``.\n\n        By default, this is disabled with ``None``.\n\n    :param float backoff_factor:\n        A backoff factor to apply between attempts after the second try\n        (most errors are resolved immediately by a second try without a\n        delay). urllib3 will sleep for::\n\n            {backoff factor} * (2 ** ({number of total retries} - 1))\n\n        seconds. If the backoff_factor is 0.1, then :func:`.sleep` will sleep\n        for [0.0s, 0.2s, 0.4s, ...] between retries. It will never be longer\n        than :attr:`Retry.BACKOFF_MAX`.\n\n        By default, backoff is disabled (set to 0).\n\n    :param bool raise_on_redirect: Whether, if the number of redirects is\n        exhausted, to raise a MaxRetryError, or to return a response with a\n        response code in the 3xx range.\n\n    :param bool raise_on_status: Similar meaning to ``raise_on_redirect``:\n        whether we should raise an exception, or return a response,\n        if status falls in ``status_forcelist`` range and retries have\n        been exhausted.\n\n    :param tuple history: The history of the request encountered during\n        each call to :meth:`~Retry.increment`. The list is in the order\n        the requests occurred. Each list item is of class :class:`RequestHistory`.\n\n    :param bool respect_retry_after_header:\n        Whether to respect Retry-After header on status codes defined as\n        :attr:`Retry.RETRY_AFTER_STATUS_CODES` or not.\n\n    :param iterable remove_headers_on_redirect:\n        Sequence of headers to remove from the request when a response\n        indicating a redirect is returned before firing off the redirected\n        request.\n    \"\"\"\n\n    #: Default methods to be used for ``allowed_methods``\n    DEFAULT_ALLOWED_METHODS = frozenset(\n        [\"HEAD\", \"GET\", \"PUT\", \"DELETE\", \"OPTIONS\", \"TRACE\"]\n    )\n\n    #: Default status codes to be used for ``status_forcelist``\n    RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])\n\n    #: Default headers to be used for ``remove_headers_on_redirect``\n    DEFAULT_REMOVE_HEADERS_ON_REDIRECT = frozenset([\"Authorization\"])\n\n    #: Maximum backoff time.\n    BACKOFF_MAX = 120\n\n    def __init__(\n        self,\n        total=10,\n        connect=None,\n        read=None,\n        redirect=None,\n        status=None,\n        other=None,\n        allowed_methods=_Default,\n        status_forcelist=None,\n        backoff_factor=0,\n        raise_on_redirect=True,\n        raise_on_status=True,\n        history=None,\n        respect_retry_after_header=True,\n        remove_headers_on_redirect=_Default,\n        # TODO: Deprecated, remove in v2.0\n        method_whitelist=_Default,\n    ):\n\n        if method_whitelist is not _Default:\n            if allowed_methods is not _Default:\n                raise ValueError(\n                    \"Using both 'allowed_methods' and \"\n                    \"'method_whitelist' together is not allowed. \"\n                    \"Instead only use 'allowed_methods'\"\n                )\n            warnings.warn(\n                \"Using 'method_whitelist' with Retry is deprecated and \"\n                \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            allowed_methods = method_whitelist\n        if allowed_methods is _Default:\n            allowed_methods = self.DEFAULT_ALLOWED_METHODS\n        if remove_headers_on_redirect is _Default:\n            remove_headers_on_redirect = self.DEFAULT_REMOVE_HEADERS_ON_REDIRECT\n\n        self.total = total\n        self.connect = connect\n        self.read = read\n        self.status = status\n        self.other = other\n\n        if redirect is False or total is False:\n            redirect = 0\n            raise_on_redirect = False\n\n        self.redirect = redirect\n        self.status_forcelist = status_forcelist or set()\n        self.allowed_methods = allowed_methods\n        self.backoff_factor = backoff_factor\n        self.raise_on_redirect = raise_on_redirect\n        self.raise_on_status = raise_on_status\n        self.history = history or tuple()\n        self.respect_retry_after_header = respect_retry_after_header\n        self.remove_headers_on_redirect = frozenset(\n            [h.lower() for h in remove_headers_on_redirect]\n        )\n\n    def new(self, **kw):\n        params = dict(\n            total=self.total,\n            connect=self.connect,\n            read=self.read,\n            redirect=self.redirect,\n            status=self.status,\n            other=self.other,\n            status_forcelist=self.status_forcelist,\n            backoff_factor=self.backoff_factor,\n            raise_on_redirect=self.raise_on_redirect,\n            raise_on_status=self.raise_on_status,\n            history=self.history,\n            remove_headers_on_redirect=self.remove_headers_on_redirect,\n            respect_retry_after_header=self.respect_retry_after_header,\n        )\n\n        # TODO: If already given in **kw we use what's given to us\n        # If not given we need to figure out what to pass. We decide\n        # based on whether our class has the 'method_whitelist' property\n        # and if so we pass the deprecated 'method_whitelist' otherwise\n        # we use 'allowed_methods'. Remove in v2.0\n        if \"method_whitelist\" not in kw and \"allowed_methods\" not in kw:\n            if \"method_whitelist\" in self.__dict__:\n                warnings.warn(\n                    \"Using 'method_whitelist' with Retry is deprecated and \"\n                    \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                    DeprecationWarning,\n                )\n                params[\"method_whitelist\"] = self.allowed_methods\n            else:\n                params[\"allowed_methods\"] = self.allowed_methods\n\n        params.update(kw)\n        return type(self)(**params)\n\n    @classmethod\n    def from_int(cls, retries, redirect=True, default=None):\n        \"\"\"Backwards-compatibility for the old retries format.\"\"\"\n        if retries is None:\n            retries = default if default is not None else cls.DEFAULT\n\n        if isinstance(retries, Retry):\n            return retries\n\n        redirect = bool(redirect) and None\n        new_retries = cls(retries, redirect=redirect)\n        log.debug(\"Converted retries value: %r -&gt; %r\", retries, new_retries)\n        return new_retries\n\n    def get_backoff_time(self):\n        \"\"\"Formula for computing the current backoff\n\n        :rtype: float\n        \"\"\"\n        # We want to consider only the last consecutive errors sequence (Ignore redirects).\n        consecutive_errors_len = len(\n            list(\n                takewhile(lambda x: x.redirect_location is None, reversed(self.history))\n            )\n        )\n        if consecutive_errors_len &lt;= 1:\n            return 0\n\n        backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))\n        return min(self.BACKOFF_MAX, backoff_value)\n\n    def parse_retry_after(self, retry_after):\n        # Whitespace: https://tools.ietf.org/html/rfc7230#section-3.2.4\n        if re.match(r\"^\\s*[0-9]+\\s*$\", retry_after):\n            seconds = int(retry_after)\n        else:\n            retry_date_tuple = email.utils.parsedate_tz(retry_after)\n            if retry_date_tuple is None:\n                raise InvalidHeader(\"Invalid Retry-After header: %s\" % retry_after)\n            if retry_date_tuple[9] is None:  # Python 2\n                # Assume UTC if no timezone was specified\n                # On Python2.7, parsedate_tz returns None for a timezone offset\n                # instead of 0 if no timezone is given, where mktime_tz treats\n                # a None timezone offset as local time.\n                retry_date_tuple = retry_date_tuple[:9] + (0,) + retry_date_tuple[10:]\n\n            retry_date = email.utils.mktime_tz(retry_date_tuple)\n            seconds = retry_date - time.time()\n\n        if seconds &lt; 0:\n            seconds = 0\n\n        return seconds\n\n    def get_retry_after(self, response):\n        \"\"\"Get the value of Retry-After in seconds.\"\"\"\n\n        retry_after = response.getheader(\"Retry-After\")\n\n        if retry_after is None:\n            return None\n\n        return self.parse_retry_after(retry_after)\n\n    def sleep_for_retry(self, response=None):\n        retry_after = self.get_retry_after(response)\n        if retry_after:\n            time.sleep(retry_after)\n            return True\n\n        return False\n\n    def _sleep_backoff(self):\n        backoff = self.get_backoff_time()\n        if backoff &lt;= 0:\n            return\n        time.sleep(backoff)\n\n    def sleep(self, response=None):\n        \"\"\"Sleep between retry attempts.\n\n        This method will respect a server's ``Retry-After`` response header\n        and sleep the duration of the time requested. If that is not present, it\n        will use an exponential backoff. By default, the backoff factor is 0 and\n        this method will return immediately.\n        \"\"\"\n\n        if self.respect_retry_after_header and response:\n            slept = self.sleep_for_retry(response)\n            if slept:\n                return\n\n        self._sleep_backoff()\n\n    def _is_connection_error(self, err):\n        \"\"\"Errors when we're fairly sure that the server did not receive the\n        request, so it should be safe to retry.\n        \"\"\"\n        if isinstance(err, ProxyError):\n            err = err.original_error\n        return isinstance(err, ConnectTimeoutError)\n\n    def _is_read_error(self, err):\n        \"\"\"Errors that occur after the request has been started, so we should\n        assume that the server began processing it.\n        \"\"\"\n        return isinstance(err, (ReadTimeoutError, ProtocolError))\n\n    def _is_method_retryable(self, method):\n        \"\"\"Checks if a given HTTP method should be retried upon, depending if\n        it is included in the allowed_methods\n        \"\"\"\n        # TODO: For now favor if the Retry implementation sets its own method_whitelist\n        # property outside of our constructor to avoid breaking custom implementations.\n        if \"method_whitelist\" in self.__dict__:\n            warnings.warn(\n                \"Using 'method_whitelist' with Retry is deprecated and \"\n                \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                DeprecationWarning,\n            )\n            allowed_methods = self.method_whitelist\n        else:\n            allowed_methods = self.allowed_methods\n\n        if allowed_methods and method.upper() not in allowed_methods:\n            return False\n        return True\n\n    def is_retry(self, method, status_code, has_retry_after=False):\n        \"\"\"Is this method/status code retryable? (Based on allowlists and control\n        variables such as the number of total retries to allow, whether to\n        respect the Retry-After header, whether this header is present, and\n        whether the returned status code is on the list of status codes to\n        be retried upon on the presence of the aforementioned header)\n        \"\"\"\n        if not self._is_method_retryable(method):\n            return False\n\n        if self.status_forcelist and status_code in self.status_forcelist:\n            return True\n\n        return (\n            self.total\n            and self.respect_retry_after_header\n            and has_retry_after\n            and (status_code in self.RETRY_AFTER_STATUS_CODES)\n        )\n\n    def is_exhausted(self):\n        \"\"\"Are we out of retries?\"\"\"\n        retry_counts = (\n            self.total,\n            self.connect,\n            self.read,\n            self.redirect,\n            self.status,\n            self.other,\n        )\n        retry_counts = list(filter(None, retry_counts))\n        if not retry_counts:\n            return False\n\n        return min(retry_counts) &lt; 0\n\n    def increment(\n        self,\n        method=None,\n        url=None,\n        response=None,\n        error=None,\n        _pool=None,\n        _stacktrace=None,\n    ):\n        \"\"\"Return a new Retry object with incremented retry counters.\n\n        :param response: A response object, or None, if the server did not\n            return a response.\n        :type response: :class:`~urllib3.response.HTTPResponse`\n        :param Exception error: An error encountered during the request, or\n            None if the response was received successfully.\n\n        :return: A new ``Retry`` object.\n        \"\"\"\n        if self.total is False and error:\n            # Disabled, indicate to re-raise the error.\n            raise six.reraise(type(error), error, _stacktrace)\n\n        total = self.total\n        if total is not None:\n            total -= 1\n\n        connect = self.connect\n        read = self.read\n        redirect = self.redirect\n        status_count = self.status\n        other = self.other\n        cause = \"unknown\"\n        status = None\n        redirect_location = None\n\n        if error and self._is_connection_error(error):\n            # Connect retry?\n            if connect is False:\n                raise six.reraise(type(error), error, _stacktrace)\n            elif connect is not None:\n                connect -= 1\n\n        elif error and self._is_read_error(error):\n            # Read retry?\n            if read is False or not self._is_method_retryable(method):\n                raise six.reraise(type(error), error, _stacktrace)\n            elif read is not None:\n                read -= 1\n\n        elif error:\n            # Other retry?\n            if other is not None:\n                other -= 1\n\n        elif response and response.get_redirect_location():\n            # Redirect retry?\n            if redirect is not None:\n                redirect -= 1\n            cause = \"too many redirects\"\n            redirect_location = response.get_redirect_location()\n            status = response.status\n\n        else:\n            # Incrementing because of a server error like a 500 in\n            # status_forcelist and the given method is in the allowed_methods\n            cause = ResponseError.GENERIC_ERROR\n            if response and response.status:\n                if status_count is not None:\n                    status_count -= 1\n                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n                status = response.status\n\n        history = self.history + (\n            RequestHistory(method, url, error, status, redirect_location),\n        )\n\n        new_retry = self.new(\n            total=total,\n            connect=connect,\n            read=read,\n            redirect=redirect,\n            status=status_count,\n            other=other,\n            history=history,\n        )\n\n        if new_retry.is_exhausted():\n            raise MaxRetryError(_pool, url, error or ResponseError(cause))\n\n        log.debug(\"Incremented Retry for (url='%s'): %r\", url, new_retry)\n\n        return new_retry\n\n    def __repr__(self):\n        return (\n            \"{cls.__name__}(total={self.total}, connect={self.connect}, \"\n            \"read={self.read}, redirect={self.redirect}, status={self.status})\"\n        ).format(cls=type(self), self=self)\n\n    def __getattr__(self, item):\n        if item == \"method_whitelist\":\n            # TODO: Remove this deprecated alias in v2.0\n            warnings.warn(\n                \"Using 'method_whitelist' with Retry is deprecated and \"\n                \"will be removed in v2.0. Use 'allowed_methods' instead\",\n                DeprecationWarning,\n            )\n            return self.allowed_methods\n        try:\n            return getattr(super(Retry, self), item)\n        except AttributeError:\n            return getattr(Retry, item)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/retry.html#client.ayon_fusion.vendor.urllib3.util.retry.Retry.from_int","title":"<code>from_int(retries, redirect=True, default=None)</code>  <code>classmethod</code>","text":"<p>Backwards-compatibility for the old retries format.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>@classmethod\ndef from_int(cls, retries, redirect=True, default=None):\n    \"\"\"Backwards-compatibility for the old retries format.\"\"\"\n    if retries is None:\n        retries = default if default is not None else cls.DEFAULT\n\n    if isinstance(retries, Retry):\n        return retries\n\n    redirect = bool(redirect) and None\n    new_retries = cls(retries, redirect=redirect)\n    log.debug(\"Converted retries value: %r -&gt; %r\", retries, new_retries)\n    return new_retries\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/retry.html#client.ayon_fusion.vendor.urllib3.util.retry.Retry.get_backoff_time","title":"<code>get_backoff_time()</code>","text":"<p>Formula for computing the current backoff</p> <p>:rtype: float</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def get_backoff_time(self):\n    \"\"\"Formula for computing the current backoff\n\n    :rtype: float\n    \"\"\"\n    # We want to consider only the last consecutive errors sequence (Ignore redirects).\n    consecutive_errors_len = len(\n        list(\n            takewhile(lambda x: x.redirect_location is None, reversed(self.history))\n        )\n    )\n    if consecutive_errors_len &lt;= 1:\n        return 0\n\n    backoff_value = self.backoff_factor * (2 ** (consecutive_errors_len - 1))\n    return min(self.BACKOFF_MAX, backoff_value)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/retry.html#client.ayon_fusion.vendor.urllib3.util.retry.Retry.get_retry_after","title":"<code>get_retry_after(response)</code>","text":"<p>Get the value of Retry-After in seconds.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def get_retry_after(self, response):\n    \"\"\"Get the value of Retry-After in seconds.\"\"\"\n\n    retry_after = response.getheader(\"Retry-After\")\n\n    if retry_after is None:\n        return None\n\n    return self.parse_retry_after(retry_after)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/retry.html#client.ayon_fusion.vendor.urllib3.util.retry.Retry.increment","title":"<code>increment(method=None, url=None, response=None, error=None, _pool=None, _stacktrace=None)</code>","text":"<p>Return a new Retry object with incremented retry counters.</p> <p>:param response: A response object, or None, if the server did not     return a response. :type response: :class:<code>~urllib3.response.HTTPResponse</code> :param Exception error: An error encountered during the request, or     None if the response was received successfully.</p> <p>:return: A new <code>Retry</code> object.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def increment(\n    self,\n    method=None,\n    url=None,\n    response=None,\n    error=None,\n    _pool=None,\n    _stacktrace=None,\n):\n    \"\"\"Return a new Retry object with incremented retry counters.\n\n    :param response: A response object, or None, if the server did not\n        return a response.\n    :type response: :class:`~urllib3.response.HTTPResponse`\n    :param Exception error: An error encountered during the request, or\n        None if the response was received successfully.\n\n    :return: A new ``Retry`` object.\n    \"\"\"\n    if self.total is False and error:\n        # Disabled, indicate to re-raise the error.\n        raise six.reraise(type(error), error, _stacktrace)\n\n    total = self.total\n    if total is not None:\n        total -= 1\n\n    connect = self.connect\n    read = self.read\n    redirect = self.redirect\n    status_count = self.status\n    other = self.other\n    cause = \"unknown\"\n    status = None\n    redirect_location = None\n\n    if error and self._is_connection_error(error):\n        # Connect retry?\n        if connect is False:\n            raise six.reraise(type(error), error, _stacktrace)\n        elif connect is not None:\n            connect -= 1\n\n    elif error and self._is_read_error(error):\n        # Read retry?\n        if read is False or not self._is_method_retryable(method):\n            raise six.reraise(type(error), error, _stacktrace)\n        elif read is not None:\n            read -= 1\n\n    elif error:\n        # Other retry?\n        if other is not None:\n            other -= 1\n\n    elif response and response.get_redirect_location():\n        # Redirect retry?\n        if redirect is not None:\n            redirect -= 1\n        cause = \"too many redirects\"\n        redirect_location = response.get_redirect_location()\n        status = response.status\n\n    else:\n        # Incrementing because of a server error like a 500 in\n        # status_forcelist and the given method is in the allowed_methods\n        cause = ResponseError.GENERIC_ERROR\n        if response and response.status:\n            if status_count is not None:\n                status_count -= 1\n            cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)\n            status = response.status\n\n    history = self.history + (\n        RequestHistory(method, url, error, status, redirect_location),\n    )\n\n    new_retry = self.new(\n        total=total,\n        connect=connect,\n        read=read,\n        redirect=redirect,\n        status=status_count,\n        other=other,\n        history=history,\n    )\n\n    if new_retry.is_exhausted():\n        raise MaxRetryError(_pool, url, error or ResponseError(cause))\n\n    log.debug(\"Incremented Retry for (url='%s'): %r\", url, new_retry)\n\n    return new_retry\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/retry.html#client.ayon_fusion.vendor.urllib3.util.retry.Retry.is_exhausted","title":"<code>is_exhausted()</code>","text":"<p>Are we out of retries?</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def is_exhausted(self):\n    \"\"\"Are we out of retries?\"\"\"\n    retry_counts = (\n        self.total,\n        self.connect,\n        self.read,\n        self.redirect,\n        self.status,\n        self.other,\n    )\n    retry_counts = list(filter(None, retry_counts))\n    if not retry_counts:\n        return False\n\n    return min(retry_counts) &lt; 0\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/retry.html#client.ayon_fusion.vendor.urllib3.util.retry.Retry.is_retry","title":"<code>is_retry(method, status_code, has_retry_after=False)</code>","text":"<p>Is this method/status code retryable? (Based on allowlists and control variables such as the number of total retries to allow, whether to respect the Retry-After header, whether this header is present, and whether the returned status code is on the list of status codes to be retried upon on the presence of the aforementioned header)</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def is_retry(self, method, status_code, has_retry_after=False):\n    \"\"\"Is this method/status code retryable? (Based on allowlists and control\n    variables such as the number of total retries to allow, whether to\n    respect the Retry-After header, whether this header is present, and\n    whether the returned status code is on the list of status codes to\n    be retried upon on the presence of the aforementioned header)\n    \"\"\"\n    if not self._is_method_retryable(method):\n        return False\n\n    if self.status_forcelist and status_code in self.status_forcelist:\n        return True\n\n    return (\n        self.total\n        and self.respect_retry_after_header\n        and has_retry_after\n        and (status_code in self.RETRY_AFTER_STATUS_CODES)\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/retry.html#client.ayon_fusion.vendor.urllib3.util.retry.Retry.sleep","title":"<code>sleep(response=None)</code>","text":"<p>Sleep between retry attempts.</p> <p>This method will respect a server's <code>Retry-After</code> response header and sleep the duration of the time requested. If that is not present, it will use an exponential backoff. By default, the backoff factor is 0 and this method will return immediately.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/retry.py</code> <pre><code>def sleep(self, response=None):\n    \"\"\"Sleep between retry attempts.\n\n    This method will respect a server's ``Retry-After`` response header\n    and sleep the duration of the time requested. If that is not present, it\n    will use an exponential backoff. By default, the backoff factor is 0 and\n    this method will return immediately.\n    \"\"\"\n\n    if self.respect_retry_after_header and response:\n        slept = self.sleep_for_retry(response)\n        if slept:\n            return\n\n    self._sleep_backoff()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssl_.html","title":"ssl_","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssl_.html#client.ayon_fusion.vendor.urllib3.util.ssl_.assert_fingerprint","title":"<code>assert_fingerprint(cert, fingerprint)</code>","text":"<p>Checks if given fingerprint matches the supplied certificate.</p> <p>:param cert:     Certificate as bytes object. :param fingerprint:     Fingerprint as string of hexdigits, can be interspersed by colons.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def assert_fingerprint(cert, fingerprint):\n    \"\"\"\n    Checks if given fingerprint matches the supplied certificate.\n\n    :param cert:\n        Certificate as bytes object.\n    :param fingerprint:\n        Fingerprint as string of hexdigits, can be interspersed by colons.\n    \"\"\"\n\n    fingerprint = fingerprint.replace(\":\", \"\").lower()\n    digest_length = len(fingerprint)\n    hashfunc = HASHFUNC_MAP.get(digest_length)\n    if not hashfunc:\n        raise SSLError(\"Fingerprint of invalid length: {0}\".format(fingerprint))\n\n    # We need encode() here for py32; works on py2 and p33.\n    fingerprint_bytes = unhexlify(fingerprint.encode())\n\n    cert_digest = hashfunc(cert).digest()\n\n    if not _const_compare_digest(cert_digest, fingerprint_bytes):\n        raise SSLError(\n            'Fingerprints did not match. Expected \"{0}\", got \"{1}\".'.format(\n                fingerprint, hexlify(cert_digest)\n            )\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssl_.html#client.ayon_fusion.vendor.urllib3.util.ssl_.create_urllib3_context","title":"<code>create_urllib3_context(ssl_version=None, cert_reqs=None, options=None, ciphers=None)</code>","text":"<p>All arguments have the same meaning as <code>ssl_wrap_socket</code>.</p> <p>By default, this function does a lot of the same work that <code>ssl.create_default_context</code> does on Python 3.4+. It:</p> <ul> <li>Disables SSLv2, SSLv3, and compression</li> <li>Sets a restricted set of server ciphers</li> </ul> <p>If you wish to enable SSLv3, you can do::</p> <pre><code>from urllib3.util import ssl_\ncontext = ssl_.create_urllib3_context()\ncontext.options &amp;= ~ssl_.OP_NO_SSLv3\n</code></pre> <p>You can do the same to enable compression (substituting <code>COMPRESSION</code> for <code>SSLv3</code> in the last line above).</p> <p>:param ssl_version:     The desired protocol version to use. This will default to     PROTOCOL_SSLv23 which will negotiate the highest protocol that both     the server and your installation of OpenSSL support. :param cert_reqs:     Whether to require the certificate verification. This defaults to     <code>ssl.CERT_REQUIRED</code>. :param options:     Specific OpenSSL options. These default to <code>ssl.OP_NO_SSLv2</code>,     <code>ssl.OP_NO_SSLv3</code>, <code>ssl.OP_NO_COMPRESSION</code>, and <code>ssl.OP_NO_TICKET</code>. :param ciphers:     Which cipher suites to allow the server to select. :returns:     Constructed SSLContext object with specified options :rtype: SSLContext</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def create_urllib3_context(\n    ssl_version=None, cert_reqs=None, options=None, ciphers=None\n):\n    \"\"\"All arguments have the same meaning as ``ssl_wrap_socket``.\n\n    By default, this function does a lot of the same work that\n    ``ssl.create_default_context`` does on Python 3.4+. It:\n\n    - Disables SSLv2, SSLv3, and compression\n    - Sets a restricted set of server ciphers\n\n    If you wish to enable SSLv3, you can do::\n\n        from urllib3.util import ssl_\n        context = ssl_.create_urllib3_context()\n        context.options &amp;= ~ssl_.OP_NO_SSLv3\n\n    You can do the same to enable compression (substituting ``COMPRESSION``\n    for ``SSLv3`` in the last line above).\n\n    :param ssl_version:\n        The desired protocol version to use. This will default to\n        PROTOCOL_SSLv23 which will negotiate the highest protocol that both\n        the server and your installation of OpenSSL support.\n    :param cert_reqs:\n        Whether to require the certificate verification. This defaults to\n        ``ssl.CERT_REQUIRED``.\n    :param options:\n        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,\n        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``, and ``ssl.OP_NO_TICKET``.\n    :param ciphers:\n        Which cipher suites to allow the server to select.\n    :returns:\n        Constructed SSLContext object with specified options\n    :rtype: SSLContext\n    \"\"\"\n    # PROTOCOL_TLS is deprecated in Python 3.10\n    if not ssl_version or ssl_version == PROTOCOL_TLS:\n        ssl_version = PROTOCOL_TLS_CLIENT\n\n    context = SSLContext(ssl_version)\n\n    context.set_ciphers(ciphers or DEFAULT_CIPHERS)\n\n    # Setting the default here, as we may have no ssl module on import\n    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs\n\n    if options is None:\n        options = 0\n        # SSLv2 is easily broken and is considered harmful and dangerous\n        options |= OP_NO_SSLv2\n        # SSLv3 has several problems and is now dangerous\n        options |= OP_NO_SSLv3\n        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+\n        # (issue #309)\n        options |= OP_NO_COMPRESSION\n        # TLSv1.2 only. Unless set explicitly, do not request tickets.\n        # This may save some bandwidth on wire, and although the ticket is encrypted,\n        # there is a risk associated with it being on wire,\n        # if the server is not rotating its ticketing keys properly.\n        options |= OP_NO_TICKET\n\n    context.options |= options\n\n    # Enable post-handshake authentication for TLS 1.3, see GH #1634. PHA is\n    # necessary for conditional client cert authentication with TLS 1.3.\n    # The attribute is None for OpenSSL &lt;= 1.1.0 or does not exist in older\n    # versions of Python.  We only enable on Python 3.7.4+ or if certificate\n    # verification is enabled to work around Python issue #37428\n    # See: https://bugs.python.org/issue37428\n    if (cert_reqs == ssl.CERT_REQUIRED or sys.version_info &gt;= (3, 7, 4)) and getattr(\n        context, \"post_handshake_auth\", None\n    ) is not None:\n        context.post_handshake_auth = True\n\n    def disable_check_hostname():\n        if (\n            getattr(context, \"check_hostname\", None) is not None\n        ):  # Platform-specific: Python 3.2\n            # We do our own verification, including fingerprints and alternative\n            # hostnames. So disable it here\n            context.check_hostname = False\n\n    # The order of the below lines setting verify_mode and check_hostname\n    # matter due to safe-guards SSLContext has to prevent an SSLContext with\n    # check_hostname=True, verify_mode=NONE/OPTIONAL. This is made even more\n    # complex because we don't know whether PROTOCOL_TLS_CLIENT will be used\n    # or not so we don't know the initial state of the freshly created SSLContext.\n    if cert_reqs == ssl.CERT_REQUIRED:\n        context.verify_mode = cert_reqs\n        disable_check_hostname()\n    else:\n        disable_check_hostname()\n        context.verify_mode = cert_reqs\n\n    # Enable logging of TLS session keys via defacto standard environment variable\n    # 'SSLKEYLOGFILE', if the feature is available (Python 3.8+). Skip empty values.\n    if hasattr(context, \"keylog_filename\"):\n        sslkeylogfile = os.environ.get(\"SSLKEYLOGFILE\")\n        if sslkeylogfile:\n            context.keylog_filename = sslkeylogfile\n\n    return context\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssl_.html#client.ayon_fusion.vendor.urllib3.util.ssl_.is_ipaddress","title":"<code>is_ipaddress(hostname)</code>","text":"<p>Detects whether the hostname given is an IPv4 or IPv6 address. Also detects IPv6 addresses with Zone IDs.</p> <p>:param str hostname: Hostname to examine. :return: True if the hostname is an IP address, False otherwise.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def is_ipaddress(hostname):\n    \"\"\"Detects whether the hostname given is an IPv4 or IPv6 address.\n    Also detects IPv6 addresses with Zone IDs.\n\n    :param str hostname: Hostname to examine.\n    :return: True if the hostname is an IP address, False otherwise.\n    \"\"\"\n    if not six.PY2 and isinstance(hostname, bytes):\n        # IDN A-label bytes are ASCII compatible.\n        hostname = hostname.decode(\"ascii\")\n    return bool(IPV4_RE.match(hostname) or BRACELESS_IPV6_ADDRZ_RE.match(hostname))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssl_.html#client.ayon_fusion.vendor.urllib3.util.ssl_.resolve_cert_reqs","title":"<code>resolve_cert_reqs(candidate)</code>","text":"<p>Resolves the argument to a numeric constant, which can be passed to the wrap_socket function/method from the ssl module. Defaults to :data:<code>ssl.CERT_REQUIRED</code>. If given a string it is assumed to be the name of the constant in the :mod:<code>ssl</code> module or its abbreviation. (So you can specify <code>REQUIRED</code> instead of <code>CERT_REQUIRED</code>. If it's neither <code>None</code> nor a string we assume it is already the numeric constant which can directly be passed to wrap_socket.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def resolve_cert_reqs(candidate):\n    \"\"\"\n    Resolves the argument to a numeric constant, which can be passed to\n    the wrap_socket function/method from the ssl module.\n    Defaults to :data:`ssl.CERT_REQUIRED`.\n    If given a string it is assumed to be the name of the constant in the\n    :mod:`ssl` module or its abbreviation.\n    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.\n    If it's neither `None` nor a string we assume it is already the numeric\n    constant which can directly be passed to wrap_socket.\n    \"\"\"\n    if candidate is None:\n        return CERT_REQUIRED\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"CERT_\" + candidate)\n        return res\n\n    return candidate\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssl_.html#client.ayon_fusion.vendor.urllib3.util.ssl_.resolve_ssl_version","title":"<code>resolve_ssl_version(candidate)</code>","text":"<p>like resolve_cert_reqs</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def resolve_ssl_version(candidate):\n    \"\"\"\n    like resolve_cert_reqs\n    \"\"\"\n    if candidate is None:\n        return PROTOCOL_TLS\n\n    if isinstance(candidate, str):\n        res = getattr(ssl, candidate, None)\n        if res is None:\n            res = getattr(ssl, \"PROTOCOL_\" + candidate)\n        return res\n\n    return candidate\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssl_.html#client.ayon_fusion.vendor.urllib3.util.ssl_.ssl_wrap_socket","title":"<code>ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None, ca_certs=None, server_hostname=None, ssl_version=None, ciphers=None, ssl_context=None, ca_cert_dir=None, key_password=None, ca_cert_data=None, tls_in_tls=False)</code>","text":"<p>All arguments except for server_hostname, ssl_context, and ca_cert_dir have the same meaning as they do when using :func:<code>ssl.wrap_socket</code>.</p> <p>:param server_hostname:     When SNI is supported, the expected hostname of the certificate :param ssl_context:     A pre-made :class:<code>SSLContext</code> object. If none is provided, one will     be created using :func:<code>create_urllib3_context</code>. :param ciphers:     A string of ciphers we wish the client to support. :param ca_cert_dir:     A directory containing CA certificates in multiple separate files, as     supported by OpenSSL's -CApath flag or the capath argument to     SSLContext.load_verify_locations(). :param key_password:     Optional password if the keyfile is encrypted. :param ca_cert_data:     Optional string containing CA certificates in PEM format suitable for     passing as the cadata parameter to SSLContext.load_verify_locations() :param tls_in_tls:     Use SSLTransport to wrap the existing socket.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssl_.py</code> <pre><code>def ssl_wrap_socket(\n    sock,\n    keyfile=None,\n    certfile=None,\n    cert_reqs=None,\n    ca_certs=None,\n    server_hostname=None,\n    ssl_version=None,\n    ciphers=None,\n    ssl_context=None,\n    ca_cert_dir=None,\n    key_password=None,\n    ca_cert_data=None,\n    tls_in_tls=False,\n):\n    \"\"\"\n    All arguments except for server_hostname, ssl_context, and ca_cert_dir have\n    the same meaning as they do when using :func:`ssl.wrap_socket`.\n\n    :param server_hostname:\n        When SNI is supported, the expected hostname of the certificate\n    :param ssl_context:\n        A pre-made :class:`SSLContext` object. If none is provided, one will\n        be created using :func:`create_urllib3_context`.\n    :param ciphers:\n        A string of ciphers we wish the client to support.\n    :param ca_cert_dir:\n        A directory containing CA certificates in multiple separate files, as\n        supported by OpenSSL's -CApath flag or the capath argument to\n        SSLContext.load_verify_locations().\n    :param key_password:\n        Optional password if the keyfile is encrypted.\n    :param ca_cert_data:\n        Optional string containing CA certificates in PEM format suitable for\n        passing as the cadata parameter to SSLContext.load_verify_locations()\n    :param tls_in_tls:\n        Use SSLTransport to wrap the existing socket.\n    \"\"\"\n    context = ssl_context\n    if context is None:\n        # Note: This branch of code and all the variables in it are no longer\n        # used by urllib3 itself. We should consider deprecating and removing\n        # this code.\n        context = create_urllib3_context(ssl_version, cert_reqs, ciphers=ciphers)\n\n    if ca_certs or ca_cert_dir or ca_cert_data:\n        try:\n            context.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)\n        except (IOError, OSError) as e:\n            raise SSLError(e)\n\n    elif ssl_context is None and hasattr(context, \"load_default_certs\"):\n        # try to load OS default certs; works well on Windows (require Python3.4+)\n        context.load_default_certs()\n\n    # Attempt to detect if we get the goofy behavior of the\n    # keyfile being encrypted and OpenSSL asking for the\n    # passphrase via the terminal and instead error out.\n    if keyfile and key_password is None and _is_key_file_encrypted(keyfile):\n        raise SSLError(\"Client private key is encrypted, password is required\")\n\n    if certfile:\n        if key_password is None:\n            context.load_cert_chain(certfile, keyfile)\n        else:\n            context.load_cert_chain(certfile, keyfile, key_password)\n\n    try:\n        if hasattr(context, \"set_alpn_protocols\"):\n            context.set_alpn_protocols(ALPN_PROTOCOLS)\n    except NotImplementedError:  # Defensive: in CI, we always have set_alpn_protocols\n        pass\n\n    # If we detect server_hostname is an IP address then the SNI\n    # extension should not be used according to RFC3546 Section 3.1\n    use_sni_hostname = server_hostname and not is_ipaddress(server_hostname)\n    # SecureTransport uses server_hostname in certificate verification.\n    send_sni = (use_sni_hostname and HAS_SNI) or (\n        IS_SECURETRANSPORT and server_hostname\n    )\n    # Do not warn the user if server_hostname is an invalid SNI hostname.\n    if not HAS_SNI and use_sni_hostname:\n        warnings.warn(\n            \"An HTTPS request has been made, but the SNI (Server Name \"\n            \"Indication) extension to TLS is not available on this platform. \"\n            \"This may cause the server to present an incorrect TLS \"\n            \"certificate, which can cause validation failures. You can upgrade to \"\n            \"a newer version of Python to solve this. For more information, see \"\n            \"https://urllib3.readthedocs.io/en/1.26.x/advanced-usage.html\"\n            \"#ssl-warnings\",\n            SNIMissingWarning,\n        )\n\n    if send_sni:\n        ssl_sock = _ssl_wrap_socket_impl(\n            sock, context, tls_in_tls, server_hostname=server_hostname\n        )\n    else:\n        ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls)\n    return ssl_sock\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssltransport.html","title":"ssltransport","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssltransport.html#client.ayon_fusion.vendor.urllib3.util.ssltransport.SSLTransport","title":"<code>SSLTransport</code>","text":"<p>The SSLTransport wraps an existing socket and establishes an SSL connection.</p> <p>Contrary to Python's implementation of SSLSocket, it allows you to chain multiple TLS connections together. It's particularly useful if you need to implement TLS within TLS.</p> <p>The class supports most of the socket API operations.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssltransport.py</code> <pre><code>class SSLTransport:\n    \"\"\"\n    The SSLTransport wraps an existing socket and establishes an SSL connection.\n\n    Contrary to Python's implementation of SSLSocket, it allows you to chain\n    multiple TLS connections together. It's particularly useful if you need to\n    implement TLS within TLS.\n\n    The class supports most of the socket API operations.\n    \"\"\"\n\n    @staticmethod\n    def _validate_ssl_context_for_tls_in_tls(ssl_context):\n        \"\"\"\n        Raises a ProxySchemeUnsupported if the provided ssl_context can't be used\n        for TLS in TLS.\n\n        The only requirement is that the ssl_context provides the 'wrap_bio'\n        methods.\n        \"\"\"\n\n        if not hasattr(ssl_context, \"wrap_bio\"):\n            if six.PY2:\n                raise ProxySchemeUnsupported(\n                    \"TLS in TLS requires SSLContext.wrap_bio() which isn't \"\n                    \"supported on Python 2\"\n                )\n            else:\n                raise ProxySchemeUnsupported(\n                    \"TLS in TLS requires SSLContext.wrap_bio() which isn't \"\n                    \"available on non-native SSLContext\"\n                )\n\n    def __init__(\n        self, socket, ssl_context, server_hostname=None, suppress_ragged_eofs=True\n    ):\n        \"\"\"\n        Create an SSLTransport around socket using the provided ssl_context.\n        \"\"\"\n        self.incoming = ssl.MemoryBIO()\n        self.outgoing = ssl.MemoryBIO()\n\n        self.suppress_ragged_eofs = suppress_ragged_eofs\n        self.socket = socket\n\n        self.sslobj = ssl_context.wrap_bio(\n            self.incoming, self.outgoing, server_hostname=server_hostname\n        )\n\n        # Perform initial handshake.\n        self._ssl_io_loop(self.sslobj.do_handshake)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *_):\n        self.close()\n\n    def fileno(self):\n        return self.socket.fileno()\n\n    def read(self, len=1024, buffer=None):\n        return self._wrap_ssl_read(len, buffer)\n\n    def recv(self, len=1024, flags=0):\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to recv\")\n        return self._wrap_ssl_read(len)\n\n    def recv_into(self, buffer, nbytes=None, flags=0):\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to recv_into\")\n        if buffer and (nbytes is None):\n            nbytes = len(buffer)\n        elif nbytes is None:\n            nbytes = 1024\n        return self.read(nbytes, buffer)\n\n    def sendall(self, data, flags=0):\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to sendall\")\n        count = 0\n        with memoryview(data) as view, view.cast(\"B\") as byte_view:\n            amount = len(byte_view)\n            while count &lt; amount:\n                v = self.send(byte_view[count:])\n                count += v\n\n    def send(self, data, flags=0):\n        if flags != 0:\n            raise ValueError(\"non-zero flags not allowed in calls to send\")\n        response = self._ssl_io_loop(self.sslobj.write, data)\n        return response\n\n    def makefile(\n        self, mode=\"r\", buffering=None, encoding=None, errors=None, newline=None\n    ):\n        \"\"\"\n        Python's httpclient uses makefile and buffered io when reading HTTP\n        messages and we need to support it.\n\n        This is unfortunately a copy and paste of socket.py makefile with small\n        changes to point to the socket directly.\n        \"\"\"\n        if not set(mode) &lt;= {\"r\", \"w\", \"b\"}:\n            raise ValueError(\"invalid mode %r (only r, w, b allowed)\" % (mode,))\n\n        writing = \"w\" in mode\n        reading = \"r\" in mode or not writing\n        assert reading or writing\n        binary = \"b\" in mode\n        rawmode = \"\"\n        if reading:\n            rawmode += \"r\"\n        if writing:\n            rawmode += \"w\"\n        raw = socket.SocketIO(self, rawmode)\n        self.socket._io_refs += 1\n        if buffering is None:\n            buffering = -1\n        if buffering &lt; 0:\n            buffering = io.DEFAULT_BUFFER_SIZE\n        if buffering == 0:\n            if not binary:\n                raise ValueError(\"unbuffered streams must be binary\")\n            return raw\n        if reading and writing:\n            buffer = io.BufferedRWPair(raw, raw, buffering)\n        elif reading:\n            buffer = io.BufferedReader(raw, buffering)\n        else:\n            assert writing\n            buffer = io.BufferedWriter(raw, buffering)\n        if binary:\n            return buffer\n        text = io.TextIOWrapper(buffer, encoding, errors, newline)\n        text.mode = mode\n        return text\n\n    def unwrap(self):\n        self._ssl_io_loop(self.sslobj.unwrap)\n\n    def close(self):\n        self.socket.close()\n\n    def getpeercert(self, binary_form=False):\n        return self.sslobj.getpeercert(binary_form)\n\n    def version(self):\n        return self.sslobj.version()\n\n    def cipher(self):\n        return self.sslobj.cipher()\n\n    def selected_alpn_protocol(self):\n        return self.sslobj.selected_alpn_protocol()\n\n    def selected_npn_protocol(self):\n        return self.sslobj.selected_npn_protocol()\n\n    def shared_ciphers(self):\n        return self.sslobj.shared_ciphers()\n\n    def compression(self):\n        return self.sslobj.compression()\n\n    def settimeout(self, value):\n        self.socket.settimeout(value)\n\n    def gettimeout(self):\n        return self.socket.gettimeout()\n\n    def _decref_socketios(self):\n        self.socket._decref_socketios()\n\n    def _wrap_ssl_read(self, len, buffer=None):\n        try:\n            return self._ssl_io_loop(self.sslobj.read, len, buffer)\n        except ssl.SSLError as e:\n            if e.errno == ssl.SSL_ERROR_EOF and self.suppress_ragged_eofs:\n                return 0  # eof, return 0.\n            else:\n                raise\n\n    def _ssl_io_loop(self, func, *args):\n        \"\"\"Performs an I/O loop between incoming/outgoing and the socket.\"\"\"\n        should_loop = True\n        ret = None\n\n        while should_loop:\n            errno = None\n            try:\n                ret = func(*args)\n            except ssl.SSLError as e:\n                if e.errno not in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_WANT_WRITE):\n                    # WANT_READ, and WANT_WRITE are expected, others are not.\n                    raise e\n                errno = e.errno\n\n            buf = self.outgoing.read()\n            self.socket.sendall(buf)\n\n            if errno is None:\n                should_loop = False\n            elif errno == ssl.SSL_ERROR_WANT_READ:\n                buf = self.socket.recv(SSL_BLOCKSIZE)\n                if buf:\n                    self.incoming.write(buf)\n                else:\n                    self.incoming.write_eof()\n        return ret\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssltransport.html#client.ayon_fusion.vendor.urllib3.util.ssltransport.SSLTransport.__init__","title":"<code>__init__(socket, ssl_context, server_hostname=None, suppress_ragged_eofs=True)</code>","text":"<p>Create an SSLTransport around socket using the provided ssl_context.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssltransport.py</code> <pre><code>def __init__(\n    self, socket, ssl_context, server_hostname=None, suppress_ragged_eofs=True\n):\n    \"\"\"\n    Create an SSLTransport around socket using the provided ssl_context.\n    \"\"\"\n    self.incoming = ssl.MemoryBIO()\n    self.outgoing = ssl.MemoryBIO()\n\n    self.suppress_ragged_eofs = suppress_ragged_eofs\n    self.socket = socket\n\n    self.sslobj = ssl_context.wrap_bio(\n        self.incoming, self.outgoing, server_hostname=server_hostname\n    )\n\n    # Perform initial handshake.\n    self._ssl_io_loop(self.sslobj.do_handshake)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/ssltransport.html#client.ayon_fusion.vendor.urllib3.util.ssltransport.SSLTransport.makefile","title":"<code>makefile(mode='r', buffering=None, encoding=None, errors=None, newline=None)</code>","text":"<p>Python's httpclient uses makefile and buffered io when reading HTTP messages and we need to support it.</p> <p>This is unfortunately a copy and paste of socket.py makefile with small changes to point to the socket directly.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/ssltransport.py</code> <pre><code>def makefile(\n    self, mode=\"r\", buffering=None, encoding=None, errors=None, newline=None\n):\n    \"\"\"\n    Python's httpclient uses makefile and buffered io when reading HTTP\n    messages and we need to support it.\n\n    This is unfortunately a copy and paste of socket.py makefile with small\n    changes to point to the socket directly.\n    \"\"\"\n    if not set(mode) &lt;= {\"r\", \"w\", \"b\"}:\n        raise ValueError(\"invalid mode %r (only r, w, b allowed)\" % (mode,))\n\n    writing = \"w\" in mode\n    reading = \"r\" in mode or not writing\n    assert reading or writing\n    binary = \"b\" in mode\n    rawmode = \"\"\n    if reading:\n        rawmode += \"r\"\n    if writing:\n        rawmode += \"w\"\n    raw = socket.SocketIO(self, rawmode)\n    self.socket._io_refs += 1\n    if buffering is None:\n        buffering = -1\n    if buffering &lt; 0:\n        buffering = io.DEFAULT_BUFFER_SIZE\n    if buffering == 0:\n        if not binary:\n            raise ValueError(\"unbuffered streams must be binary\")\n        return raw\n    if reading and writing:\n        buffer = io.BufferedRWPair(raw, raw, buffering)\n    elif reading:\n        buffer = io.BufferedReader(raw, buffering)\n    else:\n        assert writing\n        buffer = io.BufferedWriter(raw, buffering)\n    if binary:\n        return buffer\n    text = io.TextIOWrapper(buffer, encoding, errors, newline)\n    text.mode = mode\n    return text\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/timeout.html","title":"timeout","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/timeout.html#client.ayon_fusion.vendor.urllib3.util.timeout.Timeout","title":"<code>Timeout</code>","text":"<p>               Bases: <code>object</code></p> <p>Timeout configuration.</p> <p>Timeouts can be defined as a default for a pool:</p> <p>.. code-block:: python</p> <p>timeout = Timeout(connect=2.0, read=7.0)    http = PoolManager(timeout=timeout)    response = http.request('GET', 'http://example.com/')</p> <p>Or per-request (which overrides the default for the pool):</p> <p>.. code-block:: python</p> <p>response = http.request('GET', 'http://example.com/', timeout=Timeout(10))</p> <p>Timeouts can be disabled by setting all the parameters to <code>None</code>:</p> <p>.. code-block:: python</p> <p>no_timeout = Timeout(connect=None, read=None)    response = http.request('GET', 'http://example.com/, timeout=no_timeout)</p> <p>:param total:     This combines the connect and read timeouts into one; the read timeout     will be set to the time leftover from the connect attempt. In the     event that both a connect timeout and a total are specified, or a read     timeout and a total are specified, the shorter timeout will be applied.</p> <pre><code>Defaults to None.\n</code></pre> <p>:type total: int, float, or None</p> <p>:param connect:     The maximum amount of time (in seconds) to wait for a connection     attempt to a server to succeed. Omitting the parameter will default the     connect timeout to the system default, probably <code>the global default     timeout in socket.py     &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;</code>_.     None will set an infinite timeout for connection attempts.</p> <p>:type connect: int, float, or None</p> <p>:param read:     The maximum amount of time (in seconds) to wait between consecutive     read operations for a response from the server. Omitting the parameter     will default the read timeout to the system default, probably <code>the     global default timeout in socket.py     &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;</code>_.     None will set an infinite timeout.</p> <p>:type read: int, float, or None</p> <p>.. note::</p> <pre><code>Many factors can affect the total amount of time for urllib3 to return\nan HTTP response.\n\nFor example, Python's DNS resolver does not obey the timeout specified\non the socket. Other factors that can affect total request time include\nhigh CPU load, high swap, the program running at a low priority level,\nor other behaviors.\n\nIn addition, the read and total timeouts only measure the time between\nread operations on the socket connecting the client and the server,\nnot the total amount of time for the request to return a complete\nresponse. For most requests, the timeout is raised because the server\nhas not sent the first byte in the specified time. This is not always\nthe case; if a server streams one byte every fifteen seconds, a timeout\nof 20 seconds will not trigger, even though the request will take\nseveral minutes to complete.\n\nIf your goal is to cut off any request after a set amount of wall clock\ntime, consider having a second \"watcher\" thread to cut off a slow\nrequest.\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>class Timeout(object):\n    \"\"\"Timeout configuration.\n\n    Timeouts can be defined as a default for a pool:\n\n    .. code-block:: python\n\n       timeout = Timeout(connect=2.0, read=7.0)\n       http = PoolManager(timeout=timeout)\n       response = http.request('GET', 'http://example.com/')\n\n    Or per-request (which overrides the default for the pool):\n\n    .. code-block:: python\n\n       response = http.request('GET', 'http://example.com/', timeout=Timeout(10))\n\n    Timeouts can be disabled by setting all the parameters to ``None``:\n\n    .. code-block:: python\n\n       no_timeout = Timeout(connect=None, read=None)\n       response = http.request('GET', 'http://example.com/, timeout=no_timeout)\n\n\n    :param total:\n        This combines the connect and read timeouts into one; the read timeout\n        will be set to the time leftover from the connect attempt. In the\n        event that both a connect timeout and a total are specified, or a read\n        timeout and a total are specified, the shorter timeout will be applied.\n\n        Defaults to None.\n\n    :type total: int, float, or None\n\n    :param connect:\n        The maximum amount of time (in seconds) to wait for a connection\n        attempt to a server to succeed. Omitting the parameter will default the\n        connect timeout to the system default, probably `the global default\n        timeout in socket.py\n        &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;`_.\n        None will set an infinite timeout for connection attempts.\n\n    :type connect: int, float, or None\n\n    :param read:\n        The maximum amount of time (in seconds) to wait between consecutive\n        read operations for a response from the server. Omitting the parameter\n        will default the read timeout to the system default, probably `the\n        global default timeout in socket.py\n        &lt;http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535&gt;`_.\n        None will set an infinite timeout.\n\n    :type read: int, float, or None\n\n    .. note::\n\n        Many factors can affect the total amount of time for urllib3 to return\n        an HTTP response.\n\n        For example, Python's DNS resolver does not obey the timeout specified\n        on the socket. Other factors that can affect total request time include\n        high CPU load, high swap, the program running at a low priority level,\n        or other behaviors.\n\n        In addition, the read and total timeouts only measure the time between\n        read operations on the socket connecting the client and the server,\n        not the total amount of time for the request to return a complete\n        response. For most requests, the timeout is raised because the server\n        has not sent the first byte in the specified time. This is not always\n        the case; if a server streams one byte every fifteen seconds, a timeout\n        of 20 seconds will not trigger, even though the request will take\n        several minutes to complete.\n\n        If your goal is to cut off any request after a set amount of wall clock\n        time, consider having a second \"watcher\" thread to cut off a slow\n        request.\n    \"\"\"\n\n    #: A sentinel object representing the default timeout value\n    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT\n\n    def __init__(self, total=None, connect=_Default, read=_Default):\n        self._connect = self._validate_timeout(connect, \"connect\")\n        self._read = self._validate_timeout(read, \"read\")\n        self.total = self._validate_timeout(total, \"total\")\n        self._start_connect = None\n\n    def __repr__(self):\n        return \"%s(connect=%r, read=%r, total=%r)\" % (\n            type(self).__name__,\n            self._connect,\n            self._read,\n            self.total,\n        )\n\n    # __str__ provided for backwards compatibility\n    __str__ = __repr__\n\n    @classmethod\n    def _validate_timeout(cls, value, name):\n        \"\"\"Check that a timeout attribute is valid.\n\n        :param value: The timeout value to validate\n        :param name: The name of the timeout attribute to validate. This is\n            used to specify in error messages.\n        :return: The validated and casted version of the given value.\n        :raises ValueError: If it is a numeric value less than or equal to\n            zero, or the type is not an integer, float, or None.\n        \"\"\"\n        if value is _Default:\n            return cls.DEFAULT_TIMEOUT\n\n        if value is None or value is cls.DEFAULT_TIMEOUT:\n            return value\n\n        if isinstance(value, bool):\n            raise ValueError(\n                \"Timeout cannot be a boolean value. It must \"\n                \"be an int, float or None.\"\n            )\n        try:\n            float(value)\n        except (TypeError, ValueError):\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            )\n\n        try:\n            if value &lt;= 0:\n                raise ValueError(\n                    \"Attempted to set %s timeout to %s, but the \"\n                    \"timeout cannot be set to a value less \"\n                    \"than or equal to 0.\" % (name, value)\n                )\n        except TypeError:\n            # Python 3\n            raise ValueError(\n                \"Timeout value %s was %s, but it must be an \"\n                \"int, float or None.\" % (name, value)\n            )\n\n        return value\n\n    @classmethod\n    def from_float(cls, timeout):\n        \"\"\"Create a new Timeout from a legacy timeout value.\n\n        The timeout value used by httplib.py sets the same timeout on the\n        connect(), and recv() socket requests. This creates a :class:`Timeout`\n        object that sets the individual timeouts to the ``timeout`` value\n        passed to this function.\n\n        :param timeout: The legacy timeout value.\n        :type timeout: integer, float, sentinel default object, or None\n        :return: Timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        return Timeout(read=timeout, connect=timeout)\n\n    def clone(self):\n        \"\"\"Create a copy of the timeout object\n\n        Timeout properties are stored per-pool but each request needs a fresh\n        Timeout object to ensure each one has its own start/stop configured.\n\n        :return: a copy of the timeout object\n        :rtype: :class:`Timeout`\n        \"\"\"\n        # We can't use copy.deepcopy because that will also create a new object\n        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to\n        # detect the user default.\n        return Timeout(connect=self._connect, read=self._read, total=self.total)\n\n    def start_connect(self):\n        \"\"\"Start the timeout clock, used during a connect() attempt\n\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to start a timer that has been started already.\n        \"\"\"\n        if self._start_connect is not None:\n            raise TimeoutStateError(\"Timeout timer has already been started.\")\n        self._start_connect = current_time()\n        return self._start_connect\n\n    def get_connect_duration(self):\n        \"\"\"Gets the time elapsed since the call to :meth:`start_connect`.\n\n        :return: Elapsed time in seconds.\n        :rtype: float\n        :raises urllib3.exceptions.TimeoutStateError: if you attempt\n            to get duration for a timer that hasn't been started.\n        \"\"\"\n        if self._start_connect is None:\n            raise TimeoutStateError(\n                \"Can't get connect duration for timer that has not started.\"\n            )\n        return current_time() - self._start_connect\n\n    @property\n    def connect_timeout(self):\n        \"\"\"Get the value to use when setting a connection timeout.\n\n        This will be a positive float or integer, the value None\n        (never timeout), or the default system timeout.\n\n        :return: Connect timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        \"\"\"\n        if self.total is None:\n            return self._connect\n\n        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:\n            return self.total\n\n        return min(self._connect, self.total)\n\n    @property\n    def read_timeout(self):\n        \"\"\"Get the value for the read timeout.\n\n        This assumes some time has elapsed in the connection timeout and\n        computes the read timeout appropriately.\n\n        If self.total is set, the read timeout is dependent on the amount of\n        time taken by the connect timeout. If the connection time has not been\n        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be\n        raised.\n\n        :return: Value to use for the read timeout.\n        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None\n        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`\n            has not yet been called on this object.\n        \"\"\"\n        if (\n            self.total is not None\n            and self.total is not self.DEFAULT_TIMEOUT\n            and self._read is not None\n            and self._read is not self.DEFAULT_TIMEOUT\n        ):\n            # In case the connect timeout has not yet been established.\n            if self._start_connect is None:\n                return self._read\n            return max(0, min(self.total - self.get_connect_duration(), self._read))\n        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:\n            return max(0, self.total - self.get_connect_duration())\n        else:\n            return self._read\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/timeout.html#client.ayon_fusion.vendor.urllib3.util.timeout.Timeout.connect_timeout","title":"<code>connect_timeout</code>  <code>property</code>","text":"<p>Get the value to use when setting a connection timeout.</p> <p>This will be a positive float or integer, the value None (never timeout), or the default system timeout.</p> <p>:return: Connect timeout. :rtype: int, float, :attr:<code>Timeout.DEFAULT_TIMEOUT</code> or None</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/timeout.html#client.ayon_fusion.vendor.urllib3.util.timeout.Timeout.read_timeout","title":"<code>read_timeout</code>  <code>property</code>","text":"<p>Get the value for the read timeout.</p> <p>This assumes some time has elapsed in the connection timeout and computes the read timeout appropriately.</p> <p>If self.total is set, the read timeout is dependent on the amount of time taken by the connect timeout. If the connection time has not been established, a :exc:<code>~urllib3.exceptions.TimeoutStateError</code> will be raised.</p> <p>:return: Value to use for the read timeout. :rtype: int, float, :attr:<code>Timeout.DEFAULT_TIMEOUT</code> or None :raises urllib3.exceptions.TimeoutStateError: If :meth:<code>start_connect</code>     has not yet been called on this object.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/timeout.html#client.ayon_fusion.vendor.urllib3.util.timeout.Timeout.clone","title":"<code>clone()</code>","text":"<p>Create a copy of the timeout object</p> <p>Timeout properties are stored per-pool but each request needs a fresh Timeout object to ensure each one has its own start/stop configured.</p> <p>:return: a copy of the timeout object :rtype: :class:<code>Timeout</code></p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>def clone(self):\n    \"\"\"Create a copy of the timeout object\n\n    Timeout properties are stored per-pool but each request needs a fresh\n    Timeout object to ensure each one has its own start/stop configured.\n\n    :return: a copy of the timeout object\n    :rtype: :class:`Timeout`\n    \"\"\"\n    # We can't use copy.deepcopy because that will also create a new object\n    # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to\n    # detect the user default.\n    return Timeout(connect=self._connect, read=self._read, total=self.total)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/timeout.html#client.ayon_fusion.vendor.urllib3.util.timeout.Timeout.from_float","title":"<code>from_float(timeout)</code>  <code>classmethod</code>","text":"<p>Create a new Timeout from a legacy timeout value.</p> <p>The timeout value used by httplib.py sets the same timeout on the connect(), and recv() socket requests. This creates a :class:<code>Timeout</code> object that sets the individual timeouts to the <code>timeout</code> value passed to this function.</p> <p>:param timeout: The legacy timeout value. :type timeout: integer, float, sentinel default object, or None :return: Timeout object :rtype: :class:<code>Timeout</code></p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>@classmethod\ndef from_float(cls, timeout):\n    \"\"\"Create a new Timeout from a legacy timeout value.\n\n    The timeout value used by httplib.py sets the same timeout on the\n    connect(), and recv() socket requests. This creates a :class:`Timeout`\n    object that sets the individual timeouts to the ``timeout`` value\n    passed to this function.\n\n    :param timeout: The legacy timeout value.\n    :type timeout: integer, float, sentinel default object, or None\n    :return: Timeout object\n    :rtype: :class:`Timeout`\n    \"\"\"\n    return Timeout(read=timeout, connect=timeout)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/timeout.html#client.ayon_fusion.vendor.urllib3.util.timeout.Timeout.get_connect_duration","title":"<code>get_connect_duration()</code>","text":"<p>Gets the time elapsed since the call to :meth:<code>start_connect</code>.</p> <p>:return: Elapsed time in seconds. :rtype: float :raises urllib3.exceptions.TimeoutStateError: if you attempt     to get duration for a timer that hasn't been started.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>def get_connect_duration(self):\n    \"\"\"Gets the time elapsed since the call to :meth:`start_connect`.\n\n    :return: Elapsed time in seconds.\n    :rtype: float\n    :raises urllib3.exceptions.TimeoutStateError: if you attempt\n        to get duration for a timer that hasn't been started.\n    \"\"\"\n    if self._start_connect is None:\n        raise TimeoutStateError(\n            \"Can't get connect duration for timer that has not started.\"\n        )\n    return current_time() - self._start_connect\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/timeout.html#client.ayon_fusion.vendor.urllib3.util.timeout.Timeout.start_connect","title":"<code>start_connect()</code>","text":"<p>Start the timeout clock, used during a connect() attempt</p> <p>:raises urllib3.exceptions.TimeoutStateError: if you attempt     to start a timer that has been started already.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/timeout.py</code> <pre><code>def start_connect(self):\n    \"\"\"Start the timeout clock, used during a connect() attempt\n\n    :raises urllib3.exceptions.TimeoutStateError: if you attempt\n        to start a timer that has been started already.\n    \"\"\"\n    if self._start_connect is not None:\n        raise TimeoutStateError(\"Timeout timer has already been started.\")\n    self._start_connect = current_time()\n    return self._start_connect\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/url.html","title":"url","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/url.html#client.ayon_fusion.vendor.urllib3.util.url.Url","title":"<code>Url</code>","text":"<p>               Bases: <code>namedtuple('Url', url_attrs)</code></p> <p>Data structure for representing an HTTP URL. Used as a return value for :func:<code>parse_url</code>. Both the scheme and host are normalized as they are both case-insensitive according to RFC 3986.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/url.py</code> <pre><code>class Url(namedtuple(\"Url\", url_attrs)):\n    \"\"\"\n    Data structure for representing an HTTP URL. Used as a return value for\n    :func:`parse_url`. Both the scheme and host are normalized as they are\n    both case-insensitive according to RFC 3986.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __new__(\n        cls,\n        scheme=None,\n        auth=None,\n        host=None,\n        port=None,\n        path=None,\n        query=None,\n        fragment=None,\n    ):\n        if path and not path.startswith(\"/\"):\n            path = \"/\" + path\n        if scheme is not None:\n            scheme = scheme.lower()\n        return super(Url, cls).__new__(\n            cls, scheme, auth, host, port, path, query, fragment\n        )\n\n    @property\n    def hostname(self):\n        \"\"\"For backwards-compatibility with urlparse. We're nice like that.\"\"\"\n        return self.host\n\n    @property\n    def request_uri(self):\n        \"\"\"Absolute path including the query string.\"\"\"\n        uri = self.path or \"/\"\n\n        if self.query is not None:\n            uri += \"?\" + self.query\n\n        return uri\n\n    @property\n    def netloc(self):\n        \"\"\"Network location including host and port\"\"\"\n        if self.port:\n            return \"%s:%d\" % (self.host, self.port)\n        return self.host\n\n    @property\n    def url(self):\n        \"\"\"\n        Convert self into a url\n\n        This function should more or less round-trip with :func:`.parse_url`. The\n        returned url may not be exactly the same as the url inputted to\n        :func:`.parse_url`, but it should be equivalent by the RFC (e.g., urls\n        with a blank port will have : removed).\n\n        Example: ::\n\n            &gt;&gt;&gt; U = parse_url('http://google.com/mail/')\n            &gt;&gt;&gt; U.url\n            'http://google.com/mail/'\n            &gt;&gt;&gt; Url('http', 'username:password', 'host.com', 80,\n            ... '/path', 'query', 'fragment').url\n            'http://username:password@host.com:80/path?query#fragment'\n        \"\"\"\n        scheme, auth, host, port, path, query, fragment = self\n        url = u\"\"\n\n        # We use \"is not None\" we want things to happen with empty strings (or 0 port)\n        if scheme is not None:\n            url += scheme + u\"://\"\n        if auth is not None:\n            url += auth + u\"@\"\n        if host is not None:\n            url += host\n        if port is not None:\n            url += u\":\" + str(port)\n        if path is not None:\n            url += path\n        if query is not None:\n            url += u\"?\" + query\n        if fragment is not None:\n            url += u\"#\" + fragment\n\n        return url\n\n    def __str__(self):\n        return self.url\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/url.html#client.ayon_fusion.vendor.urllib3.util.url.Url.hostname","title":"<code>hostname</code>  <code>property</code>","text":"<p>For backwards-compatibility with urlparse. We're nice like that.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/url.html#client.ayon_fusion.vendor.urllib3.util.url.Url.netloc","title":"<code>netloc</code>  <code>property</code>","text":"<p>Network location including host and port</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/url.html#client.ayon_fusion.vendor.urllib3.util.url.Url.request_uri","title":"<code>request_uri</code>  <code>property</code>","text":"<p>Absolute path including the query string.</p>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/url.html#client.ayon_fusion.vendor.urllib3.util.url.Url.url","title":"<code>url</code>  <code>property</code>","text":"<p>Convert self into a url</p> <p>This function should more or less round-trip with :func:<code>.parse_url</code>. The returned url may not be exactly the same as the url inputted to :func:<code>.parse_url</code>, but it should be equivalent by the RFC (e.g., urls with a blank port will have : removed).</p> <p>Example: ::</p> <pre><code>&gt;&gt;&gt; U = parse_url('http://google.com/mail/')\n&gt;&gt;&gt; U.url\n'http://google.com/mail/'\n&gt;&gt;&gt; Url('http', 'username:password', 'host.com', 80,\n... '/path', 'query', 'fragment').url\n'http://username:password@host.com:80/path?query#fragment'\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/url.html#client.ayon_fusion.vendor.urllib3.util.url.get_host","title":"<code>get_host(url)</code>","text":"<p>Deprecated. Use :func:<code>parse_url</code> instead.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/url.py</code> <pre><code>def get_host(url):\n    \"\"\"\n    Deprecated. Use :func:`parse_url` instead.\n    \"\"\"\n    p = parse_url(url)\n    return p.scheme or \"http\", p.hostname, p.port\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/url.html#client.ayon_fusion.vendor.urllib3.util.url.parse_url","title":"<code>parse_url(url)</code>","text":"<p>Given a url, return a parsed :class:<code>.Url</code> namedtuple. Best-effort is performed to parse incomplete urls. Fields not provided will be None. This parser is RFC 3986 compliant.</p> <p>The parser logic and helper functions are based heavily on work done in the <code>rfc3986</code> module.</p> <p>:param str url: URL to parse into a :class:<code>.Url</code> namedtuple.</p> <p>Partly backwards-compatible with :mod:<code>urlparse</code>.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; parse_url('http://google.com/mail/')\nUrl(scheme='http', host='google.com', port=None, path='/mail/', ...)\n&gt;&gt;&gt; parse_url('google.com:80')\nUrl(scheme=None, host='google.com', port=80, path=None, ...)\n&gt;&gt;&gt; parse_url('/foo?bar')\nUrl(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n</code></pre> Source code in <code>client/ayon_fusion/vendor/urllib3/util/url.py</code> <pre><code>def parse_url(url):\n    \"\"\"\n    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is\n    performed to parse incomplete urls. Fields not provided will be None.\n    This parser is RFC 3986 compliant.\n\n    The parser logic and helper functions are based heavily on\n    work done in the ``rfc3986`` module.\n\n    :param str url: URL to parse into a :class:`.Url` namedtuple.\n\n    Partly backwards-compatible with :mod:`urlparse`.\n\n    Example::\n\n        &gt;&gt;&gt; parse_url('http://google.com/mail/')\n        Url(scheme='http', host='google.com', port=None, path='/mail/', ...)\n        &gt;&gt;&gt; parse_url('google.com:80')\n        Url(scheme=None, host='google.com', port=80, path=None, ...)\n        &gt;&gt;&gt; parse_url('/foo?bar')\n        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)\n    \"\"\"\n    if not url:\n        # Empty\n        return Url()\n\n    source_url = url\n    if not SCHEME_RE.search(url):\n        url = \"//\" + url\n\n    try:\n        scheme, authority, path, query, fragment = URI_RE.match(url).groups()\n        normalize_uri = scheme is None or scheme.lower() in NORMALIZABLE_SCHEMES\n\n        if scheme:\n            scheme = scheme.lower()\n\n        if authority:\n            auth, _, host_port = authority.rpartition(\"@\")\n            auth = auth or None\n            host, port = _HOST_PORT_RE.match(host_port).groups()\n            if auth and normalize_uri:\n                auth = _encode_invalid_chars(auth, USERINFO_CHARS)\n            if port == \"\":\n                port = None\n        else:\n            auth, host, port = None, None, None\n\n        if port is not None:\n            port = int(port)\n            if not (0 &lt;= port &lt;= 65535):\n                raise LocationParseError(url)\n\n        host = _normalize_host(host, scheme)\n\n        if normalize_uri and path:\n            path = _remove_path_dot_segments(path)\n            path = _encode_invalid_chars(path, PATH_CHARS)\n        if normalize_uri and query:\n            query = _encode_invalid_chars(query, QUERY_CHARS)\n        if normalize_uri and fragment:\n            fragment = _encode_invalid_chars(fragment, FRAGMENT_CHARS)\n\n    except (ValueError, AttributeError):\n        return six.raise_from(LocationParseError(source_url), None)\n\n    # For the sake of backwards compatibility we put empty\n    # string values for path if there are any defined values\n    # beyond the path in the URL.\n    # TODO: Remove this when we break backwards compatibility.\n    if not path:\n        if query is not None or fragment is not None:\n            path = \"\"\n        else:\n            path = None\n\n    # Ensure that each part of the URL is a `str` for\n    # backwards compatibility.\n    if isinstance(url, six.text_type):\n        ensure_func = six.ensure_text\n    else:\n        ensure_func = six.ensure_str\n\n    def ensure_type(x):\n        return x if x is None else ensure_func(x)\n\n    return Url(\n        scheme=ensure_type(scheme),\n        auth=ensure_type(auth),\n        host=ensure_type(host),\n        port=port,\n        path=ensure_type(path),\n        query=ensure_type(query),\n        fragment=ensure_type(fragment),\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/url.html#client.ayon_fusion.vendor.urllib3.util.url.split_first","title":"<code>split_first(s, delims)</code>","text":"<p>.. deprecated:: 1.25</p> <p>Given a string and an iterable of delimiters, split on the first found delimiter. Return two split parts and the matched delimiter.</p> <p>If not found, then the first part is the full input string.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; split_first('foo/bar?baz', '?/=')\n('foo', 'bar?baz', '/')\n&gt;&gt;&gt; split_first('foo/bar?baz', '123')\n('foo/bar?baz', '', None)\n</code></pre> <p>Scales linearly with number of delims. Not ideal for large number of delims.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/url.py</code> <pre><code>def split_first(s, delims):\n    \"\"\"\n    .. deprecated:: 1.25\n\n    Given a string and an iterable of delimiters, split on the first found\n    delimiter. Return two split parts and the matched delimiter.\n\n    If not found, then the first part is the full input string.\n\n    Example::\n\n        &gt;&gt;&gt; split_first('foo/bar?baz', '?/=')\n        ('foo', 'bar?baz', '/')\n        &gt;&gt;&gt; split_first('foo/bar?baz', '123')\n        ('foo/bar?baz', '', None)\n\n    Scales linearly with number of delims. Not ideal for large number of delims.\n    \"\"\"\n    min_idx = None\n    min_delim = None\n    for d in delims:\n        idx = s.find(d)\n        if idx &lt; 0:\n            continue\n\n        if min_idx is None or idx &lt; min_idx:\n            min_idx = idx\n            min_delim = d\n\n    if min_idx is None or min_idx &lt; 0:\n        return s, \"\", None\n\n    return s[:min_idx], s[min_idx + 1 :], min_delim\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/wait.html","title":"wait","text":""},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/wait.html#client.ayon_fusion.vendor.urllib3.util.wait.wait_for_read","title":"<code>wait_for_read(sock, timeout=None)</code>","text":"<p>Waits for reading to be available on a given socket. Returns True if the socket is readable, or False if the timeout expired.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/wait.py</code> <pre><code>def wait_for_read(sock, timeout=None):\n    \"\"\"Waits for reading to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, read=True, timeout=timeout)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/vendor/urllib3/util/wait.html#client.ayon_fusion.vendor.urllib3.util.wait.wait_for_write","title":"<code>wait_for_write(sock, timeout=None)</code>","text":"<p>Waits for writing to be available on a given socket. Returns True if the socket is readable, or False if the timeout expired.</p> Source code in <code>client/ayon_fusion/vendor/urllib3/util/wait.py</code> <pre><code>def wait_for_write(sock, timeout=None):\n    \"\"\"Waits for writing to be available on a given socket.\n    Returns True if the socket is readable, or False if the timeout expired.\n    \"\"\"\n    return wait_for_socket(sock, write=True, timeout=timeout)\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings.html","title":"settings","text":""}]}