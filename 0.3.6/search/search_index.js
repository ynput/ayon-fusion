var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Fusion addon","text":"<p>Fusion integration for AYON.</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_fusion<ul> <li>addon</li> <li>api<ul> <li>action</li> <li>lib</li> <li>menu</li> <li>pipeline</li> <li>plugin</li> <li>pulse</li> </ul> </li> <li>deploy<ul> <li>MenuScripts<ul> <li>install_pyside2</li> <li>launch_menu</li> </ul> </li> </ul> </li> <li>hooks<ul> <li>pre_fusion_launch_menu_hook</li> <li>pre_fusion_profile_hook</li> <li>pre_fusion_setup</li> <li>pre_pyside_install</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_image_saver</li> <li>create_saver</li> <li>create_workfile</li> </ul> </li> <li>inventory<ul> <li>select_containers</li> <li>set_tool_color</li> </ul> </li> <li>load<ul> <li>actions</li> <li>load_alembic</li> <li>load_fbx</li> <li>load_sequence</li> <li>load_usd</li> <li>load_workfile</li> </ul> </li> <li>publish<ul> <li>collect_comp</li> <li>collect_comp_frame_range</li> <li>collect_inputs</li> <li>collect_instances</li> <li>collect_render</li> <li>collect_workfile</li> <li>extract_render_local</li> <li>increment_current_file</li> <li>save_scene</li> <li>validate_background_depth</li> <li>validate_comp_saved</li> <li>validate_create_folder_checked</li> <li>validate_expected_frames_existence</li> <li>validate_filename_has_extension</li> <li>validate_image_frame</li> <li>validate_instance_frame_range</li> <li>validate_instance_in_context</li> <li>validate_saver_has_input</li> <li>validate_saver_passthrough</li> <li>validate_saver_resolution</li> <li>validate_unique_subsets</li> </ul> </li> </ul> </li> <li>scripts<ul> <li>duplicate_with_inputs</li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>imageio</li> <li>settings</li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_fusion/index.html","title":"ayon_fusion","text":""},{"location":"autoapi/client/ayon_fusion/index.html#client.ayon_fusion.get_fusion_version","title":"<code>get_fusion_version(app_name)</code>","text":"<p>The function is triggered by the prelaunch hooks to get the fusion version.</p> <p><code>app_name</code> is obtained by prelaunch hooks from the <code>launch_context.env.get(\"AYON_APP_NAME\")</code>.</p> <p>To get a correct Fusion version, a version number should be present in the <code>applications/fusion/variants</code> key of the Blackmagic Fusion Application Settings.</p> Source code in <code>client/ayon_fusion/addon.py</code> <pre><code>def get_fusion_version(app_name):\n    \"\"\"\n    The function is triggered by the prelaunch hooks to get the fusion version.\n\n    `app_name` is obtained by prelaunch hooks from the\n    `launch_context.env.get(\"AYON_APP_NAME\")`.\n\n    To get a correct Fusion version, a version number should be present\n    in the `applications/fusion/variants` key\n    of the Blackmagic Fusion Application Settings.\n    \"\"\"\n\n    log = Logger.get_logger(__name__)\n\n    if not app_name:\n        return\n\n    app_version_candidates = re.findall(r\"\\d+\", app_name)\n    if not app_version_candidates:\n        return\n    for app_version in app_version_candidates:\n        if int(app_version) in FUSION_VERSIONS_DICT:\n            return int(app_version)\n        else:\n            log.info(\n                \"Unsupported Fusion version: {app_version}\".format(\n                    app_version=app_version\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_fusion/addon.html#client.ayon_fusion.addon.get_fusion_version","title":"<code>get_fusion_version(app_name)</code>","text":"<p>The function is triggered by the prelaunch hooks to get the fusion version.</p> <p><code>app_name</code> is obtained by prelaunch hooks from the <code>launch_context.env.get(\"AYON_APP_NAME\")</code>.</p> <p>To get a correct Fusion version, a version number should be present in the <code>applications/fusion/variants</code> key of the Blackmagic Fusion Application Settings.</p> Source code in <code>client/ayon_fusion/addon.py</code> <pre><code>def get_fusion_version(app_name):\n    \"\"\"\n    The function is triggered by the prelaunch hooks to get the fusion version.\n\n    `app_name` is obtained by prelaunch hooks from the\n    `launch_context.env.get(\"AYON_APP_NAME\")`.\n\n    To get a correct Fusion version, a version number should be present\n    in the `applications/fusion/variants` key\n    of the Blackmagic Fusion Application Settings.\n    \"\"\"\n\n    log = Logger.get_logger(__name__)\n\n    if not app_name:\n        return\n\n    app_version_candidates = re.findall(r\"\\d+\", app_name)\n    if not app_version_candidates:\n        return\n    for app_version in app_version_candidates:\n        if int(app_version) in FUSION_VERSIONS_DICT:\n            return int(app_version)\n        else:\n            log.info(\n                \"Unsupported Fusion version: {app_version}\".format(\n                    app_version=app_version\n                )\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/version.html","title":"version","text":"<p>Package declaring AYON addon 'fusion' version.</p>"},{"location":"autoapi/client/ayon_fusion/api/index.html","title":"api","text":""},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.FusionHost","title":"<code>FusionHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>class FusionHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"fusion\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._forced_current_comp = None\n\n    def install(self):\n        \"\"\"Install fusion-specific functionality of AYON.\n\n        This is where you install menus and register families, data\n        and loaders into fusion.\n\n        It is called automatically when installing via\n        `ayon_core.pipeline.install_host(ayon_fusion.api)`\n\n        See the Maya equivalent for inspiration on how to implement this.\n\n        \"\"\"\n        # Remove all handlers associated with the root logger object, because\n        # that one always logs as \"warnings\" incorrectly.\n        for handler in logging.root.handlers[:]:\n            logging.root.removeHandler(handler)\n\n        # Attach default logging handler that prints to active comp\n        logger = logging.getLogger()\n        formatter = logging.Formatter(fmt=\"%(message)s\\n\")\n        handler = FusionLogHandler()\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        logger.setLevel(logging.DEBUG)\n\n        pyblish.api.register_host(\"fusion\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        log.info(\"Registering Fusion plug-ins..\")\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n\n        # Register events\n        register_event_callback(\"open\", on_after_open)\n        register_event_callback(\"workfile.save.before\", before_workfile_save)\n        register_event_callback(\"save\", on_save)\n        register_event_callback(\"new\", on_new)\n        register_event_callback(\"taskChanged\", on_task_changed)\n\n    # region workfile io api\n    def has_unsaved_changes(self):\n        comp = self.get_current_comp()\n        return comp.GetAttrs()[\"COMPB_Modified\"]\n\n    def get_workfile_extensions(self):\n        return [\".comp\"]\n\n    def save_workfile(self, dst_path=None):\n        comp = self.get_current_comp()\n        comp.Save(dst_path)\n\n    def open_workfile(self, filepath):\n        # Hack to get fusion, see\n        #   ayon_fusion.api.pipeline.get_current_comp()\n        fusion = getattr(sys.modules[\"__main__\"], \"fusion\", None)\n\n        return fusion.LoadComp(filepath)\n\n    def get_current_workfile(self):\n        comp = self.get_current_comp()\n        current_filepath = comp.GetAttrs()[\"COMPS_FileName\"]\n        if not current_filepath:\n            return None\n\n        return current_filepath\n\n    def work_root(self, session):\n        work_dir = session[\"AYON_WORKDIR\"]\n        scene_dir = session.get(\"AVALON_SCENEDIR\")\n        if scene_dir:\n            return os.path.join(work_dir, scene_dir)\n        else:\n            return work_dir\n    # endregion\n\n    @contextlib.contextmanager\n    def maintained_selection(self):\n        from .lib import maintained_selection\n        return maintained_selection()\n\n    def get_containers(self):\n        return ls()\n\n    def update_context_data(self, data, changes):\n        comp = self.get_current_comp()\n        comp.SetData(\"openpype\", data)\n\n    def get_context_data(self):\n        comp = self.get_current_comp()\n        return comp.GetData(\"openpype\") or {}\n\n    def get_current_comp(self):\n        if self._forced_current_comp is not None:\n            return self._forced_current_comp\n        return get_current_comp()\n\n    @contextlib.contextmanager\n    def current_comp(self, comp):\n        \"\"\"Fusion context manager to temporarily enforce 'current' comp.\n\n        During this context the workfile methods like `get_current_workfile`\n        and `save_workfile` will use the specifiec `comp` instead of the actual\n        active comp tab in Fusion itself. This is useful during e.g. publishing\n        where a user may have initiated a publish from one comp and then as\n        the publishing is running they switch to another comp tab.\n        \"\"\"\n        old_comp = self._forced_current_comp\n        try:\n            self._forced_current_comp = comp\n            yield\n        finally:\n            self._forced_current_comp = old_comp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.FusionHost.current_comp","title":"<code>current_comp(comp)</code>","text":"<p>Fusion context manager to temporarily enforce 'current' comp.</p> <p>During this context the workfile methods like <code>get_current_workfile</code> and <code>save_workfile</code> will use the specifiec <code>comp</code> instead of the actual active comp tab in Fusion itself. This is useful during e.g. publishing where a user may have initiated a publish from one comp and then as the publishing is running they switch to another comp tab.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>@contextlib.contextmanager\ndef current_comp(self, comp):\n    \"\"\"Fusion context manager to temporarily enforce 'current' comp.\n\n    During this context the workfile methods like `get_current_workfile`\n    and `save_workfile` will use the specifiec `comp` instead of the actual\n    active comp tab in Fusion itself. This is useful during e.g. publishing\n    where a user may have initiated a publish from one comp and then as\n    the publishing is running they switch to another comp tab.\n    \"\"\"\n    old_comp = self._forced_current_comp\n    try:\n        self._forced_current_comp = comp\n        yield\n    finally:\n        self._forced_current_comp = old_comp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.FusionHost.install","title":"<code>install()</code>","text":"<p>Install fusion-specific functionality of AYON.</p> <p>This is where you install menus and register families, data and loaders into fusion.</p> <p>It is called automatically when installing via <code>ayon_core.pipeline.install_host(ayon_fusion.api)</code></p> <p>See the Maya equivalent for inspiration on how to implement this.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install fusion-specific functionality of AYON.\n\n    This is where you install menus and register families, data\n    and loaders into fusion.\n\n    It is called automatically when installing via\n    `ayon_core.pipeline.install_host(ayon_fusion.api)`\n\n    See the Maya equivalent for inspiration on how to implement this.\n\n    \"\"\"\n    # Remove all handlers associated with the root logger object, because\n    # that one always logs as \"warnings\" incorrectly.\n    for handler in logging.root.handlers[:]:\n        logging.root.removeHandler(handler)\n\n    # Attach default logging handler that prints to active comp\n    logger = logging.getLogger()\n    formatter = logging.Formatter(fmt=\"%(message)s\\n\")\n    handler = FusionLogHandler()\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    logger.setLevel(logging.DEBUG)\n\n    pyblish.api.register_host(\"fusion\")\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    log.info(\"Registering Fusion plug-ins..\")\n\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n    register_inventory_action_path(INVENTORY_PATH)\n\n    # Register events\n    register_event_callback(\"open\", on_after_open)\n    register_event_callback(\"workfile.save.before\", before_workfile_save)\n    register_event_callback(\"save\", on_save)\n    register_event_callback(\"new\", on_new)\n    register_event_callback(\"taskChanged\", on_task_changed)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.comp_lock_and_undo_chunk","title":"<code>comp_lock_and_undo_chunk(comp, undo_queue_name='Script CMD', keep_undo=True)</code>","text":"<p>Lock comp and open an undo chunk during the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef comp_lock_and_undo_chunk(\n    comp,\n    undo_queue_name=\"Script CMD\",\n    keep_undo=True,\n):\n    \"\"\"Lock comp and open an undo chunk during the context\"\"\"\n    try:\n        comp.Lock()\n        comp.StartUndo(undo_queue_name)\n        yield\n    finally:\n        comp.Unlock()\n        comp.EndUndo(keep_undo)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.get_bmd_library","title":"<code>get_bmd_library()</code>","text":"<p>Get bmd library</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_bmd_library():\n    \"\"\"Get bmd library\"\"\"\n    bmd = getattr(sys.modules[\"__main__\"], \"bmd\", None)\n    return bmd\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.get_current_comp","title":"<code>get_current_comp()</code>","text":"<p>Get current comp in this session</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_current_comp():\n    \"\"\"Get current comp in this session\"\"\"\n    fusion = get_fusion_module()\n    if fusion is not None:\n        comp = fusion.CurrentComp\n        return comp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.imprint_container","title":"<code>imprint_container(tool, name, namespace, context, loader=None)</code>","text":"<p>Imprint a Loader with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>object</code> <p>The node in Fusion to imprint as container, usually a Loader.</p> required <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def imprint_container(tool,\n                      name,\n                      namespace,\n                      context,\n                      loader=None):\n    \"\"\"Imprint a Loader with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        tool (object): The node in Fusion to imprint as container, usually a\n            Loader.\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    data = [\n        (\"schema\", \"openpype:container-2.0\"),\n        (\"id\", AVALON_CONTAINER_ID),\n        (\"name\", str(name)),\n        (\"namespace\", str(namespace)),\n        (\"loader\", str(loader)),\n        (\"representation\", context[\"representation\"][\"id\"]),\n        (\"project_name\", context[\"project\"][\"name\"]),\n    ]\n\n    for key, value in data:\n        tool.SetData(\"avalon.{}\".format(key), value)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.ls","title":"<code>ls()</code>","text":"<p>List containers from active Fusion scene</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Fusion; once loaded they are called 'containers'</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List containers from active Fusion scene\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in Fusion; once loaded\n    they are called 'containers'\n\n    Yields:\n        dict: container\n\n    \"\"\"\n    host = registered_host()\n    comp = host.get_current_comp()\n    tools = comp.GetToolList(False).values()\n\n    for tool in tools:\n        container = parse_container(tool)\n        if container:\n            yield container\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.maintained_selection","title":"<code>maintained_selection(comp=None)</code>","text":"<p>Reset comp selection from before the context after the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection(comp=None):\n    \"\"\"Reset comp selection from before the context after the context\"\"\"\n    if comp is None:\n        comp = get_current_comp()\n\n    previous_selection = comp.GetToolList(True).values()\n    try:\n        yield\n    finally:\n        flow = comp.CurrentFrame.FlowView\n        flow.Select()  # No args equals clearing selection\n        if previous_selection:\n            for tool in previous_selection:\n                flow.Select(tool, True)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.parse_container","title":"<code>parse_container(tool)</code>","text":"<p>Returns imprinted container data of a tool</p> <p>This reads the imprinted data from <code>imprint_container</code>.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def parse_container(tool):\n    \"\"\"Returns imprinted container data of a tool\n\n    This reads the imprinted data from `imprint_container`.\n\n    \"\"\"\n\n    data = tool.GetData('avalon')\n    if not isinstance(data, dict):\n        return\n\n    # If not all required data return the empty container\n    required = ['schema', 'id', 'name',\n                'namespace', 'loader', 'representation']\n    if not all(key in data for key in required):\n        return\n\n    container = {key: data[key] for key in required}\n\n    # Add optional keys, like `project_name`\n    optional = [\"project_name\"]\n    for key in optional:\n        if key in data:\n            container[key] = data[key]\n\n    # Store the tool's name\n    container[\"objectName\"] = tool.Name\n\n    # Store reference to the tool object\n    container[\"_tool\"] = tool\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.set_current_context_framerange","title":"<code>set_current_context_framerange(task_entity=None)</code>","text":"<p>Set Comp's frame range based on current task.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def set_current_context_framerange(task_entity=None):\n    \"\"\"Set Comp's frame range based on current task.\"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(\n            fields={\"attrib.frameStart\",\n                    \"attrib.frameEnd\",\n                    \"attrib.handleStart\",\n                    \"attrib.handleEnd\"})\n\n    task_attributes = task_entity[\"attrib\"]\n    start = task_attributes[\"frameStart\"]\n    end = task_attributes[\"frameEnd\"]\n    handle_start = task_attributes[\"handleStart\"]\n    handle_end = task_attributes[\"handleEnd\"]\n    update_frame_range(start, end, set_render_range=True,\n                       handle_start=handle_start,\n                       handle_end=handle_end)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/index.html#client.ayon_fusion.api.update_frame_range","title":"<code>update_frame_range(start, end, comp=None, set_render_range=True, handle_start=0, handle_end=0)</code>","text":"<p>Set Fusion comp's start and end frame range</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(float, int)</code> <p>start frame</p> required <code>end</code> <code>(float, int)</code> <p>end frame</p> required <code>comp</code> <code>(object, Optional)</code> <p>comp object from fusion</p> <code>None</code> <code>set_render_range</code> <code>(bool, Optional)</code> <p>When True this will also set the composition's render start and end frame.</p> <code>True</code> <code>handle_start</code> <code>(float, int, Optional)</code> <p>frame handles before start frame</p> <code>0</code> <code>handle_end</code> <code>(float, int, Optional)</code> <p>frame handles after end frame</p> <code>0</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def update_frame_range(start, end, comp=None, set_render_range=True,\n                       handle_start=0, handle_end=0):\n    \"\"\"Set Fusion comp's start and end frame range\n\n    Args:\n        start (float, int): start frame\n        end (float, int): end frame\n        comp (object, Optional): comp object from fusion\n        set_render_range (bool, Optional): When True this will also set the\n            composition's render start and end frame.\n        handle_start (float, int, Optional): frame handles before start frame\n        handle_end (float, int, Optional): frame handles after end frame\n\n    Returns:\n        None\n\n    \"\"\"\n\n    if not comp:\n        comp = get_current_comp()\n\n    # Convert any potential none type to zero\n    handle_start = handle_start or 0\n    handle_end = handle_end or 0\n\n    attrs = {\n        \"COMPN_GlobalStart\": start - handle_start,\n        \"COMPN_GlobalEnd\": end + handle_end\n    }\n\n    # set frame range\n    if set_render_range:\n        attrs.update({\n            \"COMPN_RenderStart\": start,\n            \"COMPN_RenderEnd\": end\n        })\n\n    with comp_lock_and_undo_chunk(comp):\n        comp.SetAttrs(attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/action.html","title":"action","text":""},{"location":"autoapi/client/ayon_fusion/api/action.html#client.ayon_fusion.api.action.SelectInvalidAction","title":"<code>SelectInvalidAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid nodes in Fusion when plug-in failed.</p> <p>To retrieve the invalid nodes this assumes a static <code>get_invalid()</code> method is available on the plugin.</p> Source code in <code>client/ayon_fusion/api/action.py</code> <pre><code>class SelectInvalidAction(pyblish.api.Action):\n    \"\"\"Select invalid nodes in Fusion when plug-in failed.\n\n    To retrieve the invalid nodes this assumes a static `get_invalid()`\n    method is available on the plugin.\n\n    \"\"\"\n\n    label = \"Select invalid\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"search\"  # Icon from Awesome Icon\n\n    def process(self, context, plugin):\n        errored_instances = get_errored_instances_from_context(\n            context,\n            plugin=plugin,\n        )\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes..\")\n        invalid = list()\n        for instance in errored_instances:\n            invalid_nodes = plugin.get_invalid(instance)\n            if invalid_nodes:\n                if isinstance(invalid_nodes, (list, tuple)):\n                    invalid.extend(invalid_nodes)\n                else:\n                    self.log.warning(\n                        \"Plug-in returned to be invalid, \"\n                        \"but has no selectable nodes.\"\n                    )\n\n        if not invalid:\n            # Assume relevant comp is current comp and clear selection\n            self.log.info(\"No invalid tools found.\")\n            comp = get_current_comp()\n            flow = comp.CurrentFrame.FlowView\n            flow.Select()  # No args equals clearing selection\n            return\n\n        # Assume a single comp\n        first_tool = invalid[0]\n        comp = first_tool.Comp()\n        flow = comp.CurrentFrame.FlowView\n        flow.Select()  # No args equals clearing selection\n        names = set()\n        for tool in invalid:\n            flow.Select(tool, True)\n            comp.SetActiveTool(tool)\n            names.add(tool.Name)\n        self.log.info(\n            \"Selecting invalid tools: %s\" % \", \".join(sorted(names))\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/action.html#client.ayon_fusion.api.action.SelectToolAction","title":"<code>SelectToolAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid output tool in Fusion when plug-in failed.</p> Source code in <code>client/ayon_fusion/api/action.py</code> <pre><code>class SelectToolAction(pyblish.api.Action):\n    \"\"\"Select invalid output tool in Fusion when plug-in failed.\n\n    \"\"\"\n\n    label = \"Select saver\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"search\"  # Icon from Awesome Icon\n\n    def process(self, context, plugin):\n        errored_instances = get_errored_instances_from_context(\n            context,\n            plugin=plugin,\n        )\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid nodes..\")\n        tools = []\n        for instance in errored_instances:\n\n            tool = instance.data.get(\"tool\")\n            if tool is not None:\n                tools.append(tool)\n            else:\n                self.log.warning(\n                    \"Plug-in returned to be invalid, \"\n                    f\"but has no saver for instance {instance.name}.\"\n                )\n\n        if not tools:\n            # Assume relevant comp is current comp and clear selection\n            self.log.info(\"No invalid tools found.\")\n            comp = get_current_comp()\n            flow = comp.CurrentFrame.FlowView\n            flow.Select()  # No args equals clearing selection\n            return\n\n        # Assume a single comp\n        first_tool = tools[0]\n        comp = first_tool.Comp()\n        flow = comp.CurrentFrame.FlowView\n        flow.Select()  # No args equals clearing selection\n        names = set()\n        for tool in tools:\n            flow.Select(tool, True)\n            comp.SetActiveTool(tool)\n            names.add(tool.Name)\n        self.log.info(\n            \"Selecting invalid tools: %s\" % \", \".join(sorted(names))\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.comp_lock_and_undo_chunk","title":"<code>comp_lock_and_undo_chunk(comp, undo_queue_name='Script CMD', keep_undo=True)</code>","text":"<p>Lock comp and open an undo chunk during the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef comp_lock_and_undo_chunk(\n    comp,\n    undo_queue_name=\"Script CMD\",\n    keep_undo=True,\n):\n    \"\"\"Lock comp and open an undo chunk during the context\"\"\"\n    try:\n        comp.Lock()\n        comp.StartUndo(undo_queue_name)\n        yield\n    finally:\n        comp.Unlock()\n        comp.EndUndo(keep_undo)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_bmd_library","title":"<code>get_bmd_library()</code>","text":"<p>Get bmd library</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_bmd_library():\n    \"\"\"Get bmd library\"\"\"\n    bmd = getattr(sys.modules[\"__main__\"], \"bmd\", None)\n    return bmd\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_current_comp","title":"<code>get_current_comp()</code>","text":"<p>Get current comp in this session</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_current_comp():\n    \"\"\"Get current comp in this session\"\"\"\n    fusion = get_fusion_module()\n    if fusion is not None:\n        comp = fusion.CurrentComp\n        return comp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_frame_path","title":"<code>get_frame_path(path)</code>","text":"<p>Get filename for the Fusion Saver with padded number as '#'</p> <p>get_frame_path(\"C:/test.exr\") ('C:/test', 4, '.exr')</p> <p>get_frame_path(\"filename.00.tif\") ('filename.', 2, '.tif')</p> <p>get_frame_path(\"foobar35.tif\") ('foobar', 2, '.tif')</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to render to.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>head, padding, tail (extension)</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_frame_path(path):\n    \"\"\"Get filename for the Fusion Saver with padded number as '#'\n\n    &gt;&gt;&gt; get_frame_path(\"C:/test.exr\")\n    ('C:/test', 4, '.exr')\n\n    &gt;&gt;&gt; get_frame_path(\"filename.00.tif\")\n    ('filename.', 2, '.tif')\n\n    &gt;&gt;&gt; get_frame_path(\"foobar35.tif\")\n    ('foobar', 2, '.tif')\n\n    Args:\n        path (str): The path to render to.\n\n    Returns:\n        tuple: head, padding, tail (extension)\n\n    \"\"\"\n    filename, ext = os.path.splitext(path)\n\n    # Find a final number group\n    match = re.match('.*?([0-9]+)$', filename)\n    if match:\n        padding = len(match.group(1))\n        # remove number from end since fusion\n        # will swap it with the frame number\n        filename = filename[:-padding]\n    else:\n        padding = 4  # default Fusion padding\n\n    return filename, padding, ext\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_fusion_module","title":"<code>get_fusion_module()</code>","text":"<p>Get current Fusion instance</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_fusion_module():\n    \"\"\"Get current Fusion instance\"\"\"\n    fusion = getattr(sys.modules[\"__main__\"], \"fusion\", None)\n    return fusion\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.get_tool_resolution","title":"<code>get_tool_resolution(tool, frame)</code>","text":"<p>Return the 2D input resolution to a Fusion tool</p> <p>If the current tool hasn't been rendered its input resolution hasn't been saved. To combat this, add an expression in the comments field to read the resolution</p> <p>Args     tool (Fusion Tool): The tool to query input resolution     frame (int): The frame to query the resolution on.</p> <p>Returns:</p> Name Type Description <code>tuple</code> <p>width, height as 2-tuple of integers</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Unable to retrieve comp resolution.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def get_tool_resolution(tool, frame):\n    \"\"\"Return the 2D input resolution to a Fusion tool\n\n    If the current tool hasn't been rendered its input resolution\n    hasn't been saved. To combat this, add an expression in\n    the comments field to read the resolution\n\n    Args\n        tool (Fusion Tool): The tool to query input resolution\n        frame (int): The frame to query the resolution on.\n\n    Returns:\n        tuple: width, height as 2-tuple of integers\n\n    Raises:\n        ValueError: Unable to retrieve comp resolution.\n\n    \"\"\"\n    comp = tool.Composition\n    attribute = tool[\"Comments\"]\n\n    # False undo removes the undo-stack from the undo list\n    with comp_lock_and_undo_chunk(comp, \"Read resolution\", False):\n\n        # Get width\n        with temp_expression(attribute, frame, \"self.Input.OriginalWidth\"):\n            value = attribute[frame]\n            if value is None:\n                raise ValueError(\"Failed to read input width\")\n            width = int(value)\n\n        # Get height\n        with temp_expression(attribute, frame, \"self.Input.OriginalHeight\"):\n            value = attribute[frame]\n            if value is None:\n                raise ValueError(\"Failed to read input height\")\n            height = int(value)\n\n        return width, height\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.maintained_comp_range","title":"<code>maintained_comp_range(comp=None, global_start=True, global_end=True, render_start=True, render_end=True)</code>","text":"<p>Reset comp frame ranges from before the context after the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_comp_range(comp=None,\n                          global_start=True,\n                          global_end=True,\n                          render_start=True,\n                          render_end=True):\n    \"\"\"Reset comp frame ranges from before the context after the context\"\"\"\n    if comp is None:\n        comp = get_current_comp()\n\n    comp_attrs = comp.GetAttrs()\n    preserve_attrs = {}\n    if global_start:\n        preserve_attrs[\"COMPN_GlobalStart\"] = comp_attrs[\"COMPN_GlobalStart\"]\n    if global_end:\n        preserve_attrs[\"COMPN_GlobalEnd\"] = comp_attrs[\"COMPN_GlobalEnd\"]\n    if render_start:\n        preserve_attrs[\"COMPN_RenderStart\"] = comp_attrs[\"COMPN_RenderStart\"]\n    if render_end:\n        preserve_attrs[\"COMPN_RenderEnd\"] = comp_attrs[\"COMPN_RenderEnd\"]\n\n    try:\n        yield\n    finally:\n        comp.SetAttrs(preserve_attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.maintained_selection","title":"<code>maintained_selection(comp=None)</code>","text":"<p>Reset comp selection from before the context after the context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection(comp=None):\n    \"\"\"Reset comp selection from before the context after the context\"\"\"\n    if comp is None:\n        comp = get_current_comp()\n\n    previous_selection = comp.GetToolList(True).values()\n    try:\n        yield\n    finally:\n        flow = comp.CurrentFrame.FlowView\n        flow.Select()  # No args equals clearing selection\n        if previous_selection:\n            for tool in previous_selection:\n                flow.Select(tool, True)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.prompt_reset_context","title":"<code>prompt_reset_context()</code>","text":"<p>Prompt the user what context settings to reset. This prompt is used on saving to a different task to allow the scene to get matched to the new context.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def prompt_reset_context():\n    \"\"\"Prompt the user what context settings to reset.\n    This prompt is used on saving to a different task to allow the scene to\n    get matched to the new context.\n    \"\"\"\n    # TODO: Cleanup this prototyped mess of imports and odd dialog\n    from ayon_core.tools.attribute_defs.dialog import (\n        AttributeDefinitionsDialog\n    )\n    from qtpy import QtCore\n\n    definitions = [\n        UILabelDef(\n            label=(\n                \"You are saving your workfile into a different folder or task.\"\n                \"\\n\\n\"\n                \"Would you like to update some settings to the new context?\\n\"\n            )\n        ),\n        BoolDef(\n            \"fps\", \n            label=\"FPS\", \n            tooltip=\"Reset Comp FPS\",\n            default=True\n        ),\n        BoolDef(\n            \"frame_range\", \n            label=\"Frame Range\",\n            tooltip=\"Reset Comp start and end frame ranges\",\n            default=True\n        ),\n        BoolDef(\n            \"resolution\", \n            label=\"Comp Resolution\", \n            tooltip=\"Reset Comp resolution\",\n            default=True\n        ),\n        BoolDef(\n            \"instances\", \n            label=\"Publish instances\", \n            tooltip=\"Update all publish instance's folder and task to match \"\n                    \"the new folder and task\", \n            default=True\n        ),\n    ]\n\n    dialog = AttributeDefinitionsDialog(definitions)\n    dialog.setWindowFlags(\n        dialog.windowFlags() | QtCore.Qt.WindowStaysOnTopHint\n    )\n    dialog.setWindowTitle(\"Saving to different context.\")\n    dialog.setStyleSheet(load_stylesheet())\n    if not dialog.exec_():\n        return None\n\n    options = dialog.get_values()\n    task_entity = get_current_task_entity()\n    if options[\"frame_range\"]:\n        set_current_context_framerange(task_entity)\n\n    if options[\"fps\"]:\n        set_current_context_fps(task_entity)\n\n    if options[\"resolution\"]:\n        set_current_context_resolution(task_entity)\n\n    if options[\"instances\"]:\n        update_content_on_context_change()\n\n    dialog.deleteLater()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.set_current_context_fps","title":"<code>set_current_context_fps(task_entity=None)</code>","text":"<p>Set Comp's frame rate (FPS) to based on current task</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def set_current_context_fps(task_entity=None):\n    \"\"\"Set Comp's frame rate (FPS) to based on current task\"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(fields={\"attrib.fps\"})\n\n    fps = float(task_entity[\"attrib\"].get(\"fps\", 24.0))\n    comp = get_current_comp()\n    comp.SetPrefs({\n        \"Comp.FrameFormat.Rate\": fps,\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.set_current_context_framerange","title":"<code>set_current_context_framerange(task_entity=None)</code>","text":"<p>Set Comp's frame range based on current task.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def set_current_context_framerange(task_entity=None):\n    \"\"\"Set Comp's frame range based on current task.\"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(\n            fields={\"attrib.frameStart\",\n                    \"attrib.frameEnd\",\n                    \"attrib.handleStart\",\n                    \"attrib.handleEnd\"})\n\n    task_attributes = task_entity[\"attrib\"]\n    start = task_attributes[\"frameStart\"]\n    end = task_attributes[\"frameEnd\"]\n    handle_start = task_attributes[\"handleStart\"]\n    handle_end = task_attributes[\"handleEnd\"]\n    update_frame_range(start, end, set_render_range=True,\n                       handle_start=handle_start,\n                       handle_end=handle_end)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.set_current_context_resolution","title":"<code>set_current_context_resolution(task_entity=None)</code>","text":"<p>Set Comp's resolution width x height default based on current task</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def set_current_context_resolution(task_entity=None):\n    \"\"\"Set Comp's resolution width x height default based on current task\"\"\"\n    if task_entity is None:\n        task_entity = get_current_task_entity(\n            fields={\"attrib.resolutionWidth\", \"attrib.resolutionHeight\"})\n\n    task_attributes = task_entity[\"attrib\"]\n    width = task_attributes[\"resolutionWidth\"]\n    height = task_attributes[\"resolutionHeight\"]\n    comp = get_current_comp()\n\n    print(\"Setting comp frame format resolution to {}x{}\".format(width,\n                                                                 height))\n    comp.SetPrefs({\n        \"Comp.FrameFormat.Width\": width,\n        \"Comp.FrameFormat.Height\": height,\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.temp_expression","title":"<code>temp_expression(attribute, frame, expression)</code>","text":"<p>Temporarily set an expression on an attribute during context</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef temp_expression(attribute, frame, expression):\n    \"\"\"Temporarily set an expression on an attribute during context\"\"\"\n    # Save old comment\n    old_comment = \"\"\n    has_expression = False\n\n    if attribute[frame] not in [\"\", None]:\n        if attribute.GetExpression() is not None:\n            has_expression = True\n            old_comment = attribute.GetExpression()\n            attribute.SetExpression(None)\n        else:\n            old_comment = attribute[frame]\n            attribute[frame] = \"\"\n\n    try:\n        attribute.SetExpression(expression)\n        yield\n    finally:\n        # Reset old comment\n        attribute.SetExpression(None)\n        if has_expression:\n            attribute.SetExpression(old_comment)\n        else:\n            attribute[frame] = old_comment\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.update_content_on_context_change","title":"<code>update_content_on_context_change()</code>","text":"<p>Update all Creator instances to current asset</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def update_content_on_context_change():\n    \"\"\"Update all Creator instances to current asset\"\"\"\n    host = registered_host()\n    context = host.get_current_context()\n\n    folder_path = context[\"folder_path\"]\n    task = context[\"task_name\"]\n\n    create_context = CreateContext(host, reset=True)\n\n    for instance in create_context.instances:\n        instance_folder_path = instance.get(\"folderPath\")\n        if instance_folder_path and instance_folder_path != folder_path:\n            instance[\"folderPath\"] = folder_path\n        instance_task = instance.get(\"task\")\n        if instance_task and instance_task != task:\n            instance[\"task\"] = task\n\n    create_context.save_changes()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.update_frame_range","title":"<code>update_frame_range(start, end, comp=None, set_render_range=True, handle_start=0, handle_end=0)</code>","text":"<p>Set Fusion comp's start and end frame range</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>(float, int)</code> <p>start frame</p> required <code>end</code> <code>(float, int)</code> <p>end frame</p> required <code>comp</code> <code>(object, Optional)</code> <p>comp object from fusion</p> <code>None</code> <code>set_render_range</code> <code>(bool, Optional)</code> <p>When True this will also set the composition's render start and end frame.</p> <code>True</code> <code>handle_start</code> <code>(float, int, Optional)</code> <p>frame handles before start frame</p> <code>0</code> <code>handle_end</code> <code>(float, int, Optional)</code> <p>frame handles after end frame</p> <code>0</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def update_frame_range(start, end, comp=None, set_render_range=True,\n                       handle_start=0, handle_end=0):\n    \"\"\"Set Fusion comp's start and end frame range\n\n    Args:\n        start (float, int): start frame\n        end (float, int): end frame\n        comp (object, Optional): comp object from fusion\n        set_render_range (bool, Optional): When True this will also set the\n            composition's render start and end frame.\n        handle_start (float, int, Optional): frame handles before start frame\n        handle_end (float, int, Optional): frame handles after end frame\n\n    Returns:\n        None\n\n    \"\"\"\n\n    if not comp:\n        comp = get_current_comp()\n\n    # Convert any potential none type to zero\n    handle_start = handle_start or 0\n    handle_end = handle_end or 0\n\n    attrs = {\n        \"COMPN_GlobalStart\": start - handle_start,\n        \"COMPN_GlobalEnd\": end + handle_end\n    }\n\n    # set frame range\n    if set_render_range:\n        attrs.update({\n            \"COMPN_RenderStart\": start,\n            \"COMPN_RenderEnd\": end\n        })\n\n    with comp_lock_and_undo_chunk(comp):\n        comp.SetAttrs(attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/lib.html#client.ayon_fusion.api.lib.validate_comp_prefs","title":"<code>validate_comp_prefs(comp=None, force_repair=False)</code>","text":"<p>Validate current comp defaults with task settings.</p> <p>Validates fps, resolutionWidth, resolutionHeight, aspectRatio.</p> <p>This does not validate frameStart, frameEnd, handleStart and handleEnd.</p> Source code in <code>client/ayon_fusion/api/lib.py</code> <pre><code>def validate_comp_prefs(comp=None, force_repair=False):\n    \"\"\"Validate current comp defaults with task settings.\n\n    Validates fps, resolutionWidth, resolutionHeight, aspectRatio.\n\n    This does *not* validate frameStart, frameEnd, handleStart and handleEnd.\n    \"\"\"\n\n    if comp is None:\n        comp = get_current_comp()\n\n    log = Logger.get_logger(\"validate_comp_prefs\")\n\n    fields = {\n        \"name\",\n        \"attrib.fps\",\n        \"attrib.resolutionWidth\",\n        \"attrib.resolutionHeight\",\n        \"attrib.pixelAspect\",\n    }\n    task_entity = get_current_task_entity(fields=fields)\n    folder_path = get_current_folder_path()\n    context_path = \"{} &gt; {}\".format(folder_path, task_entity[\"name\"])\n\n    task_attributes = task_entity[\"attrib\"]\n\n    comp_frame_format_prefs = comp.GetPrefs(\"Comp.FrameFormat\")\n\n    # Pixel aspect ratio in Fusion is set as AspectX and AspectY so we convert\n    # the data to something that is more sensible to Fusion\n    task_attributes[\"pixelAspectX\"] = task_attributes.pop(\"pixelAspect\")\n    task_attributes[\"pixelAspectY\"] = 1.0\n\n    validations = [\n        (\"fps\", \"Rate\", \"FPS\"),\n        (\"resolutionWidth\", \"Width\", \"Resolution Width\"),\n        (\"resolutionHeight\", \"Height\", \"Resolution Height\"),\n        (\"pixelAspectX\", \"AspectX\", \"Pixel Aspect Ratio X\"),\n        (\"pixelAspectY\", \"AspectY\", \"Pixel Aspect Ratio Y\")\n    ]\n\n    invalid = []\n    for key, comp_key, label in validations:\n        task_value = task_attributes[key]\n        comp_value = comp_frame_format_prefs.get(comp_key)\n        if task_value != comp_value:\n            invalid_msg = \"{} {} should be {}\".format(label,\n                                                      comp_value,\n                                                      task_value)\n            invalid.append(invalid_msg)\n\n            if not force_repair:\n                # Do not log warning if we force repair anyway\n                log.warning(\n                    \"Comp {pref} {value} does not match \"\n                    \"{context_path} {pref} {task_value}\".format(\n                        pref=label,\n                        value=comp_value,\n                        context_path=context_path,\n                        task_value=task_value)\n                )\n\n    if invalid:\n\n        def _on_repair():\n            attributes = dict()\n            for key, comp_key, _label in validations:\n                value = task_attributes[key]\n                comp_key_full = \"Comp.FrameFormat.{}\".format(comp_key)\n                attributes[comp_key_full] = value\n            comp.SetPrefs(attributes)\n\n        if force_repair:\n            log.info(\"Applying default Comp preferences..\")\n            _on_repair()\n            return\n\n        from . import menu\n        from ayon_core.tools.utils import SimplePopup\n        dialog = SimplePopup(parent=menu.menu)\n        dialog.setWindowTitle(\"Fusion comp has invalid configuration\")\n\n        msg = \"Comp preferences mismatches '{}'\".format(context_path)\n        msg += \"\\n\" + \"\\n\".join(invalid)\n        dialog.set_message(msg)\n        dialog.set_button_text(\"Repair\")\n        dialog.on_clicked.connect(_on_repair)\n        dialog.show()\n        dialog.raise_()\n        dialog.activateWindow()\n        dialog.setStyleSheet(load_stylesheet())\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/menu.html","title":"menu","text":""},{"location":"autoapi/client/ayon_fusion/api/pipeline.html","title":"pipeline","text":"<p>Basic avalon integration</p>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.FusionEventHandler","title":"<code>FusionEventHandler</code>","text":"<p>               Bases: <code>QObject</code></p> <p>Emits AYON events based on Fusion events captured in a QThread.</p> This will emit the following AYON events based on Fusion actions <p>save: Comp_Save, Comp_SaveAs open: Comp_Opened new: Comp_New</p> <p>To use this you can attach it to you Qt UI so it runs in the background. E.g.     &gt;&gt;&gt; handler = FusionEventHandler(parent=window)     &gt;&gt;&gt; handler.start()</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>class FusionEventHandler(QtCore.QObject):\n    \"\"\"Emits AYON events based on Fusion events captured in a QThread.\n\n    This will emit the following AYON events based on Fusion actions:\n        save: Comp_Save, Comp_SaveAs\n        open: Comp_Opened\n        new: Comp_New\n\n    To use this you can attach it to you Qt UI so it runs in the background.\n    E.g.\n        &gt;&gt;&gt; handler = FusionEventHandler(parent=window)\n        &gt;&gt;&gt; handler.start()\n\n    \"\"\"\n    ACTION_IDS = [\n        \"Comp_Save\",\n        \"Comp_SaveAs\",\n        \"Comp_New\",\n        \"Comp_Opened\"\n    ]\n\n    def __init__(self, parent=None):\n        super(FusionEventHandler, self).__init__(parent=parent)\n\n        # Set up Fusion event callbacks\n        fusion = getattr(sys.modules[\"__main__\"], \"fusion\", None)\n        ui = fusion.UIManager\n\n        # Add notifications for the ones we want to listen to\n        notifiers = []\n        for action_id in self.ACTION_IDS:\n            notifier = ui.AddNotify(action_id, None)\n            notifiers.append(notifier)\n\n        # TODO: Not entirely sure whether these must be kept to avoid\n        #       garbage collection\n        self._notifiers = notifiers\n\n        self._event_thread = FusionEventThread(parent=self)\n        self._event_thread.on_event.connect(self._on_event)\n\n    def start(self):\n        self._event_thread.start()\n\n    def stop(self):\n        self._event_thread.stop()\n\n    def _on_event(self, event):\n        \"\"\"Handle Fusion events to emit AYON events\"\"\"\n        if not event:\n            return\n\n        what = event[\"what\"]\n\n        # Comp Save\n        if what in {\"Comp_Save\", \"Comp_SaveAs\"}:\n            if not event[\"Rets\"].get(\"success\"):\n                # If the Save action is cancelled it will still emit an\n                # event but with \"success\": False so we ignore those cases\n                return\n            # Comp was saved\n            emit_event(\"save\", data=event)\n            return\n\n        # Comp New\n        elif what in {\"Comp_New\"}:\n            emit_event(\"new\", data=event)\n\n        # Comp Opened\n        elif what in {\"Comp_Opened\"}:\n            emit_event(\"open\", data=event)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.FusionEventThread","title":"<code>FusionEventThread</code>","text":"<p>               Bases: <code>QThread</code></p> <p>QThread which will periodically ping Fusion app for any events. The fusion.UIManager must be set up to be notified of events before they'll be reported by this thread, for example:     fusion.UIManager.AddNotify(\"Comp_Save\", None)</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>class FusionEventThread(QtCore.QThread):\n    \"\"\"QThread which will periodically ping Fusion app for any events.\n    The fusion.UIManager must be set up to be notified of events before they'll\n    be reported by this thread, for example:\n        fusion.UIManager.AddNotify(\"Comp_Save\", None)\n\n    \"\"\"\n\n    on_event = QtCore.Signal(dict)\n\n    def run(self):\n\n        app = getattr(sys.modules[\"__main__\"], \"app\", None)\n        if app is None:\n            # No Fusion app found\n            return\n\n        # As optimization store the GetEvent method directly because every\n        # getattr of UIManager.GetEvent tries to resolve the Remote Function\n        # through the PyRemoteObject\n        get_event = app.UIManager.GetEvent\n        delay = int(os.environ.get(\"AYON_FUSION_CALLBACK_INTERVAL\", 1000))\n        while True:\n            if self.isInterruptionRequested():\n                return\n\n            # Process all events that have been queued up until now\n            while True:\n                event = get_event(False)\n                if not event:\n                    break\n                self.on_event.emit(event)\n\n            # Wait some time before processing events again\n            # to not keep blocking the UI\n            self.msleep(delay)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.FusionHost","title":"<code>FusionHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>class FusionHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"fusion\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self._forced_current_comp = None\n\n    def install(self):\n        \"\"\"Install fusion-specific functionality of AYON.\n\n        This is where you install menus and register families, data\n        and loaders into fusion.\n\n        It is called automatically when installing via\n        `ayon_core.pipeline.install_host(ayon_fusion.api)`\n\n        See the Maya equivalent for inspiration on how to implement this.\n\n        \"\"\"\n        # Remove all handlers associated with the root logger object, because\n        # that one always logs as \"warnings\" incorrectly.\n        for handler in logging.root.handlers[:]:\n            logging.root.removeHandler(handler)\n\n        # Attach default logging handler that prints to active comp\n        logger = logging.getLogger()\n        formatter = logging.Formatter(fmt=\"%(message)s\\n\")\n        handler = FusionLogHandler()\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        logger.setLevel(logging.DEBUG)\n\n        pyblish.api.register_host(\"fusion\")\n        pyblish.api.register_plugin_path(PUBLISH_PATH)\n        log.info(\"Registering Fusion plug-ins..\")\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n\n        # Register events\n        register_event_callback(\"open\", on_after_open)\n        register_event_callback(\"workfile.save.before\", before_workfile_save)\n        register_event_callback(\"save\", on_save)\n        register_event_callback(\"new\", on_new)\n        register_event_callback(\"taskChanged\", on_task_changed)\n\n    # region workfile io api\n    def has_unsaved_changes(self):\n        comp = self.get_current_comp()\n        return comp.GetAttrs()[\"COMPB_Modified\"]\n\n    def get_workfile_extensions(self):\n        return [\".comp\"]\n\n    def save_workfile(self, dst_path=None):\n        comp = self.get_current_comp()\n        comp.Save(dst_path)\n\n    def open_workfile(self, filepath):\n        # Hack to get fusion, see\n        #   ayon_fusion.api.pipeline.get_current_comp()\n        fusion = getattr(sys.modules[\"__main__\"], \"fusion\", None)\n\n        return fusion.LoadComp(filepath)\n\n    def get_current_workfile(self):\n        comp = self.get_current_comp()\n        current_filepath = comp.GetAttrs()[\"COMPS_FileName\"]\n        if not current_filepath:\n            return None\n\n        return current_filepath\n\n    def work_root(self, session):\n        work_dir = session[\"AYON_WORKDIR\"]\n        scene_dir = session.get(\"AVALON_SCENEDIR\")\n        if scene_dir:\n            return os.path.join(work_dir, scene_dir)\n        else:\n            return work_dir\n    # endregion\n\n    @contextlib.contextmanager\n    def maintained_selection(self):\n        from .lib import maintained_selection\n        return maintained_selection()\n\n    def get_containers(self):\n        return ls()\n\n    def update_context_data(self, data, changes):\n        comp = self.get_current_comp()\n        comp.SetData(\"openpype\", data)\n\n    def get_context_data(self):\n        comp = self.get_current_comp()\n        return comp.GetData(\"openpype\") or {}\n\n    def get_current_comp(self):\n        if self._forced_current_comp is not None:\n            return self._forced_current_comp\n        return get_current_comp()\n\n    @contextlib.contextmanager\n    def current_comp(self, comp):\n        \"\"\"Fusion context manager to temporarily enforce 'current' comp.\n\n        During this context the workfile methods like `get_current_workfile`\n        and `save_workfile` will use the specifiec `comp` instead of the actual\n        active comp tab in Fusion itself. This is useful during e.g. publishing\n        where a user may have initiated a publish from one comp and then as\n        the publishing is running they switch to another comp tab.\n        \"\"\"\n        old_comp = self._forced_current_comp\n        try:\n            self._forced_current_comp = comp\n            yield\n        finally:\n            self._forced_current_comp = old_comp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.FusionHost.current_comp","title":"<code>current_comp(comp)</code>","text":"<p>Fusion context manager to temporarily enforce 'current' comp.</p> <p>During this context the workfile methods like <code>get_current_workfile</code> and <code>save_workfile</code> will use the specifiec <code>comp</code> instead of the actual active comp tab in Fusion itself. This is useful during e.g. publishing where a user may have initiated a publish from one comp and then as the publishing is running they switch to another comp tab.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>@contextlib.contextmanager\ndef current_comp(self, comp):\n    \"\"\"Fusion context manager to temporarily enforce 'current' comp.\n\n    During this context the workfile methods like `get_current_workfile`\n    and `save_workfile` will use the specifiec `comp` instead of the actual\n    active comp tab in Fusion itself. This is useful during e.g. publishing\n    where a user may have initiated a publish from one comp and then as\n    the publishing is running they switch to another comp tab.\n    \"\"\"\n    old_comp = self._forced_current_comp\n    try:\n        self._forced_current_comp = comp\n        yield\n    finally:\n        self._forced_current_comp = old_comp\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.FusionHost.install","title":"<code>install()</code>","text":"<p>Install fusion-specific functionality of AYON.</p> <p>This is where you install menus and register families, data and loaders into fusion.</p> <p>It is called automatically when installing via <code>ayon_core.pipeline.install_host(ayon_fusion.api)</code></p> <p>See the Maya equivalent for inspiration on how to implement this.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install fusion-specific functionality of AYON.\n\n    This is where you install menus and register families, data\n    and loaders into fusion.\n\n    It is called automatically when installing via\n    `ayon_core.pipeline.install_host(ayon_fusion.api)`\n\n    See the Maya equivalent for inspiration on how to implement this.\n\n    \"\"\"\n    # Remove all handlers associated with the root logger object, because\n    # that one always logs as \"warnings\" incorrectly.\n    for handler in logging.root.handlers[:]:\n        logging.root.removeHandler(handler)\n\n    # Attach default logging handler that prints to active comp\n    logger = logging.getLogger()\n    formatter = logging.Formatter(fmt=\"%(message)s\\n\")\n    handler = FusionLogHandler()\n    handler.setFormatter(formatter)\n    logger.addHandler(handler)\n    logger.setLevel(logging.DEBUG)\n\n    pyblish.api.register_host(\"fusion\")\n    pyblish.api.register_plugin_path(PUBLISH_PATH)\n    log.info(\"Registering Fusion plug-ins..\")\n\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n    register_inventory_action_path(INVENTORY_PATH)\n\n    # Register events\n    register_event_callback(\"open\", on_after_open)\n    register_event_callback(\"workfile.save.before\", before_workfile_save)\n    register_event_callback(\"save\", on_save)\n    register_event_callback(\"new\", on_new)\n    register_event_callback(\"taskChanged\", on_task_changed)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.imprint_container","title":"<code>imprint_container(tool, name, namespace, context, loader=None)</code>","text":"<p>Imprint a Loader with metadata</p> <p>Containerisation enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>tool</code> <code>object</code> <p>The node in Fusion to imprint as container, usually a Loader.</p> required <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of loader used to produce this container.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def imprint_container(tool,\n                      name,\n                      namespace,\n                      context,\n                      loader=None):\n    \"\"\"Imprint a Loader with metadata\n\n    Containerisation enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        tool (object): The node in Fusion to imprint as container, usually a\n            Loader.\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (str, optional): Name of loader used to produce this container.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    data = [\n        (\"schema\", \"openpype:container-2.0\"),\n        (\"id\", AVALON_CONTAINER_ID),\n        (\"name\", str(name)),\n        (\"namespace\", str(namespace)),\n        (\"loader\", str(loader)),\n        (\"representation\", context[\"representation\"][\"id\"]),\n        (\"project_name\", context[\"project\"][\"name\"]),\n    ]\n\n    for key, value in data:\n        tool.SetData(\"avalon.{}\".format(key), value)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>List containers from active Fusion scene</p> <p>This is the host-equivalent of api.ls(), but instead of listing assets on disk, it lists assets already loaded in Fusion; once loaded they are called 'containers'</p> <p>Yields:</p> Name Type Description <code>dict</code> <p>container</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List containers from active Fusion scene\n\n    This is the host-equivalent of api.ls(), but instead of listing\n    assets on disk, it lists assets already loaded in Fusion; once loaded\n    they are called 'containers'\n\n    Yields:\n        dict: container\n\n    \"\"\"\n    host = registered_host()\n    comp = host.get_current_comp()\n    tools = comp.GetToolList(False).values()\n\n    for tool in tools:\n        container = parse_container(tool)\n        if container:\n            yield container\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pipeline.html#client.ayon_fusion.api.pipeline.parse_container","title":"<code>parse_container(tool)</code>","text":"<p>Returns imprinted container data of a tool</p> <p>This reads the imprinted data from <code>imprint_container</code>.</p> Source code in <code>client/ayon_fusion/api/pipeline.py</code> <pre><code>def parse_container(tool):\n    \"\"\"Returns imprinted container data of a tool\n\n    This reads the imprinted data from `imprint_container`.\n\n    \"\"\"\n\n    data = tool.GetData('avalon')\n    if not isinstance(data, dict):\n        return\n\n    # If not all required data return the empty container\n    required = ['schema', 'id', 'name',\n                'namespace', 'loader', 'representation']\n    if not all(key in data for key in required):\n        return\n\n    container = {key: data[key] for key in required}\n\n    # Add optional keys, like `project_name`\n    optional = [\"project_name\"]\n    for key in optional:\n        if key in data:\n            container[key] = data[key]\n\n    # Store the tool's name\n    container[\"objectName\"] = tool.Name\n\n    # Store reference to the tool object\n    container[\"_tool\"] = tool\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_fusion/api/plugin.html#client.ayon_fusion.api.plugin.GenericCreateSaver","title":"<code>GenericCreateSaver</code>","text":"<p>               Bases: <code>Creator</code></p> Source code in <code>client/ayon_fusion/api/plugin.py</code> <pre><code>class GenericCreateSaver(Creator):\n    default_variants = [\"Main\", \"Mask\"]\n    description = \"Fusion Saver to generate image sequence\"\n    icon = \"fa5.eye\"\n\n    instance_attributes = [\n        \"reviewable\"\n    ]\n\n    settings_category = \"fusion\"\n\n    image_format = \"exr\"\n\n    # TODO: This should be renamed together with Nuke so it is aligned\n    temp_rendering_path_template = (\n        \"{workdir}/renders/fusion/{product[name]}/\"\n        \"{product[name]}.{frame}.{ext}\"\n    )\n\n    def create(self, product_name, instance_data, pre_create_data):\n        self.pass_pre_attributes_to_instance(instance_data, pre_create_data)\n\n        instance = CreatedInstance(\n            product_type=self.product_type,\n            product_name=product_name,\n            data=instance_data,\n            creator=self,\n        )\n        data = instance.data_to_store()\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp):\n            args = (-32768, -32768)  # Magical position numbers\n            saver = comp.AddTool(\"Saver\", *args)\n\n            self._update_tool_with_data(saver, data=data)\n\n        # Register the CreatedInstance\n        self._imprint(saver, data)\n\n        # Insert the transient data\n        instance.transient_data[\"tool\"] = saver\n\n        self._add_instance_to_context(instance)\n\n        return instance\n\n    def collect_instances(self):\n        comp = get_current_comp()\n        tools = comp.GetToolList(False, \"Saver\").values()\n        for tool in tools:\n            data = self.get_managed_tool_data(tool)\n            if not data:\n                continue\n\n            # Add instance\n            created_instance = CreatedInstance.from_existing(data, self)\n\n            # Collect transient data\n            created_instance.transient_data[\"tool\"] = tool\n\n            self._add_instance_to_context(created_instance)\n\n    def update_instances(self, update_list):\n        for created_inst, _changes in update_list:\n            new_data = created_inst.data_to_store()\n            tool = created_inst.transient_data[\"tool\"]\n            self._update_tool_with_data(tool, new_data)\n            self._imprint(tool, new_data)\n\n    def remove_instances(self, instances):\n        for instance in instances:\n            # Remove the tool from the scene\n\n            tool = instance.transient_data[\"tool\"]\n            if tool:\n                tool.Delete()\n\n            # Remove the collected CreatedInstance to remove from UI directly\n            self._remove_instance_from_context(instance)\n\n    def _imprint(self, tool, data):\n        # Save all data in a \"openpype.{key}\" = value data\n\n        # Instance id is the tool's name so we don't need to imprint as data\n        data.pop(\"instance_id\", None)\n\n        active = data.pop(\"active\", None)\n        if active is not None:\n            # Use active value to set the passthrough state\n            tool.SetAttrs({\"TOOLB_PassThrough\": not active})\n\n        for key, value in data.items():\n            tool.SetData(f\"openpype.{key}\", value)\n\n    def _update_tool_with_data(self, tool, data):\n        \"\"\"Update tool node name and output path based on product data\"\"\"\n        if \"productName\" not in data:\n            return\n\n        original_product_name = tool.GetData(\"openpype.productName\")\n        original_format = tool.GetData(\n            \"openpype.creator_attributes.image_format\"\n        )\n\n        product_name = data[\"productName\"]\n        if (\n            original_product_name != product_name\n            or tool.GetData(\"openpype.task\") != data[\"task\"]\n            or tool.GetData(\"openpype.folderPath\") != data[\"folderPath\"]\n            or original_format != data[\"creator_attributes\"][\"image_format\"]\n        ):\n            self._configure_saver_tool(data, tool, product_name)\n\n    def _configure_saver_tool(self, data, tool, product_name):\n        formatting_data = deepcopy(data)\n\n        # get frame padding from anatomy templates\n        frame_padding = self.project_anatomy.templates_obj.frame_padding\n\n        # get output format\n        ext = data[\"creator_attributes\"][\"image_format\"]\n\n        # Product name and type\n        product_type = formatting_data[\"productType\"]\n        f_product_name = formatting_data[\"productName\"]\n\n        # Get instance context entities\n        project_entity = self.create_context.get_current_project_entity()\n        folder_path: str = data[\"folderPath\"]\n        task_name: str = data[\"task\"]\n        folder_entity = None\n        task_entity = None\n        if folder_path:\n            folder_entity = self.create_context.get_folder_entity(folder_path)\n            if task_name:\n                task_entity = self.create_context.get_task_entity(\n                    folder_path, task_name)\n\n        # If the folder path and task do not match the current context then the\n        # workdir is not just the `AYON_WORKDIR`. Hence, we need to actually\n        # compute the resulting workdir\n        if (\n            folder_path == self.create_context.get_current_folder_path()\n            and task_name == self.create_context.get_current_task_name()\n        ):\n            workdir = os.path.normpath(os.getenv(\"AYON_WORKDIR\"))\n        else:\n            # Note: This may error when no task is set for the instance\n            #  however default render template would include task name anyway\n            #  disallowing the instance to have no task set at an earlier stage\n            #  already.\n            workdir = get_workdir(\n                project_entity=project_entity,\n                folder_entity=folder_entity,\n                task_entity=task_entity,\n                host_name=self.create_context.host_name,\n            )\n\n        formatting_data.update({\n            \"workdir\": workdir,\n            \"frame\": \"0\" * frame_padding,\n            \"ext\": ext,\n            \"product\": {\n                \"name\": f_product_name,\n                \"type\": product_type,\n            },\n            # Backwards compatibility\n            \"subset\": f_product_name,\n            \"family\": product_type,\n        })\n\n        # build file path to render\n        temp_rendering_path_template = (\n            self.temp_rendering_path_template\n            .replace(\"{task}\", \"{task[name]}\")\n        )\n\n        extra_data = get_template_data(\n            project_entity,\n            folder_entity,\n            task_entity,\n            host_name=self.create_context.host_name,\n            settings=self.create_context.get_current_project_settings(),\n        )\n        anatomy = self.create_context.project_anatomy\n        extra_data[\"root\"] = anatomy.roots\n        formatting_data.update(extra_data)\n\n        filepath = temp_rendering_path_template.format(**formatting_data)\n\n        comp = get_current_comp()\n        tool[\"Clip\"] = comp.ReverseMapPath(os.path.normpath(filepath))\n\n        # Rename tool\n        if tool.Name != product_name:\n            print(f\"Renaming {tool.Name} -&gt; {product_name}\")\n            tool.SetAttrs({\"TOOLS_Name\": product_name})\n\n    def get_managed_tool_data(self, tool):\n        \"\"\"Return data of the tool if it matches creator identifier\"\"\"\n        data = tool.GetData(\"openpype\")\n        if not isinstance(data, dict):\n            return\n\n        if (\n            data.get(\"creator_identifier\") != self.identifier\n            or data.get(\"id\") not in {\n                AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n            }\n        ):\n            return\n\n        # Get active state from the actual tool state\n        attrs = tool.GetAttrs()\n        passthrough = attrs[\"TOOLB_PassThrough\"]\n        data[\"active\"] = not passthrough\n\n        # Override publisher's UUID generation because tool names are\n        # already unique in Fusion in a comp\n        data[\"instance_id\"] = tool.Name\n\n        return data\n\n    def get_instance_attr_defs(self):\n        \"\"\"Settings for publish page\"\"\"\n        return self.get_pre_create_attr_defs()\n\n    def pass_pre_attributes_to_instance(self, instance_data, pre_create_data):\n        creator_attrs = instance_data[\"creator_attributes\"] = {}\n        for pass_key in pre_create_data.keys():\n            creator_attrs[pass_key] = pre_create_data[pass_key]\n\n    def _get_render_target_enum(self):\n        rendering_targets = {\n            \"local\": \"Local machine rendering\",\n            \"frames\": \"Use existing frames\",\n        }\n        if \"farm_rendering\" in self.instance_attributes:\n            rendering_targets[\"farm\"] = \"Farm rendering\"\n\n        return EnumDef(\n            \"render_target\", items=rendering_targets, label=\"Render target\"\n        )\n\n    def _get_reviewable_bool(self):\n        return BoolDef(\n            \"review\",\n            default=(\"reviewable\" in self.instance_attributes),\n            label=\"Review\",\n        )\n\n    def _get_image_format_enum(self):\n        image_format_options = [\"exr\", \"tga\", \"tif\", \"png\", \"jpg\", \"dpx\"]\n        return EnumDef(\n            \"image_format\",\n            items=image_format_options,\n            default=self.image_format,\n            label=\"Output Image Format\",\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/plugin.html#client.ayon_fusion.api.plugin.GenericCreateSaver.get_instance_attr_defs","title":"<code>get_instance_attr_defs()</code>","text":"<p>Settings for publish page</p> Source code in <code>client/ayon_fusion/api/plugin.py</code> <pre><code>def get_instance_attr_defs(self):\n    \"\"\"Settings for publish page\"\"\"\n    return self.get_pre_create_attr_defs()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/plugin.html#client.ayon_fusion.api.plugin.GenericCreateSaver.get_managed_tool_data","title":"<code>get_managed_tool_data(tool)</code>","text":"<p>Return data of the tool if it matches creator identifier</p> Source code in <code>client/ayon_fusion/api/plugin.py</code> <pre><code>def get_managed_tool_data(self, tool):\n    \"\"\"Return data of the tool if it matches creator identifier\"\"\"\n    data = tool.GetData(\"openpype\")\n    if not isinstance(data, dict):\n        return\n\n    if (\n        data.get(\"creator_identifier\") != self.identifier\n        or data.get(\"id\") not in {\n            AYON_INSTANCE_ID, AVALON_INSTANCE_ID\n        }\n    ):\n        return\n\n    # Get active state from the actual tool state\n    attrs = tool.GetAttrs()\n    passthrough = attrs[\"TOOLB_PassThrough\"]\n    data[\"active\"] = not passthrough\n\n    # Override publisher's UUID generation because tool names are\n    # already unique in Fusion in a comp\n    data[\"instance_id\"] = tool.Name\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/api/pulse.html","title":"pulse","text":""},{"location":"autoapi/client/ayon_fusion/api/pulse.html#client.ayon_fusion.api.pulse.FusionPulse","title":"<code>FusionPulse</code>","text":"<p>               Bases: <code>QObject</code></p> <p>A Timer that checks whether host app is still alive.</p> <p>This checks whether the Fusion process is still active at a certain interval. This is useful due to how Fusion runs its scripts. Each script runs in its own environment and process (a <code>fusionscript</code> process each). If Fusion would go down and we have a UI process running at the same time then it can happen that the <code>fusionscript.exe</code> will remain running in the background in limbo due to e.g. a Qt interface's QApplication that keeps running infinitely.</p> Warning <p>When the host is not detected this will automatically exit the current process.</p> Source code in <code>client/ayon_fusion/api/pulse.py</code> <pre><code>class FusionPulse(QtCore.QObject):\n    \"\"\"A Timer that checks whether host app is still alive.\n\n    This checks whether the Fusion process is still active at a certain\n    interval. This is useful due to how Fusion runs its scripts. Each script\n    runs in its own environment and process (a `fusionscript` process each).\n    If Fusion would go down and we have a UI process running at the same time\n    then it can happen that the `fusionscript.exe` will remain running in the\n    background in limbo due to e.g. a Qt interface's QApplication that keeps\n    running infinitely.\n\n    Warning:\n        When the host is not detected this will automatically exit\n        the current process.\n\n    \"\"\"\n\n    def __init__(self, parent=None):\n        super(FusionPulse, self).__init__(parent=parent)\n        self._thread = PulseThread(parent=self)\n        self._thread.no_response.connect(self.on_no_response)\n\n    def on_no_response(self):\n        print(\"Pulse detected no response from Fusion..\")\n        sys.exit(1)\n\n    def start(self):\n        self._thread.start()\n\n    def stop(self):\n        self._thread.requestInterruption()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/deploy/index.html","title":"deploy","text":""},{"location":"autoapi/client/ayon_fusion/deploy/MenuScripts/index.html","title":"MenuScripts","text":""},{"location":"autoapi/client/ayon_fusion/deploy/MenuScripts/install_pyside2.html","title":"install_pyside2","text":""},{"location":"autoapi/client/ayon_fusion/deploy/MenuScripts/launch_menu.html","title":"launch_menu","text":""},{"location":"autoapi/client/ayon_fusion/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_launch_menu_hook.html","title":"pre_fusion_launch_menu_hook","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_launch_menu_hook.html#client.ayon_fusion.hooks.pre_fusion_launch_menu_hook.FusionLaunchMenuHook","title":"<code>FusionLaunchMenuHook</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Launch AYON menu on start of Fusion</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_launch_menu_hook.py</code> <pre><code>class FusionLaunchMenuHook(PreLaunchHook):\n    \"\"\"Launch AYON menu on start of Fusion\"\"\"\n    app_groups = [\"fusion\"]\n    order = 9\n\n    def execute(self):\n        # Prelaunch hook is optional\n        settings = self.data[\"project_settings\"][\"fusion\"]\n        if not settings[\"hooks\"][\"FusionLaunchMenuHook\"][\"enabled\"]:\n            return\n\n        variant = self.application.name\n        if variant.isnumeric():\n            version = int(variant)\n            if version &lt; 18:\n                print(\"Skipping launch of OpenPype menu on Fusion start \"\n                      \"because Fusion version below 18.0 does not support \"\n                      \"/execute argument on launch. \"\n                      f\"Version detected: {version}\")\n                return\n        else:\n            print(f\"Application variant is not numeric: {variant}. \"\n                  \"Validation for Fusion version 18+ for /execute \"\n                  \"prelaunch argument skipped.\")\n\n        path = os.path.join(FUSION_ADDON_ROOT,\n                            \"deploy\",\n                            \"MenuScripts\",\n                            \"launch_menu.py\").replace(\"\\\\\", \"/\")\n        script = f\"fusion:RunScript('{path}')\"\n        self.launch_context.launch_args.extend([\"/execute\", script])\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_profile_hook.html","title":"pre_fusion_profile_hook","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_profile_hook.html#client.ayon_fusion.hooks.pre_fusion_profile_hook.FusionCopyPrefsPrelaunch","title":"<code>FusionCopyPrefsPrelaunch</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Prepares local Fusion profile directory, copies existing Fusion profile. This also sets FUSION MasterPrefs variable, which is used to apply Master.prefs file to override some Fusion profile settings to:     - enable the AYON menu     - force Python 3 over Python 2     - force English interface Master.prefs is defined in openpype/hosts/fusion/deploy/fusion_shared.prefs</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_profile_hook.py</code> <pre><code>class FusionCopyPrefsPrelaunch(PreLaunchHook):\n    \"\"\"\n    Prepares local Fusion profile directory, copies existing Fusion profile.\n    This also sets FUSION MasterPrefs variable, which is used\n    to apply Master.prefs file to override some Fusion profile settings to:\n        - enable the AYON menu\n        - force Python 3 over Python 2\n        - force English interface\n    Master.prefs is defined in openpype/hosts/fusion/deploy/fusion_shared.prefs\n    \"\"\"\n\n    app_groups = {\"fusion\"}\n    order = 2\n    launch_types = {LaunchTypes.local,\n                    LaunchTypes.farm_render,\n                    # This seems to be incorrectly configured for\n                    # ayon_applications addon, see `ayon_applications/#2`\n                    LaunchTypes.farm_publish}\n\n    def get_fusion_profile_name(self, profile_version) -&gt; str:\n        # Returns 'Default', unless FUSION16_PROFILE is set\n        return os.getenv(f\"FUSION{profile_version}_PROFILE\", \"Default\")\n\n    def get_fusion_profile_dir(self, profile_version) -&gt; Path:\n        # Get FUSION_PROFILE_DIR variable\n        fusion_profile = self.get_fusion_profile_name(profile_version)\n        fusion_var_prefs_dir = os.getenv(\n            f\"FUSION{profile_version}_PROFILE_DIR\"\n        )\n\n        # Check if FUSION_PROFILE_DIR exists\n        if fusion_var_prefs_dir and Path(fusion_var_prefs_dir).is_dir():\n            fu_prefs_dir = Path(fusion_var_prefs_dir, fusion_profile)\n            self.log.info(f\"{fusion_var_prefs_dir} is set to {fu_prefs_dir}\")\n            return fu_prefs_dir\n\n    def get_profile_source(self, profile_version) -&gt; Path:\n        \"\"\"Get Fusion preferences profile location.\n        See Per-User_Preferences_and_Paths on VFXpedia for reference.\n        \"\"\"\n        fusion_profile = self.get_fusion_profile_name(profile_version)\n        profile_source = self.get_fusion_profile_dir(profile_version)\n        if profile_source:\n            return profile_source\n        # otherwise get default location of the profile folder\n        fu_prefs_dir = f\"Blackmagic Design/Fusion/Profiles/{fusion_profile}\"\n        if platform.system() == \"Windows\":\n            profile_source = Path(os.getenv(\"AppData\"), fu_prefs_dir)\n        elif platform.system() == \"Darwin\":\n            profile_source = Path(\n                \"~/Library/Application Support/\", fu_prefs_dir\n            ).expanduser()\n        elif platform.system() == \"Linux\":\n            profile_source = Path(\"~/.fusion\", fu_prefs_dir).expanduser()\n        self.log.info(\n            f\"Locating source Fusion prefs directory: {profile_source}\"\n        )\n        return profile_source\n\n    def get_copy_fusion_prefs_settings(self):\n        # Get copy preferences options from the global application settings\n\n        copy_fusion_settings = self.data[\"project_settings\"][\"fusion\"].get(\n            \"copy_fusion_settings\", {}\n        )\n        if not copy_fusion_settings:\n            self.log.error(\"Copy prefs settings not found\")\n        copy_status = copy_fusion_settings.get(\"copy_status\", False)\n        force_sync = copy_fusion_settings.get(\"force_sync\", False)\n        copy_path = copy_fusion_settings.get(\"copy_path\") or None\n        if copy_path:\n            copy_path = Path(copy_path).expanduser()\n        return copy_status, copy_path, force_sync\n\n    def copy_fusion_profile(\n        self, copy_from: Path, copy_to: Path, force_sync: bool\n    ) -&gt; None:\n        \"\"\"On the first Fusion launch copy the contents of Fusion profile\n        directory to the working predefined location. If the Openpype profile\n        folder exists, skip copying, unless re-sync is checked.\n        If the prefs were not copied on the first launch,\n        clean Fusion profile will be created in fu_profile_dir.\n        \"\"\"\n        if copy_to.exists() and not force_sync:\n            self.log.info(\n                \"Destination Fusion preferences folder already exists: \"\n                f\"{copy_to} \"\n            )\n            return\n        self.log.info(\"Starting copying Fusion preferences\")\n        self.log.debug(f\"force_sync option is set to {force_sync}\")\n        try:\n            copy_to.mkdir(exist_ok=True, parents=True)\n        except PermissionError:\n            self.log.warning(f\"Creating the folder not permitted at {copy_to}\")\n            return\n        if not copy_from.exists():\n            self.log.warning(f\"Fusion preferences not found in {copy_from}\")\n            return\n        for file in copy_from.iterdir():\n            if file.suffix in (\n                \".prefs\",\n                \".def\",\n                \".blocklist\",\n                \".fu\",\n                \".toolbars\",\n            ):\n                # convert Path to str to be compatible with Python 3.6+\n                shutil.copy(str(file), str(copy_to))\n        self.log.info(\n            f\"Successfully copied preferences: {copy_from} to {copy_to}\"\n        )\n\n    def execute(self):\n        (\n            copy_status,\n            fu_profile_dir,\n            force_sync,\n        ) = self.get_copy_fusion_prefs_settings()\n\n        # Get launched application context and return correct app version\n        app_name = self.launch_context.env.get(\"AYON_APP_NAME\")\n        app_version = get_fusion_version(app_name)\n        if app_version is None:\n            version_names = \", \".join(str(x) for x in FUSION_VERSIONS_DICT)\n            raise ApplicationLaunchFailed(\n                \"Unable to detect valid Fusion version number from app \"\n                f\"name: {app_name}.\\nMake sure to include at least a digit \"\n                \"to indicate the Fusion version like '18'.\\n\"\n                f\"Detectable Fusion versions are: {version_names}\"\n            )\n\n        _, profile_version = FUSION_VERSIONS_DICT[app_version]\n        fu_profile = self.get_fusion_profile_name(profile_version)\n\n        # do a copy of Fusion profile if copy_status toggle is enabled\n        if copy_status and fu_profile_dir is not None:\n            profile_source = self.get_profile_source(profile_version)\n            dest_folder = Path(fu_profile_dir, fu_profile)\n            self.copy_fusion_profile(profile_source, dest_folder, force_sync)\n\n        # Add temporary profile directory variables to customize Fusion\n        # to define where it can read custom scripts and tools from\n        fu_profile_dir_variable = f\"FUSION{profile_version}_PROFILE_DIR\"\n        self.log.info(f\"Setting {fu_profile_dir_variable}: {fu_profile_dir}\")\n        self.launch_context.env[fu_profile_dir_variable] = str(fu_profile_dir)\n\n        # Add custom Fusion Master Prefs and the temporary\n        # profile directory variables to customize Fusion\n        # to define where it can read custom scripts and tools from\n        master_prefs_variable = f\"FUSION{profile_version}_MasterPrefs\"\n\n        master_prefs = Path(\n            FUSION_ADDON_ROOT, \"deploy\", \"ayon\", \"fusion_shared.prefs\")\n\n        self.log.info(f\"Setting {master_prefs_variable}: {master_prefs}\")\n        self.launch_context.env[master_prefs_variable] = str(master_prefs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_profile_hook.html#client.ayon_fusion.hooks.pre_fusion_profile_hook.FusionCopyPrefsPrelaunch.copy_fusion_profile","title":"<code>copy_fusion_profile(copy_from, copy_to, force_sync)</code>","text":"<p>On the first Fusion launch copy the contents of Fusion profile directory to the working predefined location. If the Openpype profile folder exists, skip copying, unless re-sync is checked. If the prefs were not copied on the first launch, clean Fusion profile will be created in fu_profile_dir.</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_profile_hook.py</code> <pre><code>def copy_fusion_profile(\n    self, copy_from: Path, copy_to: Path, force_sync: bool\n) -&gt; None:\n    \"\"\"On the first Fusion launch copy the contents of Fusion profile\n    directory to the working predefined location. If the Openpype profile\n    folder exists, skip copying, unless re-sync is checked.\n    If the prefs were not copied on the first launch,\n    clean Fusion profile will be created in fu_profile_dir.\n    \"\"\"\n    if copy_to.exists() and not force_sync:\n        self.log.info(\n            \"Destination Fusion preferences folder already exists: \"\n            f\"{copy_to} \"\n        )\n        return\n    self.log.info(\"Starting copying Fusion preferences\")\n    self.log.debug(f\"force_sync option is set to {force_sync}\")\n    try:\n        copy_to.mkdir(exist_ok=True, parents=True)\n    except PermissionError:\n        self.log.warning(f\"Creating the folder not permitted at {copy_to}\")\n        return\n    if not copy_from.exists():\n        self.log.warning(f\"Fusion preferences not found in {copy_from}\")\n        return\n    for file in copy_from.iterdir():\n        if file.suffix in (\n            \".prefs\",\n            \".def\",\n            \".blocklist\",\n            \".fu\",\n            \".toolbars\",\n        ):\n            # convert Path to str to be compatible with Python 3.6+\n            shutil.copy(str(file), str(copy_to))\n    self.log.info(\n        f\"Successfully copied preferences: {copy_from} to {copy_to}\"\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_profile_hook.html#client.ayon_fusion.hooks.pre_fusion_profile_hook.FusionCopyPrefsPrelaunch.get_profile_source","title":"<code>get_profile_source(profile_version)</code>","text":"<p>Get Fusion preferences profile location. See Per-User_Preferences_and_Paths on VFXpedia for reference.</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_profile_hook.py</code> <pre><code>def get_profile_source(self, profile_version) -&gt; Path:\n    \"\"\"Get Fusion preferences profile location.\n    See Per-User_Preferences_and_Paths on VFXpedia for reference.\n    \"\"\"\n    fusion_profile = self.get_fusion_profile_name(profile_version)\n    profile_source = self.get_fusion_profile_dir(profile_version)\n    if profile_source:\n        return profile_source\n    # otherwise get default location of the profile folder\n    fu_prefs_dir = f\"Blackmagic Design/Fusion/Profiles/{fusion_profile}\"\n    if platform.system() == \"Windows\":\n        profile_source = Path(os.getenv(\"AppData\"), fu_prefs_dir)\n    elif platform.system() == \"Darwin\":\n        profile_source = Path(\n            \"~/Library/Application Support/\", fu_prefs_dir\n        ).expanduser()\n    elif platform.system() == \"Linux\":\n        profile_source = Path(\"~/.fusion\", fu_prefs_dir).expanduser()\n    self.log.info(\n        f\"Locating source Fusion prefs directory: {profile_source}\"\n    )\n    return profile_source\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_setup.html","title":"pre_fusion_setup","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_fusion_setup.html#client.ayon_fusion.hooks.pre_fusion_setup.FusionPrelaunch","title":"<code>FusionPrelaunch</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Prepares AYON Fusion environment. Requires correct Python home variable to be defined in the environment settings for Fusion to point at a valid Python 3 build for Fusion. Python3 versions that are supported by Fusion: Fusion 9, 16, 17 : Python 3.6 Fusion 18        : Python 3.6 - 3.10</p> Source code in <code>client/ayon_fusion/hooks/pre_fusion_setup.py</code> <pre><code>class FusionPrelaunch(PreLaunchHook):\n    \"\"\"\n    Prepares AYON Fusion environment.\n    Requires correct Python home variable to be defined in the environment\n    settings for Fusion to point at a valid Python 3 build for Fusion.\n    Python3 versions that are supported by Fusion:\n    Fusion 9, 16, 17 : Python 3.6\n    Fusion 18        : Python 3.6 - 3.10\n    \"\"\"\n\n    app_groups = {\"fusion\"}\n    order = 1\n    launch_types = {LaunchTypes.local,\n                    LaunchTypes.farm_render,\n                    # This seems to be incorrectly configured for\n                    # ayon_applications addon, see `ayon_applications/#2`\n                    LaunchTypes.farm_publish}\n\n    def execute(self):\n        # making sure python 3 is installed at provided path\n        # Py 3.3-3.10 for Fusion 18+ or Py 3.6 for Fu 16-17\n        app_data = self.launch_context.env.get(\"AYON_APP_NAME\")\n        app_version = get_fusion_version(app_data)\n        if not app_version:\n            self.log.warning(\n                f\"Fusion version information not found for '{app_data}'.\\n\"\n                \"The key field in the 'applications/fusion/variants' should \"\n                \"consist of a number, corresponding to major Fusion version. \"\n                f\"Assuming fallback version: {FUSION_FALLBACK_VERSION}.\"\n            )\n            app_version = FUSION_FALLBACK_VERSION\n\n        py3_var, _ = FUSION_VERSIONS_DICT[app_version]\n        fusion_python3_home = self.launch_context.env.get(py3_var, \"\")\n\n        for path in fusion_python3_home.split(os.pathsep):\n            # Allow defining multiple paths, separated by os.pathsep,\n            # to allow \"fallback\" to other path.\n            # But make to set only a single path as final variable.\n            py3_dir = os.path.normpath(path)\n            if os.path.isdir(py3_dir):\n                break\n        else:\n            raise ApplicationLaunchFailed(\n                \"Python 3 is not installed at the provided path.\\n\"\n                \"Make sure the environment in fusion settings has \"\n                \"'FUSION_PYTHON3_HOME' set correctly and make sure \"\n                \"Python 3 is installed in the given path.\"\n                f\"\\n\\nPYTHON PATH: {fusion_python3_home}\"\n            )\n\n        self.log.info(f\"Setting {py3_var}: '{py3_dir}'...\")\n        self.launch_context.env[py3_var] = py3_dir\n\n        # Fusion 18+ requires FUSION_PYTHON3_HOME to also be on PATH\n        if app_version &gt;= 18:\n            self.launch_context.env[\"PATH\"] += os.pathsep + py3_dir\n\n        self.launch_context.env[py3_var] = py3_dir\n\n        # for hook installing PySide2\n        self.data[\"fusion_python3_home\"] = py3_dir\n\n        self.log.info(f\"Setting AYON_FUSION_ROOT: {FUSION_ADDON_ROOT}\")\n        self.launch_context.env[\"AYON_FUSION_ROOT\"] = FUSION_ADDON_ROOT\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/hooks/pre_pyside_install.html","title":"pre_pyside_install","text":""},{"location":"autoapi/client/ayon_fusion/hooks/pre_pyside_install.html#client.ayon_fusion.hooks.pre_pyside_install.InstallPySideToFusion","title":"<code>InstallPySideToFusion</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Automatically installs Qt binding to fusion's python packages.</p> <p>Check if fusion has installed PySide2 and will try to install if not.</p> <p>For pipeline implementation is required to have Qt binding installed in fusion's python packages.</p> Source code in <code>client/ayon_fusion/hooks/pre_pyside_install.py</code> <pre><code>class InstallPySideToFusion(PreLaunchHook):\n    \"\"\"Automatically installs Qt binding to fusion's python packages.\n\n    Check if fusion has installed PySide2 and will try to install if not.\n\n    For pipeline implementation is required to have Qt binding installed in\n    fusion's python packages.\n    \"\"\"\n\n    app_groups = {\"fusion\"}\n    order = 2\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Prelaunch hook is not crucial\n        try:\n            settings = self.data[\"project_settings\"][\"fusion\"]\n            if not settings[\"hooks\"][\"InstallPySideToFusion\"][\"enabled\"]:\n                return\n            self.inner_execute()\n        except Exception:\n            self.log.warning(\n                \"Processing of {} crashed.\".format(self.__class__.__name__),\n                exc_info=True\n            )\n\n    def inner_execute(self):\n        self.log.debug(\"Check for PySide2 installation.\")\n\n        fusion_python3_home = self.data.get(\"fusion_python3_home\")\n        if not fusion_python3_home:\n            self.log.warning(\"'fusion_python3_home' was not provided. \"\n                             \"Installation of PySide2 not possible\")\n            return\n\n        if platform.system().lower() == \"windows\":\n            exe_filenames = [\"python.exe\"]\n        else:\n            exe_filenames = [\"python3\", \"python\"]\n\n        for exe_filename in exe_filenames:\n            python_executable = os.path.join(fusion_python3_home, exe_filename)\n            if os.path.exists(python_executable):\n                break\n\n        if not os.path.exists(python_executable):\n            self.log.warning(\n                \"Couldn't find python executable for fusion. {}\".format(\n                    python_executable\n                )\n            )\n            return\n\n        # Check if PySide2 is installed and skip if yes\n        if self._is_pyside_installed(python_executable):\n            self.log.debug(\"Fusion has already installed PySide2.\")\n            return\n\n        self.log.debug(\"Installing PySide2.\")\n        # Install PySide2 in fusion's python\n        if self._windows_require_permissions(\n                os.path.dirname(python_executable)):\n            result = self._install_pyside_windows(python_executable)\n        else:\n            result = self._install_pyside(python_executable)\n\n        if result:\n            self.log.info(\"Successfully installed PySide2 module to fusion.\")\n        else:\n            self.log.warning(\"Failed to install PySide2 module to fusion.\")\n\n    def _install_pyside_windows(self, python_executable):\n        \"\"\"Install PySide2 python module to fusion's python.\n\n        Installation requires administration rights that's why it is required\n        to use \"pywin32\" module which can execute command's and ask for\n        administration rights.\n        \"\"\"\n        try:\n            import win32con\n            import win32process\n            import win32event\n            import pywintypes\n            from win32comext.shell.shell import ShellExecuteEx\n            from win32comext.shell import shellcon\n        except Exception:\n            self.log.warning(\"Couldn't import \\\"pywin32\\\" modules\")\n            return False\n\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install PySide2 and argument\n            #   \"--ignore-installed\" is to force install module to fusion's\n            #   site-packages and make sure it is binary compatible\n            parameters = \"-m pip install --ignore-installed PySide2\"\n\n            # Execute command and ask for administrator's rights\n            process_info = ShellExecuteEx(\n                nShow=win32con.SW_SHOWNORMAL,\n                fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,\n                lpVerb=\"runas\",\n                lpFile=python_executable,\n                lpParameters=parameters,\n                lpDirectory=os.path.dirname(python_executable)\n            )\n            process_handle = process_info[\"hProcess\"]\n            win32event.WaitForSingleObject(process_handle,\n                                           win32event.INFINITE)\n            returncode = win32process.GetExitCodeProcess(process_handle)\n            return returncode == 0\n        except pywintypes.error:\n            return False\n\n    def _install_pyside(self, python_executable):\n        \"\"\"Install PySide2 python module to fusion's python.\"\"\"\n        try:\n            # Parameters\n            # - use \"-m pip\" as module pip to install PySide2 and argument\n            #   \"--ignore-installed\" is to force install module to fusion's\n            #   site-packages and make sure it is binary compatible\n            env = dict(os.environ)\n            del env['PYTHONPATH']\n            args = [\n                python_executable,\n                \"-m\",\n                \"pip\",\n                \"install\",\n                \"--ignore-installed\",\n                \"PySide2\",\n            ]\n            process = subprocess.Popen(\n                args, stdout=subprocess.PIPE, universal_newlines=True,\n                env=env\n            )\n            process.communicate()\n            return process.returncode == 0\n        except PermissionError:\n            self.log.warning(\n                \"Permission denied with command:\"\n                \"\\\"{}\\\".\".format(\" \".join(args))\n            )\n        except OSError as error:\n            self.log.warning(f\"OS error has occurred: \\\"{error}\\\".\")\n        except subprocess.SubprocessError:\n            pass\n\n    def _is_pyside_installed(self, python_executable):\n        \"\"\"Check if PySide2 module is in fusion's pip list.\"\"\"\n        args = [python_executable, \"-c\", \"from qtpy import QtWidgets\"]\n        process = subprocess.Popen(args,\n                                   stdout=subprocess.PIPE,\n                                   stderr=subprocess.PIPE)\n        _, stderr = process.communicate()\n        stderr = stderr.decode()\n        if stderr:\n            return False\n        return True\n\n    def _windows_require_permissions(self, dirpath):\n        if platform.system().lower() != \"windows\":\n            return False\n\n        try:\n            # Attempt to create a temporary file in the folder\n            temp_file_path = os.path.join(dirpath, uuid.uuid4().hex)\n            with open(temp_file_path, \"w\"):\n                pass\n            os.remove(temp_file_path)  # Clean up temporary file\n            return False\n\n        except PermissionError:\n            return True\n\n        except BaseException as exc:\n            print((\"Failed to determine if root requires permissions.\"\n                   \"Unexpected error: {}\").format(exc))\n            return False\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_fusion/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_fusion/plugins/create/create_image_saver.html","title":"create_image_saver","text":""},{"location":"autoapi/client/ayon_fusion/plugins/create/create_image_saver.html#client.ayon_fusion.plugins.create.create_image_saver.CreateImageSaver","title":"<code>CreateImageSaver</code>","text":"<p>               Bases: <code>GenericCreateSaver</code></p> <p>Fusion Saver to generate single image.</p> <p>Created to explicitly separate single ('image') or     multi frame('render) outputs.</p> <p>This might be temporary creator until 'alias' functionality will be implemented to limit creation of additional product types with similar, but not the same workflows.</p> Source code in <code>client/ayon_fusion/plugins/create/create_image_saver.py</code> <pre><code>class CreateImageSaver(GenericCreateSaver):\n    \"\"\"Fusion Saver to generate single image.\n\n     Created to explicitly separate single ('image') or\n        multi frame('render) outputs.\n\n    This might be temporary creator until 'alias' functionality will be\n    implemented to limit creation of additional product types with similar, but\n    not the same workflows.\n    \"\"\"\n    identifier = \"io.openpype.creators.fusion.imagesaver\"\n    label = \"Image (saver)\"\n    name = \"image\"\n    product_type = \"image\"\n    product_base_type = \"image\"\n    description = \"Fusion Saver to generate a single image file\"\n\n    default_frame = 0\n\n    def get_detail_description(self):\n        return inspect.cleandoc(\n            \"\"\"Fusion Saver to generate a single image file.\n\n            This creator is expected for publishing of single frame `image` \n            product type.\n\n            Artist should provide frame number (integer) to specify which frame\n            should be published. It must be inside of global timeline frame \n            range.\n\n            Supports local and deadline rendering.\n\n            Supports selection from predefined set of output file extensions:\n            - exr\n            - tga\n            - png\n            - tif\n            - jpg\n\n            Created to explicitly separate single frame ('image') or\n            multi frame ('render') outputs.\n            \"\"\"\n        )\n\n    def get_pre_create_attr_defs(self):\n        \"\"\"Settings for create page\"\"\"\n        attr_defs = [\n            self._get_render_target_enum(),\n            self._get_reviewable_bool(),\n            self._get_frame_int(),\n            self._get_image_format_enum(),\n        ]\n        return attr_defs\n\n    def _get_frame_int(self):\n        return NumberDef(\n            \"frame\",\n            default=self.default_frame,\n            label=\"Frame\",\n            tooltip=\"Set frame to be rendered, must be inside of global \"\n                    \"timeline range\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_image_saver.html#client.ayon_fusion.plugins.create.create_image_saver.CreateImageSaver.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<p>Settings for create page</p> Source code in <code>client/ayon_fusion/plugins/create/create_image_saver.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    \"\"\"Settings for create page\"\"\"\n    attr_defs = [\n        self._get_render_target_enum(),\n        self._get_reviewable_bool(),\n        self._get_frame_int(),\n        self._get_image_format_enum(),\n    ]\n    return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_saver.html","title":"create_saver","text":""},{"location":"autoapi/client/ayon_fusion/plugins/create/create_saver.html#client.ayon_fusion.plugins.create.create_saver.CreateSaver","title":"<code>CreateSaver</code>","text":"<p>               Bases: <code>GenericCreateSaver</code></p> <p>Fusion Saver to generate image sequence of 'render' product type.</p> <p>Original Saver creator targeted for 'render' product type. It uses original not to descriptive name because of values in Settings.</p> Source code in <code>client/ayon_fusion/plugins/create/create_saver.py</code> <pre><code>class CreateSaver(GenericCreateSaver):\n    \"\"\"Fusion Saver to generate image sequence of 'render' product type.\n\n     Original Saver creator targeted for 'render' product type. It uses\n     original not to descriptive name because of values in Settings.\n    \"\"\"\n    identifier = \"io.openpype.creators.fusion.saver\"\n    label = \"Render (saver)\"\n    name = \"render\"\n    product_type = \"render\"\n    product_base_type = \"render\"\n    description = \"Fusion Saver to generate image sequence\"\n\n    default_frame_range_option = \"current_context\"\n\n    def get_detail_description(self):\n        return inspect.cleandoc(\n            \"\"\"Fusion Saver to generate image sequence.\n\n            This creator is expected for publishing of image sequences for \n            'render' product type. (But can publish even single frame \n            'render'.)\n\n            Select what should be source of render range:\n            - \"Current Folder context\" - values set on folder on AYON server\n            - \"From render in/out\" - from node itself\n            - \"From composition timeline\" - from timeline\n\n            Supports local and farm rendering.\n\n            Supports selection from predefined set of output file extensions:\n            - exr\n            - tga\n            - png\n            - tif\n            - jpg\n            \"\"\"\n        )\n\n    def register_callbacks(self):\n        self.create_context.add_value_changed_callback(self.on_values_changed)\n\n    def on_values_changed(self, event):\n        \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n\n        for instance_change in event[\"changes\"]:\n            # First check if there's a change we want to respond to\n            instance = instance_change[\"instance\"]\n            if instance is None:\n                # Change is on context\n                continue\n\n            if instance[\"creator_identifier\"] != self.identifier:\n                continue\n\n            value_changes = instance_change[\"changes\"]\n            if (\n                \"frame_range_source\"\n                not in value_changes.get(\"creator_attributes\", {})\n            ):\n                continue\n\n            # Update the attribute definitions\n            new_attrs = self.get_attr_defs_for_instance(instance)\n            instance.set_create_attr_defs(new_attrs)\n\n    def get_pre_create_attr_defs(self):\n        \"\"\"Settings for create page\"\"\"\n        attr_defs = [\n            self._get_render_target_enum(),\n            self._get_reviewable_bool(),\n            self._get_frame_range_enum(),\n            self._get_image_format_enum(),\n            *self._get_custom_frame_range_attribute_defs()\n        ]\n        return attr_defs\n\n    def get_attr_defs_for_instance(self, instance):\n        return [\n            self._get_render_target_enum(),\n            self._get_reviewable_bool(),\n            self._get_frame_range_enum(),\n            self._get_image_format_enum(),\n            *self._get_custom_frame_range_attribute_defs(instance)\n        ]\n\n    def _get_frame_range_enum(self):\n        frame_range_options = {\n            \"current_task\": \"Current context\",\n            \"render_range\": \"From render in/out\",\n            \"comp_range\": \"From composition timeline\",\n            \"custom_range\": \"Custom frame range\",\n        }\n\n        return EnumDef(\n            \"frame_range_source\",\n            items=frame_range_options,\n            label=\"Frame range source\",\n            default=self.default_frame_range_option\n        )\n\n    @staticmethod\n    def _get_custom_frame_range_attribute_defs(instance=None) -&gt; list:\n\n        # If an instance is provided and 'custom_range' is not the frame\n        # range source, then we will disable the custom frame range attributes\n        custom_enabled = True\n        if instance is not None:\n            frame_range_source = instance.get(\n                \"creator_attributes\", {}).get(\"frame_range_source\")\n            custom_enabled = frame_range_source == \"custom_range\"\n\n        # Define custom frame range defaults based on current comp\n        # timeline settings (if a comp is currently open)\n        comp = get_current_comp()\n        if comp is not None:\n            attrs = comp.GetAttrs()\n            frame_defaults = {\n                \"frameStart\": int(attrs[\"COMPN_GlobalStart\"]),\n                \"frameEnd\": int(attrs[\"COMPN_GlobalEnd\"]),\n                \"handleStart\": int(\n                    attrs[\"COMPN_RenderStart\"] - attrs[\"COMPN_GlobalStart\"]\n                ),\n                \"handleEnd\": int(\n                    attrs[\"COMPN_GlobalEnd\"] - attrs[\"COMPN_RenderEnd\"]\n                ),\n            }\n        else:\n            frame_defaults = {\n                \"frameStart\": 1001,\n                \"frameEnd\": 1100,\n                \"handleStart\": 0,\n                \"handleEnd\": 0\n            }\n\n        attr_defs = []\n        if custom_enabled:\n            # UILabelDef does not support `hidden` argument so we exclude it\n            # manually\n            attr_defs.append(\n                UILabelDef(\n                    label=\"&lt;br&gt;&lt;b&gt;Custom Frame Range&lt;/b&gt;\",\n                ),\n            )\n\n        attr_defs.extend([\n            NumberDef(\n                \"custom_frameStart\",\n                label=\"Frame Start\",\n                default=frame_defaults[\"frameStart\"],\n                minimum=0,\n                decimals=0,\n                tooltip=(\n                    \"Set the start frame for the export.\\n\"\n                    \"Only used if frame range source is 'Custom frame range'.\"\n                ),\n                visible=custom_enabled\n            ),\n            NumberDef(\n                \"custom_frameEnd\",\n                label=\"Frame End\",\n                default=frame_defaults[\"frameEnd\"],\n                minimum=0,\n                decimals=0,\n                tooltip=(\n                    \"Set the end frame for the export.\\n\"\n                    \"Only used if frame range source is 'Custom frame range'.\"\n                ),\n                visible=custom_enabled\n            ),\n            NumberDef(\n                \"custom_handleStart\",\n                label=\"Handle Start\",\n                default=frame_defaults[\"handleStart\"],\n                minimum=0,\n                decimals=0,\n                tooltip=(\n                    \"Set the start handles for the export, this will be \"\n                    \"added before the start frame.\\n\"\n                    \"Only used if frame range source is 'Custom frame range'.\"\n                ),\n                visible=custom_enabled\n            ),\n            NumberDef(\n                \"custom_handleEnd\",\n                label=\"Handle End\",\n                default=frame_defaults[\"handleEnd\"],\n                minimum=0,\n                decimals=0,\n                tooltip=(\n                    \"Set the end handles for the export, this will be added \"\n                    \"after the end frame.\\n\"\n                    \"Only used if frame range source is 'Custom frame range'.\"\n                ),\n                visible=custom_enabled\n            )\n        ])\n        return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_saver.html#client.ayon_fusion.plugins.create.create_saver.CreateSaver.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<p>Settings for create page</p> Source code in <code>client/ayon_fusion/plugins/create/create_saver.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    \"\"\"Settings for create page\"\"\"\n    attr_defs = [\n        self._get_render_target_enum(),\n        self._get_reviewable_bool(),\n        self._get_frame_range_enum(),\n        self._get_image_format_enum(),\n        *self._get_custom_frame_range_attribute_defs()\n    ]\n    return attr_defs\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_saver.html#client.ayon_fusion.plugins.create.create_saver.CreateSaver.on_values_changed","title":"<code>on_values_changed(event)</code>","text":"<p>Update instance attribute definitions on attribute changes.</p> Source code in <code>client/ayon_fusion/plugins/create/create_saver.py</code> <pre><code>def on_values_changed(self, event):\n    \"\"\"Update instance attribute definitions on attribute changes.\"\"\"\n\n    for instance_change in event[\"changes\"]:\n        # First check if there's a change we want to respond to\n        instance = instance_change[\"instance\"]\n        if instance is None:\n            # Change is on context\n            continue\n\n        if instance[\"creator_identifier\"] != self.identifier:\n            continue\n\n        value_changes = instance_change[\"changes\"]\n        if (\n            \"frame_range_source\"\n            not in value_changes.get(\"creator_attributes\", {})\n        ):\n            continue\n\n        # Update the attribute definitions\n        new_attrs = self.get_attr_defs_for_instance(instance)\n        instance.set_create_attr_defs(new_attrs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/create/create_workfile.html","title":"create_workfile","text":""},{"location":"autoapi/client/ayon_fusion/plugins/inventory/index.html","title":"inventory","text":""},{"location":"autoapi/client/ayon_fusion/plugins/inventory/select_containers.html","title":"select_containers","text":""},{"location":"autoapi/client/ayon_fusion/plugins/inventory/set_tool_color.html","title":"set_tool_color","text":""},{"location":"autoapi/client/ayon_fusion/plugins/inventory/set_tool_color.html#client.ayon_fusion.plugins.inventory.set_tool_color.FusionSetToolColor","title":"<code>FusionSetToolColor</code>","text":"<p>               Bases: <code>InventoryAction</code></p> <p>Update the color of the selected tools</p> Source code in <code>client/ayon_fusion/plugins/inventory/set_tool_color.py</code> <pre><code>class FusionSetToolColor(InventoryAction):\n    \"\"\"Update the color of the selected tools\"\"\"\n\n    label = \"Set Tool Color\"\n    icon = \"plus\"\n    color = \"#d8d8d8\"\n    _fallback_color = QtGui.QColor(1.0, 1.0, 1.0)\n\n    def process(self, containers):\n        \"\"\"Color all selected tools the selected colors\"\"\"\n\n        result = []\n        comp = get_current_comp()\n\n        # Get tool color\n        first = containers[0]\n        tool = first[\"_tool\"]\n        color = tool.TileColor\n\n        if color is not None:\n            qcolor = QtGui.QColor().fromRgbF(color[\"R\"], color[\"G\"], color[\"B\"])\n        else:\n            qcolor = self._fallback_color\n\n        # Launch pick color\n        picked_color = self.get_color_picker(qcolor)\n        if not picked_color:\n            return\n\n        with comp_lock_and_undo_chunk(comp):\n            for container in containers:\n                # Convert color to RGB 0-1 floats\n                rgb_f = picked_color.getRgbF()\n                rgb_f_table = {\"R\": rgb_f[0], \"G\": rgb_f[1], \"B\": rgb_f[2]}\n\n                # Update tool\n                tool = container[\"_tool\"]\n                tool.TileColor = rgb_f_table\n\n                result.append(container)\n\n        return result\n\n    def get_color_picker(self, color):\n        \"\"\"Launch color picker and return chosen color\n\n        Args:\n            color(QtGui.QColor): Start color to display\n\n        Returns:\n            QtGui.QColor\n\n        \"\"\"\n\n        color_dialog = QtWidgets.QColorDialog(color)\n        color_dialog.setStyleSheet(style.load_stylesheet())\n\n        accepted = color_dialog.exec_()\n        if not accepted:\n            return\n\n        return color_dialog.selectedColor()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/inventory/set_tool_color.html#client.ayon_fusion.plugins.inventory.set_tool_color.FusionSetToolColor.get_color_picker","title":"<code>get_color_picker(color)</code>","text":"<p>Launch color picker and return chosen color</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>QColor</code> <p>Start color to display</p> required <p>Returns:</p> Type Description <p>QtGui.QColor</p> Source code in <code>client/ayon_fusion/plugins/inventory/set_tool_color.py</code> <pre><code>def get_color_picker(self, color):\n    \"\"\"Launch color picker and return chosen color\n\n    Args:\n        color(QtGui.QColor): Start color to display\n\n    Returns:\n        QtGui.QColor\n\n    \"\"\"\n\n    color_dialog = QtWidgets.QColorDialog(color)\n    color_dialog.setStyleSheet(style.load_stylesheet())\n\n    accepted = color_dialog.exec_()\n    if not accepted:\n        return\n\n    return color_dialog.selectedColor()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/inventory/set_tool_color.html#client.ayon_fusion.plugins.inventory.set_tool_color.FusionSetToolColor.process","title":"<code>process(containers)</code>","text":"<p>Color all selected tools the selected colors</p> Source code in <code>client/ayon_fusion/plugins/inventory/set_tool_color.py</code> <pre><code>def process(self, containers):\n    \"\"\"Color all selected tools the selected colors\"\"\"\n\n    result = []\n    comp = get_current_comp()\n\n    # Get tool color\n    first = containers[0]\n    tool = first[\"_tool\"]\n    color = tool.TileColor\n\n    if color is not None:\n        qcolor = QtGui.QColor().fromRgbF(color[\"R\"], color[\"G\"], color[\"B\"])\n    else:\n        qcolor = self._fallback_color\n\n    # Launch pick color\n    picked_color = self.get_color_picker(qcolor)\n    if not picked_color:\n        return\n\n    with comp_lock_and_undo_chunk(comp):\n        for container in containers:\n            # Convert color to RGB 0-1 floats\n            rgb_f = picked_color.getRgbF()\n            rgb_f_table = {\"R\": rgb_f[0], \"G\": rgb_f[1], \"B\": rgb_f[2]}\n\n            # Update tool\n            tool = container[\"_tool\"]\n            tool.TileColor = rgb_f_table\n\n            result.append(container)\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/actions.html","title":"actions","text":"<p>A module containing generic loader actions that will display in the Loader.</p>"},{"location":"autoapi/client/ayon_fusion/plugins/load/actions.html#client.ayon_fusion.plugins.load.actions.FusionSetFrameRangeLoader","title":"<code>FusionSetFrameRangeLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range excluding pre- and post-handles</p> Source code in <code>client/ayon_fusion/plugins/load/actions.py</code> <pre><code>class FusionSetFrameRangeLoader(load.LoaderPlugin):\n    \"\"\"Set frame range excluding pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"imagesequence\",\n        \"render\",\n        \"yeticache\",\n        \"pointcache\",\n        \"render\",\n    }\n    representations = {\"*\"}\n    extensions = {\"*\"}\n\n    label = \"Set frame range\"\n    order = 11\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name, namespace, data):\n\n        from ayon_fusion.api import lib\n\n        version_attributes = context[\"version\"][\"attrib\"]\n\n        start = version_attributes.get(\"frameStart\", None)\n        end = version_attributes.get(\"frameEnd\", None)\n\n        if start is None or end is None:\n            print(\"Skipping setting frame range because start or \"\n                  \"end frame data is missing..\")\n            return\n\n        lib.update_frame_range(start, end)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/actions.html#client.ayon_fusion.plugins.load.actions.FusionSetFrameRangeWithHandlesLoader","title":"<code>FusionSetFrameRangeWithHandlesLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Set frame range including pre- and post-handles</p> Source code in <code>client/ayon_fusion/plugins/load/actions.py</code> <pre><code>class FusionSetFrameRangeWithHandlesLoader(load.LoaderPlugin):\n    \"\"\"Set frame range including pre- and post-handles\"\"\"\n\n    product_types = {\n        \"animation\",\n        \"camera\",\n        \"imagesequence\",\n        \"render\",\n        \"yeticache\",\n        \"pointcache\",\n        \"render\",\n    }\n    representations = {\"*\"}\n\n    label = \"Set frame range (with handles)\"\n    order = 12\n    icon = \"clock-o\"\n    color = \"white\"\n\n    def load(self, context, name, namespace, data):\n\n        from ayon_fusion.api import lib\n\n        version_attributes = context[\"version\"][\"attrib\"]\n        start = version_attributes.get(\"frameStart\", None)\n        end = version_attributes.get(\"frameEnd\", None)\n\n        if start is None or end is None:\n            print(\"Skipping setting frame range because start or \"\n                  \"end frame data is missing..\")\n            return\n\n        # Include handles\n        start -= version_attributes.get(\"handleStart\", 0)\n        end += version_attributes.get(\"handleEnd\", 0)\n\n        lib.update_frame_range(start, end)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_alembic.html","title":"load_alembic","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/load_alembic.html#client.ayon_fusion.plugins.load.load_alembic.FusionLoadAlembicMesh","title":"<code>FusionLoadAlembicMesh</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load Alembic mesh into Fusion</p> Source code in <code>client/ayon_fusion/plugins/load/load_alembic.py</code> <pre><code>class FusionLoadAlembicMesh(load.LoaderPlugin):\n    \"\"\"Load Alembic mesh into Fusion\"\"\"\n\n    product_types = {\"pointcache\", \"model\"}\n    representations = {\"*\"}\n    extensions = {\"abc\"}\n\n    label = \"Load alembic mesh\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    tool_type = \"SurfaceAlembicMesh\"\n\n    def load(self, context, name, namespace, data):\n        # Fallback to folder name when namespace is None\n        if namespace is None:\n            namespace = context[\"folder\"][\"name\"]\n\n        # Create the Loader with the filename path set\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp, \"Create tool\"):\n\n            path = self.filepath_from_context(context)\n\n            args = (-32768, -32768)\n            tool = comp.AddTool(self.tool_type, *args)\n            tool[\"Filename\"] = path\n\n            imprint_container(tool,\n                              name=name,\n                              namespace=namespace,\n                              context=context,\n                              loader=self.__class__.__name__)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        \"\"\"Update Alembic path\"\"\"\n\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        repre_entity = context[\"representation\"]\n        path = get_representation_path(repre_entity)\n\n        with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n            tool[\"Filename\"] = path\n\n            # Update the imprinted representation\n            tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n\n    def remove(self, container):\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        with comp_lock_and_undo_chunk(comp, \"Remove tool\"):\n            tool.Delete()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_alembic.html#client.ayon_fusion.plugins.load.load_alembic.FusionLoadAlembicMesh.update","title":"<code>update(container, context)</code>","text":"<p>Update Alembic path</p> Source code in <code>client/ayon_fusion/plugins/load/load_alembic.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update Alembic path\"\"\"\n\n    tool = container[\"_tool\"]\n    assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n    comp = tool.Comp()\n\n    repre_entity = context[\"representation\"]\n    path = get_representation_path(repre_entity)\n\n    with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n        tool[\"Filename\"] = path\n\n        # Update the imprinted representation\n        tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_fbx.html","title":"load_fbx","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/load_fbx.html#client.ayon_fusion.plugins.load.load_fbx.FusionLoadFBXMesh","title":"<code>FusionLoadFBXMesh</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load FBX mesh into Fusion</p> Source code in <code>client/ayon_fusion/plugins/load/load_fbx.py</code> <pre><code>class FusionLoadFBXMesh(load.LoaderPlugin):\n    \"\"\"Load FBX mesh into Fusion\"\"\"\n\n    product_types = {\"*\"}\n    representations = {\"*\"}\n    extensions = {\n        \"3ds\",\n        \"amc\",\n        \"aoa\",\n        \"asf\",\n        \"bvh\",\n        \"c3d\",\n        \"dae\",\n        \"dxf\",\n        \"fbx\",\n        \"htr\",\n        \"mcd\",\n        \"obj\",\n        \"trc\",\n    }\n\n    label = \"Load FBX mesh\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    tool_type = \"SurfaceFBXMesh\"\n\n    def load(self, context, name, namespace, data):\n        # Fallback to folder name when namespace is None\n        if namespace is None:\n            namespace = context[\"folder\"][\"name\"]\n\n        # Create the Loader with the filename path set\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp, \"Create tool\"):\n            path = self.filepath_from_context(context)\n\n            args = (-32768, -32768)\n            tool = comp.AddTool(self.tool_type, *args)\n            tool[\"ImportFile\"] = path\n\n            imprint_container(\n                tool,\n                name=name,\n                namespace=namespace,\n                context=context,\n                loader=self.__class__.__name__,\n            )\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        \"\"\"Update path\"\"\"\n\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        repre_entity = context[\"representation\"]\n        path = get_representation_path(repre_entity)\n\n        with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n            tool[\"ImportFile\"] = path\n\n            # Update the imprinted representation\n            tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n\n    def remove(self, container):\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        with comp_lock_and_undo_chunk(comp, \"Remove tool\"):\n            tool.Delete()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_fbx.html#client.ayon_fusion.plugins.load.load_fbx.FusionLoadFBXMesh.update","title":"<code>update(container, context)</code>","text":"<p>Update path</p> Source code in <code>client/ayon_fusion/plugins/load/load_fbx.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update path\"\"\"\n\n    tool = container[\"_tool\"]\n    assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n    comp = tool.Comp()\n\n    repre_entity = context[\"representation\"]\n    path = get_representation_path(repre_entity)\n\n    with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n        tool[\"ImportFile\"] = path\n\n        # Update the imprinted representation\n        tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html","title":"load_sequence","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.FusionLoadSequence","title":"<code>FusionLoadSequence</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load image sequence into Fusion</p> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>class FusionLoadSequence(load.LoaderPlugin):\n    \"\"\"Load image sequence into Fusion\"\"\"\n\n    product_types = {\n        \"imagesequence\",\n        \"review\",\n        \"render\",\n        \"plate\",\n        \"image\",\n        \"online\",\n    }\n    representations = {\"*\"}\n    extensions = set(\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS.union(VIDEO_EXTENSIONS)\n    )\n\n    label = \"Load sequence\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n        # Fallback to folder name when namespace is None\n        if namespace is None:\n            namespace = context[\"folder\"][\"name\"]\n\n        # Use the first file for now\n        path = self.filepath_from_context(context)\n\n        # Create the Loader with the filename path set\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp, \"Create Loader\"):\n            args = (-32768, -32768)\n            tool = comp.AddTool(\"Loader\", *args)\n            tool[\"Clip\"] = comp.ReverseMapPath(path)\n            tool.SetAttrs({\"TOOLB_NameSet\": True, \"TOOLS_Name\": name})\n\n            # Set global in point to start frame (if in version.data)\n            start = self._get_start(context[\"version\"], tool)\n            loader_shift(tool, start, relative=False)\n\n            imprint_container(\n                tool,\n                name=name,\n                namespace=namespace,\n                context=context,\n                loader=self.__class__.__name__,\n            )\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        \"\"\"Update the Loader's path\n\n        Fusion automatically tries to reset some variables when changing\n        the loader's path to a new file. These automatic changes are to its\n        inputs:\n            - ClipTimeStart: Fusion reset to 0 if duration changes\n              - We keep the trim in as close as possible to the previous value.\n                When there are less frames then the amount of trim we reduce\n                it accordingly.\n\n            - ClipTimeEnd: Fusion reset to 0 if duration changes\n              - We keep the trim out as close as possible to the previous value\n                within new amount of frames after trim in (ClipTimeStart) has\n                been set.\n\n            - GlobalIn: Fusion reset to comp's global in if duration changes\n              - We change it to the \"frameStart\"\n\n            - GlobalEnd: Fusion resets to globalIn + length if duration changes\n              - We do the same like Fusion - allow fusion to take control.\n\n            - HoldFirstFrame: Fusion resets this to 0\n              - We preserve the value.\n\n            - HoldLastFrame: Fusion resets this to 0\n              - We preserve the value.\n\n            - Reverse: Fusion resets to disabled if \"Loop\" is not enabled.\n              - We preserve the value.\n\n            - Depth: Fusion resets to \"Format\"\n              - We preserve the value.\n\n            - KeyCode: Fusion resets to \"\"\n              - We preserve the value.\n\n            - TimeCodeOffset: Fusion resets to 0\n              - We preserve the value.\n\n        \"\"\"\n\n        tool = container[\"_tool\"]\n        assert tool.ID == \"Loader\", \"Must be Loader\"\n        comp = tool.Comp()\n\n        repre_entity = context[\"representation\"]\n        path = self.filepath_from_context(context)\n\n        # Get start frame from version data\n        start = self._get_start(context[\"version\"], tool)\n\n        with comp_lock_and_undo_chunk(comp, \"Update Loader\"):\n            # Update the loader's path whilst preserving some values\n            with preserve_trim(tool, log=self.log):\n                with preserve_inputs(\n                    tool,\n                    inputs=(\n                        \"HoldFirstFrame\",\n                        \"HoldLastFrame\",\n                        \"Reverse\",\n                        \"Depth\",\n                        \"KeyCode\",\n                        \"TimeCodeOffset\",\n                    ),\n                ):\n                    tool[\"Clip\"] = comp.ReverseMapPath(path)\n                    tool.SetAttrs(\n                        {\n                            \"TOOLB_NameSet\": True,\n                            \"TOOLS_Name\": repre_entity[\"context\"][\"product\"][\n                                \"name\"\n                            ],\n                        }\n                    )\n\n            # Set the global in to the start frame of the sequence\n            global_in_changed = loader_shift(tool, start, relative=False)\n            if global_in_changed:\n                # Log this change to the user\n                self.log.debug(\n                    \"Changed '%s' global in: %d\" % (tool.Name, start)\n                )\n\n            # Update the imprinted representation\n            tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n\n    def remove(self, container):\n        tool = container[\"_tool\"]\n        assert tool.ID == \"Loader\", \"Must be Loader\"\n        comp = tool.Comp()\n\n        with comp_lock_and_undo_chunk(comp, \"Remove Loader\"):\n            tool.Delete()\n\n    def _get_start(self, version_entity, tool):\n        \"\"\"Return real start frame of published files (incl. handles)\"\"\"\n        attributes = version_entity[\"attrib\"]\n\n        # Get start frame directly with handle if it's in data\n        start = attributes.get(\"frameStartHandle\")\n        if start is not None:\n            return start\n\n        # Get frame start without handles\n        start = attributes.get(\"frameStart\")\n        if start is None:\n            self.log.warning(\n                \"Missing start frame for version \"\n                \"assuming starts at frame 0 for: \"\n                \"{}\".format(tool.Name)\n            )\n            return 0\n\n        # Use `handleStart` if the data is available\n        handle_start = attributes.get(\"handleStart\")\n        if handle_start:\n            start -= handle_start\n\n        return start\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.FusionLoadSequence.update","title":"<code>update(container, context)</code>","text":"<p>Update the Loader's path</p> <p>Fusion automatically tries to reset some variables when changing the loader's path to a new file. These automatic changes are to its inputs:     - ClipTimeStart: Fusion reset to 0 if duration changes       - We keep the trim in as close as possible to the previous value.         When there are less frames then the amount of trim we reduce         it accordingly.</p> <pre><code>- ClipTimeEnd: Fusion reset to 0 if duration changes\n  - We keep the trim out as close as possible to the previous value\n    within new amount of frames after trim in (ClipTimeStart) has\n    been set.\n\n- GlobalIn: Fusion reset to comp's global in if duration changes\n  - We change it to the \"frameStart\"\n\n- GlobalEnd: Fusion resets to globalIn + length if duration changes\n  - We do the same like Fusion - allow fusion to take control.\n\n- HoldFirstFrame: Fusion resets this to 0\n  - We preserve the value.\n\n- HoldLastFrame: Fusion resets this to 0\n  - We preserve the value.\n\n- Reverse: Fusion resets to disabled if \"Loop\" is not enabled.\n  - We preserve the value.\n\n- Depth: Fusion resets to \"Format\"\n  - We preserve the value.\n\n- KeyCode: Fusion resets to \"\"\n  - We preserve the value.\n\n- TimeCodeOffset: Fusion resets to 0\n  - We preserve the value.\n</code></pre> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update the Loader's path\n\n    Fusion automatically tries to reset some variables when changing\n    the loader's path to a new file. These automatic changes are to its\n    inputs:\n        - ClipTimeStart: Fusion reset to 0 if duration changes\n          - We keep the trim in as close as possible to the previous value.\n            When there are less frames then the amount of trim we reduce\n            it accordingly.\n\n        - ClipTimeEnd: Fusion reset to 0 if duration changes\n          - We keep the trim out as close as possible to the previous value\n            within new amount of frames after trim in (ClipTimeStart) has\n            been set.\n\n        - GlobalIn: Fusion reset to comp's global in if duration changes\n          - We change it to the \"frameStart\"\n\n        - GlobalEnd: Fusion resets to globalIn + length if duration changes\n          - We do the same like Fusion - allow fusion to take control.\n\n        - HoldFirstFrame: Fusion resets this to 0\n          - We preserve the value.\n\n        - HoldLastFrame: Fusion resets this to 0\n          - We preserve the value.\n\n        - Reverse: Fusion resets to disabled if \"Loop\" is not enabled.\n          - We preserve the value.\n\n        - Depth: Fusion resets to \"Format\"\n          - We preserve the value.\n\n        - KeyCode: Fusion resets to \"\"\n          - We preserve the value.\n\n        - TimeCodeOffset: Fusion resets to 0\n          - We preserve the value.\n\n    \"\"\"\n\n    tool = container[\"_tool\"]\n    assert tool.ID == \"Loader\", \"Must be Loader\"\n    comp = tool.Comp()\n\n    repre_entity = context[\"representation\"]\n    path = self.filepath_from_context(context)\n\n    # Get start frame from version data\n    start = self._get_start(context[\"version\"], tool)\n\n    with comp_lock_and_undo_chunk(comp, \"Update Loader\"):\n        # Update the loader's path whilst preserving some values\n        with preserve_trim(tool, log=self.log):\n            with preserve_inputs(\n                tool,\n                inputs=(\n                    \"HoldFirstFrame\",\n                    \"HoldLastFrame\",\n                    \"Reverse\",\n                    \"Depth\",\n                    \"KeyCode\",\n                    \"TimeCodeOffset\",\n                ),\n            ):\n                tool[\"Clip\"] = comp.ReverseMapPath(path)\n                tool.SetAttrs(\n                    {\n                        \"TOOLB_NameSet\": True,\n                        \"TOOLS_Name\": repre_entity[\"context\"][\"product\"][\n                            \"name\"\n                        ],\n                    }\n                )\n\n        # Set the global in to the start frame of the sequence\n        global_in_changed = loader_shift(tool, start, relative=False)\n        if global_in_changed:\n            # Log this change to the user\n            self.log.debug(\n                \"Changed '%s' global in: %d\" % (tool.Name, start)\n            )\n\n        # Update the imprinted representation\n        tool.SetData(\"avalon.representation\", repre_entity[\"id\"])\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.loader_shift","title":"<code>loader_shift(loader, frame, relative=True)</code>","text":"<p>Shift global in time by i preserving duration</p> <p>This moves the loader by i frames preserving global duration. When relative is False it will shift the global in to the start frame.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>tool</code> <p>The fusion loader tool.</p> required <code>frame</code> <code>int</code> <p>The amount of frames to move.</p> required <code>relative</code> <code>bool</code> <p>When True the shift is relative, else the shift will change the global in to frame.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>int</code> <p>The resulting relative frame change (how much it moved)</p> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>def loader_shift(loader, frame, relative=True):\n    \"\"\"Shift global in time by i preserving duration\n\n    This moves the loader by i frames preserving global duration. When relative\n    is False it will shift the global in to the start frame.\n\n    Args:\n        loader (tool): The fusion loader tool.\n        frame (int): The amount of frames to move.\n        relative (bool): When True the shift is relative, else the shift will\n            change the global in to frame.\n\n    Returns:\n        int: The resulting relative frame change (how much it moved)\n\n    \"\"\"\n    comp = loader.Comp()\n    time = comp.TIME_UNDEFINED\n\n    old_in = loader[\"GlobalIn\"][time]\n    old_out = loader[\"GlobalOut\"][time]\n\n    if relative:\n        shift = frame\n    else:\n        shift = frame - old_in\n\n    if not shift:\n        return 0\n\n    # Shifting global in will try to automatically compensate for the change\n    # in the \"ClipTimeStart\" and \"HoldFirstFrame\" inputs, so we preserve those\n    # input values to \"just shift\" the clip\n    with preserve_inputs(\n        loader,\n        inputs=[\n            \"ClipTimeStart\",\n            \"ClipTimeEnd\",\n            \"HoldFirstFrame\",\n            \"HoldLastFrame\",\n        ],\n    ):\n        # GlobalIn cannot be set past GlobalOut or vice versa\n        # so we must apply them in the order of the shift.\n        if shift &gt; 0:\n            loader[\"GlobalOut\"][time] = old_out + shift\n            loader[\"GlobalIn\"][time] = old_in + shift\n        else:\n            loader[\"GlobalIn\"][time] = old_in + shift\n            loader[\"GlobalOut\"][time] = old_out + shift\n\n    return int(shift)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.preserve_inputs","title":"<code>preserve_inputs(tool, inputs)</code>","text":"<p>Preserve the tool's inputs after context</p> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>@contextlib.contextmanager\ndef preserve_inputs(tool, inputs):\n    \"\"\"Preserve the tool's inputs after context\"\"\"\n\n    comp = tool.Comp()\n\n    values = {}\n    for name in inputs:\n        tool_input = getattr(tool, name)\n        value = tool_input[comp.TIME_UNDEFINED]\n        values[name] = value\n\n    try:\n        yield\n    finally:\n        for name, value in values.items():\n            tool_input = getattr(tool, name)\n            tool_input[comp.TIME_UNDEFINED] = value\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_sequence.html#client.ayon_fusion.plugins.load.load_sequence.preserve_trim","title":"<code>preserve_trim(loader, log=None)</code>","text":"<p>Preserve the relative trim of the Loader tool.</p> <p>This tries to preserve the loader's trim (trim in and trim out) after the context by reapplying the \"amount\" it trims on the clip's length at start and end.</p> Source code in <code>client/ayon_fusion/plugins/load/load_sequence.py</code> <pre><code>@contextlib.contextmanager\ndef preserve_trim(loader, log=None):\n    \"\"\"Preserve the relative trim of the Loader tool.\n\n    This tries to preserve the loader's trim (trim in and trim out) after\n    the context by reapplying the \"amount\" it trims on the clip's length at\n    start and end.\n\n    \"\"\"\n\n    # Get original trim as amount of \"trimming\" from length\n    time = loader.Comp().TIME_UNDEFINED\n    length = loader.GetAttrs()[\"TOOLIT_Clip_Length\"][1] - 1\n    trim_from_start = loader[\"ClipTimeStart\"][time]\n    trim_from_end = length - loader[\"ClipTimeEnd\"][time]\n\n    try:\n        yield\n    finally:\n        length = loader.GetAttrs()[\"TOOLIT_Clip_Length\"][1] - 1\n        if trim_from_start &gt; length:\n            trim_from_start = length\n            if log:\n                log.warning(\n                    \"Reducing trim in to %d \"\n                    \"(because of less frames)\" % trim_from_start\n                )\n\n        remainder = length - trim_from_start\n        if trim_from_end &gt; remainder:\n            trim_from_end = remainder\n            if log:\n                log.warning(\n                    \"Reducing trim in to %d \"\n                    \"(because of less frames)\" % trim_from_end\n                )\n\n        loader[\"ClipTimeStart\"][time] = trim_from_start\n        loader[\"ClipTimeEnd\"][time] = length - trim_from_end\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_usd.html","title":"load_usd","text":""},{"location":"autoapi/client/ayon_fusion/plugins/load/load_usd.html#client.ayon_fusion.plugins.load.load_usd.FusionLoadUSD","title":"<code>FusionLoadUSD</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load USD into Fusion</p> <p>Support for USD was added since Fusion 18.5</p> Source code in <code>client/ayon_fusion/plugins/load/load_usd.py</code> <pre><code>class FusionLoadUSD(load.LoaderPlugin):\n    \"\"\"Load USD into Fusion\n\n    Support for USD was added since Fusion 18.5\n    \"\"\"\n\n    product_types = {\"*\"}\n    representations = {\"*\"}\n    extensions = {\"usd\", \"usda\", \"usdz\"}\n\n    label = \"Load USD\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    tool_type = \"uLoader\"\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super().apply_settings(project_settings)\n        if cls.enabled:\n            # Enable only in Fusion 18.5+\n            fusion = get_fusion_module()\n            version = fusion.GetVersion()\n            major = version[1]\n            minor = version[2]\n            is_usd_supported = (major, minor) &gt;= (18, 5)\n            cls.enabled = is_usd_supported\n\n    def load(self, context, name, namespace, data):\n        # Fallback to folder name when namespace is None\n        if namespace is None:\n            namespace = context[\"folder\"][\"name\"]\n\n        # Create the Loader with the filename path set\n        comp = get_current_comp()\n        with comp_lock_and_undo_chunk(comp, \"Create tool\"):\n            path = self.filepath_from_context(context)\n\n            args = (-32768, -32768)\n            tool = comp.AddTool(self.tool_type, *args)\n            tool[\"Filename\"] = path\n\n            imprint_container(tool,\n                              name=name,\n                              namespace=namespace,\n                              context=context,\n                              loader=self.__class__.__name__)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        path = self.filepath_from_context(context)\n        with comp_lock_and_undo_chunk(comp, \"Update tool\"):\n            tool[\"Filename\"] = path\n\n            # Update the imprinted representation\n            tool.SetData(\"avalon.representation\",\n                         context[\"representation\"][\"id\"])\n\n    def remove(self, container):\n        tool = container[\"_tool\"]\n        assert tool.ID == self.tool_type, f\"Must be {self.tool_type}\"\n        comp = tool.Comp()\n\n        with comp_lock_and_undo_chunk(comp, \"Remove tool\"):\n            tool.Delete()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_workfile.html","title":"load_workfile","text":"<p>Import workfiles into your current comp. As all imported nodes are free floating and will probably be changed there is no update or reload function added for this plugin</p>"},{"location":"autoapi/client/ayon_fusion/plugins/load/load_workfile.html#client.ayon_fusion.plugins.load.load_workfile.FusionLoadWorkfile","title":"<code>FusionLoadWorkfile</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load the content of a workfile into Fusion</p> Source code in <code>client/ayon_fusion/plugins/load/load_workfile.py</code> <pre><code>class FusionLoadWorkfile(load.LoaderPlugin):\n    \"\"\"Load the content of a workfile into Fusion\"\"\"\n\n    product_types = {\"workfile\"}\n    representations = {\"*\"}\n    extensions = {\"comp\"}\n\n    label = \"Load Workfile\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n        # Get needed elements\n        bmd = get_bmd_library()\n        comp = get_current_comp()\n        path = self.filepath_from_context(context)\n\n        # Paste the content of the file into the current comp\n        comp.Paste(bmd.readfile(path))\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp.html","title":"collect_comp","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp.html#client.ayon_fusion.plugins.publish.collect_comp.CollectCurrentCompFusion","title":"<code>CollectCurrentCompFusion</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect current comp</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp.py</code> <pre><code>class CollectCurrentCompFusion(pyblish.api.ContextPlugin):\n    \"\"\"Collect current comp\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.4\n    label = \"Collect Current Comp\"\n    hosts = [\"fusion\"]\n\n    def process(self, context):\n        \"\"\"Collect all image sequence tools\"\"\"\n\n        current_comp = get_current_comp()\n        assert current_comp, \"Must have active Fusion composition\"\n        context.data[\"currentComp\"] = current_comp\n\n        # Store path to current file\n        filepath = current_comp.GetAttrs().get(\"COMPS_FileName\", \"\")\n        context.data['currentFile'] = filepath\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp.html#client.ayon_fusion.plugins.publish.collect_comp.CollectCurrentCompFusion.process","title":"<code>process(context)</code>","text":"<p>Collect all image sequence tools</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp.py</code> <pre><code>def process(self, context):\n    \"\"\"Collect all image sequence tools\"\"\"\n\n    current_comp = get_current_comp()\n    assert current_comp, \"Must have active Fusion composition\"\n    context.data[\"currentComp\"] = current_comp\n\n    # Store path to current file\n    filepath = current_comp.GetAttrs().get(\"COMPS_FileName\", \"\")\n    context.data['currentFile'] = filepath\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp_frame_range.html","title":"collect_comp_frame_range","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp_frame_range.html#client.ayon_fusion.plugins.publish.collect_comp_frame_range.CollectFusionCompFrameRanges","title":"<code>CollectFusionCompFrameRanges</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect current comp</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp_frame_range.py</code> <pre><code>class CollectFusionCompFrameRanges(pyblish.api.ContextPlugin):\n    \"\"\"Collect current comp\"\"\"\n\n    # We run this after CollectorOrder - 0.1 otherwise it gets\n    # overridden by global plug-in `CollectContextEntities`\n    order = pyblish.api.CollectorOrder - 0.05\n    label = \"Collect Comp Frame Ranges\"\n    hosts = [\"fusion\"]\n\n    def process(self, context):\n        \"\"\"Collect all image sequence tools\"\"\"\n\n        comp = context.data[\"currentComp\"]\n\n        # Store comp render ranges\n        start, end, global_start, global_end = get_comp_render_range(comp)\n\n        context.data.update({\n            \"renderFrameStart\": int(start),\n            \"renderFrameEnd\": int(end),\n            \"compFrameStart\": int(global_start),\n            \"compFrameEnd\": int(global_end)\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp_frame_range.html#client.ayon_fusion.plugins.publish.collect_comp_frame_range.CollectFusionCompFrameRanges.process","title":"<code>process(context)</code>","text":"<p>Collect all image sequence tools</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp_frame_range.py</code> <pre><code>def process(self, context):\n    \"\"\"Collect all image sequence tools\"\"\"\n\n    comp = context.data[\"currentComp\"]\n\n    # Store comp render ranges\n    start, end, global_start, global_end = get_comp_render_range(comp)\n\n    context.data.update({\n        \"renderFrameStart\": int(start),\n        \"renderFrameEnd\": int(end),\n        \"compFrameStart\": int(global_start),\n        \"compFrameEnd\": int(global_end)\n    })\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_comp_frame_range.html#client.ayon_fusion.plugins.publish.collect_comp_frame_range.get_comp_render_range","title":"<code>get_comp_render_range(comp)</code>","text":"<p>Return comp's start-end render range and global start-end range.</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_comp_frame_range.py</code> <pre><code>def get_comp_render_range(comp):\n    \"\"\"Return comp's start-end render range and global start-end range.\"\"\"\n    comp_attrs = comp.GetAttrs()\n    start = comp_attrs[\"COMPN_RenderStart\"]\n    end = comp_attrs[\"COMPN_RenderEnd\"]\n    global_start = comp_attrs[\"COMPN_GlobalStart\"]\n    global_end = comp_attrs[\"COMPN_GlobalEnd\"]\n\n    # Whenever render ranges are undefined fall back\n    # to the comp's global start and end\n    if start == -1000000000:\n        start = global_start\n    if end == -1000000000:\n        end = global_end\n\n    return start, end, global_start, global_end\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_inputs.html","title":"collect_inputs","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_inputs.html#client.ayon_fusion.plugins.publish.collect_inputs.CollectUpstreamInputs","title":"<code>CollectUpstreamInputs</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect source input containers used for this publish.</p> <p>This will include <code>inputs</code> data of which loaded publishes were used in the generation of this publish. This leaves an upstream trace to what was used as input.</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_inputs.py</code> <pre><code>class CollectUpstreamInputs(pyblish.api.InstancePlugin):\n    \"\"\"Collect source input containers used for this publish.\n\n    This will include `inputs` data of which loaded publishes were used in the\n    generation of this publish. This leaves an upstream trace to what was used\n    as input.\n\n    \"\"\"\n\n    label = \"Collect Inputs\"\n    order = pyblish.api.CollectorOrder + 0.2\n    hosts = [\"fusion\"]\n    families = [\"render\", \"image\"]\n\n    def process(self, instance):\n\n        # Get all upstream and include itself\n        if not any(instance[:]):\n            self.log.debug(\"No tool found in instance, skipping..\")\n            return\n\n        tool = instance[0]\n        nodes = list(iter_upstream(tool))\n        nodes.append(tool)\n\n        # Collect containers for the given set of nodes\n        containers = collect_input_containers(nodes)\n\n        inputs = [c[\"representation\"] for c in containers]\n        instance.data[\"inputRepresentations\"] = inputs\n        self.log.debug(\"Collected inputs: %s\" % inputs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_inputs.html#client.ayon_fusion.plugins.publish.collect_inputs.collect_input_containers","title":"<code>collect_input_containers(tools)</code>","text":"<p>Collect containers that contain any of the node in <code>nodes</code>.</p> <p>This will return any loaded Avalon container that contains at least one of the nodes. As such, the Avalon container is an input for it. Or in short, there are member nodes of that container.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>Input avalon containers</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_inputs.py</code> <pre><code>def collect_input_containers(tools):\n    \"\"\"Collect containers that contain any of the node in `nodes`.\n\n    This will return any loaded Avalon container that contains at least one of\n    the nodes. As such, the Avalon container is an input for it. Or in short,\n    there are member nodes of that container.\n\n    Returns:\n        list: Input avalon containers\n\n    \"\"\"\n\n    # Lookup by node ids\n    lookup = frozenset([tool.Name for tool in tools])\n\n    containers = []\n    host = registered_host()\n    for container in host.ls():\n\n        name = container[\"_tool\"].Name\n\n        # We currently assume no \"groups\" as containers but just single tools\n        # like a single \"Loader\" operator. As such we just check whether the\n        # Loader is part of the processing queue.\n        if name in lookup:\n            containers.append(container)\n\n    return containers\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_inputs.html#client.ayon_fusion.plugins.publish.collect_inputs.iter_upstream","title":"<code>iter_upstream(tool)</code>","text":"<p>Yields all upstream inputs for the current tool.</p> <p>Yields:</p> Name Type Description <code>tool</code> <p>The input tools.</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_inputs.py</code> <pre><code>def iter_upstream(tool):\n    \"\"\"Yields all upstream inputs for the current tool.\n\n    Yields:\n        tool: The input tools.\n\n    \"\"\"\n\n    def get_connected_input_tools(tool):\n        \"\"\"Helper function that returns connected input tools for a tool.\"\"\"\n        inputs = []\n\n        # Filter only to actual types that will have sensible upstream\n        # connections. So we ignore just \"Number\" inputs as they can be\n        # many to iterate, slowing things down quite a bit - and in practice\n        # they don't have upstream connections.\n        VALID_INPUT_TYPES = ['Image', 'Particles', 'Mask', 'DataType3D']\n        for type_ in VALID_INPUT_TYPES:\n            for input_ in tool.GetInputList(type_).values():\n                output = input_.GetConnectedOutput()\n                if output:\n                    input_tool = output.GetTool()\n                    inputs.append(input_tool)\n\n        return inputs\n\n    # Initialize process queue with the node's inputs itself\n    queue = get_connected_input_tools(tool)\n\n    # We keep track of which node names we have processed so far, to ensure we\n    # don't process the same hierarchy again. We are not pushing the tool\n    # itself into the set as that doesn't correctly recognize the same tool.\n    # Since tool names are unique in a comp in Fusion we rely on that.\n    collected = set(tool.Name for tool in queue)\n\n    # Traverse upstream references for all nodes and yield them as we\n    # process the queue.\n    while queue:\n        upstream_tool = queue.pop()\n        yield upstream_tool\n\n        # Find upstream tools that are not collected yet.\n        upstream_inputs = get_connected_input_tools(upstream_tool)\n        upstream_inputs = [t for t in upstream_inputs if\n                           t.Name not in collected]\n\n        queue.extend(upstream_inputs)\n        collected.update(tool.Name for tool in upstream_inputs)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_instances.html","title":"collect_instances","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_instances.html#client.ayon_fusion.plugins.publish.collect_instances.CollectInstanceData","title":"<code>CollectInstanceData</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Fusion saver instances</p> <p>This additionally stores the Comp start and end render range in the current context's data as \"frameStart\" and \"frameEnd\".</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_instances.py</code> <pre><code>class CollectInstanceData(pyblish.api.InstancePlugin):\n    \"\"\"Collect Fusion saver instances\n\n    This additionally stores the Comp start and end render range in the\n    current context's data as \"frameStart\" and \"frameEnd\".\n\n    \"\"\"\n\n    order = pyblish.api.CollectorOrder\n    label = \"Collect Instances Data\"\n    hosts = [\"fusion\"]\n\n    def process(self, instance):\n        \"\"\"Collect all image sequence tools\"\"\"\n\n        context = instance.context\n\n        # Include creator attributes directly as instance data\n        creator_attributes = instance.data[\"creator_attributes\"]\n        instance.data.update(creator_attributes)\n\n        frame_range_source = creator_attributes.get(\"frame_range_source\")\n        instance.data[\"frame_range_source\"] = frame_range_source\n\n        # get folder frame ranges to all instances\n        # render product type instances `current_context` render target\n        start = context.data[\"frameStart\"]\n        end = context.data[\"frameEnd\"]\n        handle_start = context.data[\"handleStart\"]\n        handle_end = context.data[\"handleEnd\"]\n        start_with_handle = start - handle_start\n        end_with_handle = end + handle_end\n\n        # conditions for render product type instances\n        if frame_range_source == \"render_range\":\n            # set comp render frame ranges\n            start = context.data[\"renderFrameStart\"]\n            end = context.data[\"renderFrameEnd\"]\n            handle_start = 0\n            handle_end = 0\n            start_with_handle = start\n            end_with_handle = end\n\n        if frame_range_source == \"comp_range\":\n            comp_start = context.data[\"compFrameStart\"]\n            comp_end = context.data[\"compFrameEnd\"]\n            render_start = context.data[\"renderFrameStart\"]\n            render_end = context.data[\"renderFrameEnd\"]\n            # set comp frame ranges\n            start = render_start\n            end = render_end\n            handle_start = render_start - comp_start\n            handle_end = comp_end - render_end\n            start_with_handle = comp_start\n            end_with_handle = comp_end\n\n        if frame_range_source == \"custom_range\":\n            start = int(instance.data[\"custom_frameStart\"])\n            end = int(instance.data[\"custom_frameEnd\"])\n            handle_start = int(instance.data[\"custom_handleStart\"])\n            handle_end = int(instance.data[\"custom_handleEnd\"])\n            start_with_handle = start - handle_start\n            end_with_handle = end + handle_end\n\n        frame = instance.data[\"creator_attributes\"].get(\"frame\")\n        # explicitly publishing only single frame\n        if frame is not None:\n            frame = int(frame)\n\n            start = frame\n            end = frame\n            handle_start = 0\n            handle_end = 0\n            start_with_handle = frame\n            end_with_handle = frame\n\n        # Include start and end render frame in label\n        product_name = instance.data[\"productName\"]\n        label = (\n            \"{product_name} ({start}-{end}) [{handle_start}-{handle_end}]\"\n        ).format(\n            product_name=product_name,\n            start=int(start),\n            end=int(end),\n            handle_start=int(handle_start),\n            handle_end=int(handle_end)\n        )\n\n        instance.data.update({\n            \"label\": label,\n\n            # todo: Allow custom frame range per instance\n            \"frameStart\": start,\n            \"frameEnd\": end,\n            \"frameStartHandle\": start_with_handle,\n            \"frameEndHandle\": end_with_handle,\n            \"handleStart\": handle_start,\n            \"handleEnd\": handle_end,\n            \"fps\": context.data[\"fps\"],\n        })\n\n        # Add review family if the instance is marked as 'review'\n        # This could be done through a 'review' Creator attribute.\n        if instance.data.get(\"review\", False):\n            self.log.debug(\"Adding review family..\")\n            instance.data[\"families\"].append(\"review\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_instances.html#client.ayon_fusion.plugins.publish.collect_instances.CollectInstanceData.process","title":"<code>process(instance)</code>","text":"<p>Collect all image sequence tools</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_instances.py</code> <pre><code>def process(self, instance):\n    \"\"\"Collect all image sequence tools\"\"\"\n\n    context = instance.context\n\n    # Include creator attributes directly as instance data\n    creator_attributes = instance.data[\"creator_attributes\"]\n    instance.data.update(creator_attributes)\n\n    frame_range_source = creator_attributes.get(\"frame_range_source\")\n    instance.data[\"frame_range_source\"] = frame_range_source\n\n    # get folder frame ranges to all instances\n    # render product type instances `current_context` render target\n    start = context.data[\"frameStart\"]\n    end = context.data[\"frameEnd\"]\n    handle_start = context.data[\"handleStart\"]\n    handle_end = context.data[\"handleEnd\"]\n    start_with_handle = start - handle_start\n    end_with_handle = end + handle_end\n\n    # conditions for render product type instances\n    if frame_range_source == \"render_range\":\n        # set comp render frame ranges\n        start = context.data[\"renderFrameStart\"]\n        end = context.data[\"renderFrameEnd\"]\n        handle_start = 0\n        handle_end = 0\n        start_with_handle = start\n        end_with_handle = end\n\n    if frame_range_source == \"comp_range\":\n        comp_start = context.data[\"compFrameStart\"]\n        comp_end = context.data[\"compFrameEnd\"]\n        render_start = context.data[\"renderFrameStart\"]\n        render_end = context.data[\"renderFrameEnd\"]\n        # set comp frame ranges\n        start = render_start\n        end = render_end\n        handle_start = render_start - comp_start\n        handle_end = comp_end - render_end\n        start_with_handle = comp_start\n        end_with_handle = comp_end\n\n    if frame_range_source == \"custom_range\":\n        start = int(instance.data[\"custom_frameStart\"])\n        end = int(instance.data[\"custom_frameEnd\"])\n        handle_start = int(instance.data[\"custom_handleStart\"])\n        handle_end = int(instance.data[\"custom_handleEnd\"])\n        start_with_handle = start - handle_start\n        end_with_handle = end + handle_end\n\n    frame = instance.data[\"creator_attributes\"].get(\"frame\")\n    # explicitly publishing only single frame\n    if frame is not None:\n        frame = int(frame)\n\n        start = frame\n        end = frame\n        handle_start = 0\n        handle_end = 0\n        start_with_handle = frame\n        end_with_handle = frame\n\n    # Include start and end render frame in label\n    product_name = instance.data[\"productName\"]\n    label = (\n        \"{product_name} ({start}-{end}) [{handle_start}-{handle_end}]\"\n    ).format(\n        product_name=product_name,\n        start=int(start),\n        end=int(end),\n        handle_start=int(handle_start),\n        handle_end=int(handle_end)\n    )\n\n    instance.data.update({\n        \"label\": label,\n\n        # todo: Allow custom frame range per instance\n        \"frameStart\": start,\n        \"frameEnd\": end,\n        \"frameStartHandle\": start_with_handle,\n        \"frameEndHandle\": end_with_handle,\n        \"handleStart\": handle_start,\n        \"handleEnd\": handle_end,\n        \"fps\": context.data[\"fps\"],\n    })\n\n    # Add review family if the instance is marked as 'review'\n    # This could be done through a 'review' Creator attribute.\n    if instance.data.get(\"review\", False):\n        self.log.debug(\"Adding review family..\")\n        instance.data[\"families\"].append(\"review\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_render.html","title":"collect_render","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_render.html#client.ayon_fusion.plugins.publish.collect_render.CollectFusionRender","title":"<code>CollectFusionRender</code>","text":"<p>               Bases: <code>AbstractCollectRender</code>, <code>ColormanagedPyblishPluginMixin</code></p> Source code in <code>client/ayon_fusion/plugins/publish/collect_render.py</code> <pre><code>class CollectFusionRender(\n    publish.AbstractCollectRender,\n    publish.ColormanagedPyblishPluginMixin\n):\n\n    order = pyblish.api.CollectorOrder + 0.09\n    label = \"Collect Fusion Render\"\n    hosts = [\"fusion\"]\n\n    def get_instances(self, context):\n\n        comp = context.data.get(\"currentComp\")\n        comp_frame_format_prefs = comp.GetPrefs(\"Comp.FrameFormat\")\n        aspect_x = comp_frame_format_prefs[\"AspectX\"]\n        aspect_y = comp_frame_format_prefs[\"AspectY\"]\n\n        current_file = context.data[\"currentFile\"]\n        version = context.data.get(\"version\")\n        project_entity = context.data[\"projectEntity\"]\n\n        instances = []\n        for inst in context:\n            if not inst.data.get(\"active\", True):\n                continue\n\n            product_type = inst.data[\"productType\"]\n            if product_type not in [\"render\", \"image\"]:\n                continue\n\n            # Get resolution from tool if we can\n            tool = inst.data[\"transientData\"][\"tool\"]\n            try:\n                width, height = get_tool_resolution(\n                    tool, frame=inst.data[\"frameStart\"])\n            except ValueError:\n                self.log.debug(\n                    f\"Unable to get resolution from tool: {tool}. \"\n                    \"Falling back to comp frame format resolution \"\n                    \"preferences.\")\n                width = comp_frame_format_prefs.get(\"Width\")\n                height = comp_frame_format_prefs.get(\"Height\")\n\n            instance_families = inst.data.get(\"families\", [])\n            product_name = inst.data[\"productName\"]\n            instance = FusionRenderInstance(\n                tool=inst.data[\"transientData\"][\"tool\"],\n                workfileComp=comp,\n                productType=product_type,\n                family=product_type,\n                families=instance_families,\n                version=version,\n                time=\"\",\n                source=current_file,\n                label=inst.data[\"label\"],\n                productName=product_name,\n                folderPath=inst.data[\"folderPath\"],\n                task=inst.data[\"task\"],\n                attachTo=False,\n                setMembers='',\n                publish=True,\n                name=product_name,\n                resolutionWidth=width,\n                resolutionHeight=height,\n                pixelAspect=aspect_x / aspect_y,\n                tileRendering=False,\n                tilesX=0,\n                tilesY=0,\n                review=\"review\" in instance_families,\n                frameStart=inst.data[\"frameStart\"],\n                frameEnd=inst.data[\"frameEnd\"],\n                handleStart=inst.data[\"handleStart\"],\n                handleEnd=inst.data[\"handleEnd\"],\n                frameStartHandle=inst.data[\"frameStartHandle\"],\n                frameEndHandle=inst.data[\"frameEndHandle\"],\n                frameStep=1,\n                fps=comp_frame_format_prefs.get(\"Rate\"),\n                app_version=comp.GetApp().Version,\n                publish_attributes=inst.data.get(\"publish_attributes\", {}),\n\n                # The source instance this render instance replaces\n                source_instance=inst\n            )\n\n            render_target = inst.data[\"creator_attributes\"][\"render_target\"]\n\n            # Add render target family\n            render_target_family = f\"render.{render_target}\"\n            if render_target_family not in instance.families:\n                instance.families.append(render_target_family)\n\n            # Add render target specific data\n            if render_target in {\"local\", \"frames\"}:\n                instance.projectEntity = project_entity\n\n            if render_target == \"farm\":\n                fam = \"render.farm\"\n                if fam not in instance.families:\n                    instance.families.append(fam)\n                instance.farm = True  # to skip integrate\n                if \"review\" in instance.families:\n                    # to skip ExtractReview locally\n                    instance.families.remove(\"review\")\n                instance.deadline = inst.data.get(\"deadline\")\n\n            instances.append(instance)\n\n        return instances\n\n    def post_collecting_action(self):\n        for instance in self._context:\n            if \"render.frames\" in instance.data.get(\"families\", []):\n                # adding representation data to the instance\n                self._update_for_frames(instance)\n\n    def get_expected_files(self, render_instance):\n        \"\"\"\n            Returns list of rendered files that should be created by\n            Deadline. These are not published directly, they are source\n            for later 'submit_publish_job'.\n\n        Args:\n            render_instance (RenderInstance): to pull anatomy and parts used\n                in url\n\n        Returns:\n            (list) of absolute urls to rendered file\n        \"\"\"\n        start = render_instance.frameStart - render_instance.handleStart\n        end = render_instance.frameEnd + render_instance.handleEnd\n\n        comp = render_instance.workfileComp\n        path = comp.MapPath(\n            render_instance.tool[\"Clip\"][\n                render_instance.workfileComp.TIME_UNDEFINED\n            ]\n        )\n        output_dir = os.path.dirname(path)\n        render_instance.outputDir = output_dir\n\n        basename = os.path.basename(path)\n\n        head, padding, ext = get_frame_path(basename)\n\n        expected_files = []\n        for frame in range(start, end + 1):\n            expected_files.append(\n                os.path.join(\n                    output_dir,\n                    f\"{head}{str(frame).zfill(padding)}{ext}\"\n                )\n            )\n\n        return expected_files\n\n    def _update_for_frames(self, instance):\n        \"\"\"Updating instance for render.frames family\n\n        Adding representation data to the instance. Also setting\n        colorspaceData to the representation based on file rules.\n        \"\"\"\n\n        expected_files = instance.data[\"expectedFiles\"]\n\n        start = instance.data[\"frameStart\"] - instance.data[\"handleStart\"]\n\n        path = expected_files[0]\n        basename = os.path.basename(path)\n        staging_dir = os.path.dirname(path)\n        _, padding, ext = get_frame_path(basename)\n\n        repre = {\n            \"name\": ext[1:],\n            \"ext\": ext[1:],\n            \"frameStart\": f\"%0{padding}d\" % start,\n            \"files\": [os.path.basename(f) for f in expected_files],\n            \"stagingDir\": staging_dir,\n        }\n\n        self.set_representation_colorspace(\n            representation=repre,\n            context=instance.context,\n        )\n\n        # review representation\n        if instance.data.get(\"review\", False):\n            repre[\"tags\"] = [\"review\"]\n\n        # add the repre to the instance\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n        instance.data[\"representations\"].append(repre)\n\n        return instance\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_render.html#client.ayon_fusion.plugins.publish.collect_render.CollectFusionRender.get_expected_files","title":"<code>get_expected_files(render_instance)</code>","text":"<pre><code>Returns list of rendered files that should be created by\nDeadline. These are not published directly, they are source\nfor later 'submit_publish_job'.\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>render_instance</code> <code>RenderInstance</code> <p>to pull anatomy and parts used in url</p> required <p>Returns:</p> Type Description <p>(list) of absolute urls to rendered file</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_render.py</code> <pre><code>def get_expected_files(self, render_instance):\n    \"\"\"\n        Returns list of rendered files that should be created by\n        Deadline. These are not published directly, they are source\n        for later 'submit_publish_job'.\n\n    Args:\n        render_instance (RenderInstance): to pull anatomy and parts used\n            in url\n\n    Returns:\n        (list) of absolute urls to rendered file\n    \"\"\"\n    start = render_instance.frameStart - render_instance.handleStart\n    end = render_instance.frameEnd + render_instance.handleEnd\n\n    comp = render_instance.workfileComp\n    path = comp.MapPath(\n        render_instance.tool[\"Clip\"][\n            render_instance.workfileComp.TIME_UNDEFINED\n        ]\n    )\n    output_dir = os.path.dirname(path)\n    render_instance.outputDir = output_dir\n\n    basename = os.path.basename(path)\n\n    head, padding, ext = get_frame_path(basename)\n\n    expected_files = []\n    for frame in range(start, end + 1):\n        expected_files.append(\n            os.path.join(\n                output_dir,\n                f\"{head}{str(frame).zfill(padding)}{ext}\"\n            )\n        )\n\n    return expected_files\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_workfile.html","title":"collect_workfile","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/collect_workfile.html#client.ayon_fusion.plugins.publish.collect_workfile.CollectFusionWorkfile","title":"<code>CollectFusionWorkfile</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect Fusion workfile representation.</p> Source code in <code>client/ayon_fusion/plugins/publish/collect_workfile.py</code> <pre><code>class CollectFusionWorkfile(pyblish.api.InstancePlugin):\n    \"\"\"Collect Fusion workfile representation.\"\"\"\n\n    order = pyblish.api.CollectorOrder + 0.1\n    label = \"Collect Workfile\"\n    hosts = [\"fusion\"]\n    families = [\"workfile\"]\n\n    def process(self, instance):\n\n        current_file = instance.context.data[\"currentFile\"]\n\n        folder, file = os.path.split(current_file)\n        filename, ext = os.path.splitext(file)\n\n        instance.data['representations'] = [{\n            'name': ext.lstrip(\".\"),\n            'ext': ext.lstrip(\".\"),\n            'files': file,\n            \"stagingDir\": folder,\n        }]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html","title":"extract_render_local","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html#client.ayon_fusion.plugins.publish.extract_render_local.FusionRenderLocal","title":"<code>FusionRenderLocal</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>ColormanagedPyblishPluginMixin</code></p> <p>Render the current Fusion composition locally.</p> Source code in <code>client/ayon_fusion/plugins/publish/extract_render_local.py</code> <pre><code>class FusionRenderLocal(\n    pyblish.api.InstancePlugin,\n    publish.ColormanagedPyblishPluginMixin\n):\n    \"\"\"Render the current Fusion composition locally.\"\"\"\n\n    order = pyblish.api.ExtractorOrder - 0.2\n    label = \"Render Local\"\n    hosts = [\"fusion\"]\n    families = [\"render.local\"]\n    settings_category = \"fusion\"\n\n    is_rendered_key = \"_fusionrenderlocal_has_rendered\"\n\n    # Settings\n    suppress_dialogs = True\n\n    def process(self, instance):\n\n        # Start render\n        result = self.render(instance)\n        if result is False:\n            raise RuntimeError(f\"Comp render failed for {instance}\")\n\n        self._add_representation(instance)\n\n        # Log render status\n        self.log.info(\n            \"Rendered '{}' for folder '{}' under the task '{}'\".format(\n                instance.data[\"name\"],\n                instance.data[\"folderPath\"],\n                instance.data[\"task\"],\n            )\n        )\n\n    def render(self, instance):\n        \"\"\"Render instance.\n\n        We try to render the minimal amount of times by combining the instances\n        that have a matching frame range in one Fusion render. Then for the\n        batch of instances we store whether the render succeeded or failed.\n\n        \"\"\"\n\n        if self.is_rendered_key in instance.data:\n            # This instance was already processed in batch with another\n            # instance, so we just return the render result directly\n            self.log.debug(f\"Instance {instance} was already rendered\")\n            return instance.data[self.is_rendered_key]\n\n        instances_by_frame_range = self.get_render_instances_by_frame_range(\n            instance.context\n        )\n\n        # Render matching batch of instances that share the same frame range\n        frame_range = self.get_instance_render_frame_range(instance)\n        render_instances = instances_by_frame_range[frame_range]\n\n        # We initialize render state false to indicate it wasn't successful\n        # yet to keep track of whether Fusion succeeded. This is for cases\n        # where an error below this might cause the comp render result not\n        # to be stored for the instances of this batch\n        for render_instance in render_instances:\n            render_instance.data[self.is_rendered_key] = False\n\n        savers_to_render = [inst.data[\"tool\"] for inst in render_instances]\n        current_comp = instance.context.data[\"currentComp\"]\n        frame_start, frame_end = frame_range\n\n        self.log.info(\n            f\"Starting Fusion render frame range {frame_start}-{frame_end}\"\n        )\n        saver_names = \", \".join(saver.Name for saver in savers_to_render)\n        self.log.info(f\"Rendering tools: {saver_names}\")\n\n        with comp_lock_and_undo_chunk(current_comp):\n            with maintained_comp_range(current_comp):\n                with enabled_savers(current_comp, savers_to_render):\n                    render_kwargs = {\n                        \"Start\": frame_start,\n                        \"End\": frame_end,\n                        \"Wait\": True\n                    }\n                    if self.suppress_dialogs:\n                        render_kwargs[\"RenderFlags\"] = REQF_Quiet\n\n                    result = current_comp.Render(render_kwargs)\n\n        # Store the render state for all the rendered instances\n        for render_instance in render_instances:\n            render_instance.data[self.is_rendered_key] = bool(result)\n\n        return result\n\n    def _add_representation(self, instance):\n        \"\"\"Add representation to instance\"\"\"\n\n        expected_files = instance.data[\"expectedFiles\"]\n\n        start = instance.data[\"frameStart\"] - instance.data[\"handleStart\"]\n\n        path = expected_files[0]\n        _, padding, ext = get_frame_path(path)\n\n        staging_dir = os.path.dirname(path)\n\n        files = [os.path.basename(f) for f in expected_files]\n        if len(expected_files) == 1:\n            files = files[0]\n\n        repre = {\n            \"name\": ext[1:],\n            \"ext\": ext[1:],\n            \"frameStart\": f\"%0{padding}d\" % start,\n            \"files\": files,\n            \"stagingDir\": staging_dir,\n        }\n\n        self.set_representation_colorspace(\n            representation=repre,\n            context=instance.context,\n        )\n\n        # review representation\n        if instance.data.get(\"review\", False):\n            repre[\"tags\"] = [\"review\"]\n\n        # add the repre to the instance\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n        instance.data[\"representations\"].append(repre)\n\n        return instance\n\n    def get_render_instances_by_frame_range(self, context):\n        \"\"\"Return enabled render.local instances grouped by their frame range.\n\n        Arguments:\n            context (pyblish.Context): The pyblish context\n\n        Returns:\n            dict: (start, end): instances mapping\n\n        \"\"\"\n\n        instances_to_render = [\n            instance for instance in context if\n            # Only active instances\n            instance.data.get(\"publish\", True) and\n            # Only render.local instances\n            \"render.local\" in instance.data.get(\"families\", [])\n        ]\n\n        # Instances by frame ranges\n        instances_by_frame_range = collections.defaultdict(list)\n        for instance in instances_to_render:\n            start, end = self.get_instance_render_frame_range(instance)\n            instances_by_frame_range[(start, end)].append(instance)\n\n        return dict(instances_by_frame_range)\n\n    def get_instance_render_frame_range(self, instance):\n        start = instance.data[\"frameStartHandle\"]\n        end = instance.data[\"frameEndHandle\"]\n        return start, end\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html#client.ayon_fusion.plugins.publish.extract_render_local.FusionRenderLocal.get_render_instances_by_frame_range","title":"<code>get_render_instances_by_frame_range(context)</code>","text":"<p>Return enabled render.local instances grouped by their frame range.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Context</code> <p>The pyblish context</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>(start, end): instances mapping</p> Source code in <code>client/ayon_fusion/plugins/publish/extract_render_local.py</code> <pre><code>def get_render_instances_by_frame_range(self, context):\n    \"\"\"Return enabled render.local instances grouped by their frame range.\n\n    Arguments:\n        context (pyblish.Context): The pyblish context\n\n    Returns:\n        dict: (start, end): instances mapping\n\n    \"\"\"\n\n    instances_to_render = [\n        instance for instance in context if\n        # Only active instances\n        instance.data.get(\"publish\", True) and\n        # Only render.local instances\n        \"render.local\" in instance.data.get(\"families\", [])\n    ]\n\n    # Instances by frame ranges\n    instances_by_frame_range = collections.defaultdict(list)\n    for instance in instances_to_render:\n        start, end = self.get_instance_render_frame_range(instance)\n        instances_by_frame_range[(start, end)].append(instance)\n\n    return dict(instances_by_frame_range)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html#client.ayon_fusion.plugins.publish.extract_render_local.FusionRenderLocal.render","title":"<code>render(instance)</code>","text":"<p>Render instance.</p> <p>We try to render the minimal amount of times by combining the instances that have a matching frame range in one Fusion render. Then for the batch of instances we store whether the render succeeded or failed.</p> Source code in <code>client/ayon_fusion/plugins/publish/extract_render_local.py</code> <pre><code>def render(self, instance):\n    \"\"\"Render instance.\n\n    We try to render the minimal amount of times by combining the instances\n    that have a matching frame range in one Fusion render. Then for the\n    batch of instances we store whether the render succeeded or failed.\n\n    \"\"\"\n\n    if self.is_rendered_key in instance.data:\n        # This instance was already processed in batch with another\n        # instance, so we just return the render result directly\n        self.log.debug(f\"Instance {instance} was already rendered\")\n        return instance.data[self.is_rendered_key]\n\n    instances_by_frame_range = self.get_render_instances_by_frame_range(\n        instance.context\n    )\n\n    # Render matching batch of instances that share the same frame range\n    frame_range = self.get_instance_render_frame_range(instance)\n    render_instances = instances_by_frame_range[frame_range]\n\n    # We initialize render state false to indicate it wasn't successful\n    # yet to keep track of whether Fusion succeeded. This is for cases\n    # where an error below this might cause the comp render result not\n    # to be stored for the instances of this batch\n    for render_instance in render_instances:\n        render_instance.data[self.is_rendered_key] = False\n\n    savers_to_render = [inst.data[\"tool\"] for inst in render_instances]\n    current_comp = instance.context.data[\"currentComp\"]\n    frame_start, frame_end = frame_range\n\n    self.log.info(\n        f\"Starting Fusion render frame range {frame_start}-{frame_end}\"\n    )\n    saver_names = \", \".join(saver.Name for saver in savers_to_render)\n    self.log.info(f\"Rendering tools: {saver_names}\")\n\n    with comp_lock_and_undo_chunk(current_comp):\n        with maintained_comp_range(current_comp):\n            with enabled_savers(current_comp, savers_to_render):\n                render_kwargs = {\n                    \"Start\": frame_start,\n                    \"End\": frame_end,\n                    \"Wait\": True\n                }\n                if self.suppress_dialogs:\n                    render_kwargs[\"RenderFlags\"] = REQF_Quiet\n\n                result = current_comp.Render(render_kwargs)\n\n    # Store the render state for all the rendered instances\n    for render_instance in render_instances:\n        render_instance.data[self.is_rendered_key] = bool(result)\n\n    return result\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/extract_render_local.html#client.ayon_fusion.plugins.publish.extract_render_local.enabled_savers","title":"<code>enabled_savers(comp, savers)</code>","text":"<p>Enable only the <code>savers</code> in Comp during the context.</p> <p>Any Saver tool in the passed composition that is not in the savers list will be set to passthrough during the context.</p> <p>Parameters:</p> Name Type Description Default <code>comp</code> <code>object</code> <p>Fusion composition object.</p> required <code>savers</code> <code>list</code> <p>List of Saver tool objects.</p> required Source code in <code>client/ayon_fusion/plugins/publish/extract_render_local.py</code> <pre><code>@contextlib.contextmanager\ndef enabled_savers(comp, savers):\n    \"\"\"Enable only the `savers` in Comp during the context.\n\n    Any Saver tool in the passed composition that is not in the savers list\n    will be set to passthrough during the context.\n\n    Args:\n        comp (object): Fusion composition object.\n        savers (list): List of Saver tool objects.\n\n    \"\"\"\n    passthrough_key = \"TOOLB_PassThrough\"\n    original_states = {}\n    enabled_saver_names = {saver.Name for saver in savers}\n\n    all_savers = comp.GetToolList(False, \"Saver\").values()\n    savers_by_name = {saver.Name: saver for saver in all_savers}\n\n    try:\n        for saver in all_savers:\n            original_state = saver.GetAttrs()[passthrough_key]\n            original_states[saver.Name] = original_state\n\n            # The passthrough state we want to set (passthrough != enabled)\n            state = saver.Name not in enabled_saver_names\n            if state != original_state:\n                saver.SetAttrs({passthrough_key: state})\n        yield\n    finally:\n        for saver_name, original_state in original_states.items():\n            saver = savers_by_name[saver_name]\n            saver.SetAttrs({\"TOOLB_PassThrough\": original_state})\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/increment_current_file.html","title":"increment_current_file","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/increment_current_file.html#client.ayon_fusion.plugins.publish.increment_current_file.FusionIncrementCurrentFile","title":"<code>FusionIncrementCurrentFile</code>","text":"<p>               Bases: <code>ContextPlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Increment the current file.</p> <p>Saves the current file with an increased version number.</p> Source code in <code>client/ayon_fusion/plugins/publish/increment_current_file.py</code> <pre><code>class FusionIncrementCurrentFile(\n    pyblish.api.ContextPlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Increment the current file.\n\n    Saves the current file with an increased version number.\"\"\"\n\n    label = \"Increment workfile version\"\n    order = pyblish.api.IntegratorOrder + 9.0\n    hosts = [\"fusion\"]\n    optional = True\n\n    def process(self, context):\n        if not self.is_active(context.data):\n            return\n\n        comp = context.data.get(\"currentComp\")\n        assert comp, \"Must have comp\"\n\n        # Fusion can have multiple compositions open at the same time, and\n        # as a publish is running the user may switch to another comp\n        # simultaneously. Hence, we need to ensure the active comp is the\n        # one current publish session is for in the registered host.\n        host: FusionHost = registered_host()\n        with host.current_comp(comp):\n            self.increment_workfile(context)\n\n    def increment_workfile(self, context: pyblish.api.Context):\n        \"\"\"Increment the current workfile version using registered host.\"\"\"\n        current_filepath: str = context.data[\"currentFile\"]\n        try:\n            from ayon_core.pipeline.workfile import save_next_version\n            from ayon_core.host.interfaces import SaveWorkfileOptionalData\n\n            current_filename = os.path.basename(current_filepath)\n            save_next_version(\n                description=(\n                    f\"Incremented by publishing from {current_filename}\"\n                ),\n                # Optimize the save by reducing needed queries for context\n                prepared_data=SaveWorkfileOptionalData(\n                    project_entity=context.data[\"projectEntity\"],\n                    project_settings=context.data[\"project_settings\"],\n                    anatomy=context.data[\"anatomy\"],\n                )\n            )\n        except ImportError:\n            # Backwards compatibility before ayon-core 1.5.0\n            self.log.debug(\n                \"Using legacy `version_up`. Update AYON core addon to \"\n                \"use newer `save_next_version` function.\"\n            )\n            new_filepath = version_up(current_filepath)\n            host: IWorkfileHost = registered_host()\n            host.save_workfile(new_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/increment_current_file.html#client.ayon_fusion.plugins.publish.increment_current_file.FusionIncrementCurrentFile.increment_workfile","title":"<code>increment_workfile(context)</code>","text":"<p>Increment the current workfile version using registered host.</p> Source code in <code>client/ayon_fusion/plugins/publish/increment_current_file.py</code> <pre><code>def increment_workfile(self, context: pyblish.api.Context):\n    \"\"\"Increment the current workfile version using registered host.\"\"\"\n    current_filepath: str = context.data[\"currentFile\"]\n    try:\n        from ayon_core.pipeline.workfile import save_next_version\n        from ayon_core.host.interfaces import SaveWorkfileOptionalData\n\n        current_filename = os.path.basename(current_filepath)\n        save_next_version(\n            description=(\n                f\"Incremented by publishing from {current_filename}\"\n            ),\n            # Optimize the save by reducing needed queries for context\n            prepared_data=SaveWorkfileOptionalData(\n                project_entity=context.data[\"projectEntity\"],\n                project_settings=context.data[\"project_settings\"],\n                anatomy=context.data[\"anatomy\"],\n            )\n        )\n    except ImportError:\n        # Backwards compatibility before ayon-core 1.5.0\n        self.log.debug(\n            \"Using legacy `version_up`. Update AYON core addon to \"\n            \"use newer `save_next_version` function.\"\n        )\n        new_filepath = version_up(current_filepath)\n        host: IWorkfileHost = registered_host()\n        host.save_workfile(new_filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/save_scene.html","title":"save_scene","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/save_scene.html#client.ayon_fusion.plugins.publish.save_scene.FusionSaveComp","title":"<code>FusionSaveComp</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Save current comp</p> Source code in <code>client/ayon_fusion/plugins/publish/save_scene.py</code> <pre><code>class FusionSaveComp(pyblish.api.ContextPlugin):\n    \"\"\"Save current comp\"\"\"\n\n    label = \"Save current file\"\n    order = pyblish.api.ExtractorOrder - 0.49\n    hosts = [\"fusion\"]\n    families = [\"render\", \"image\", \"workfile\"]\n\n    def process(self, context):\n\n        comp = context.data.get(\"currentComp\")\n        assert comp, \"Must have comp\"\n\n        current = comp.GetAttrs().get(\"COMPS_FileName\", \"\")\n        assert context.data['currentFile'] == current\n\n        self.log.info(\"Saving current file: {}\".format(current))\n        comp.Save()\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_background_depth.html","title":"validate_background_depth","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_background_depth.html#client.ayon_fusion.plugins.publish.validate_background_depth.ValidateBackgroundDepth","title":"<code>ValidateBackgroundDepth</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate if all Background tool are set to float32 bit</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_background_depth.py</code> <pre><code>class ValidateBackgroundDepth(\n    pyblish.api.InstancePlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Validate if all Background tool are set to float32 bit\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Background Depth 32 bit\"\n    hosts = [\"fusion\"]\n    families = [\"render\", \"image\"]\n    optional = True\n\n    actions = [SelectInvalidAction, publish.RepairAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n        context = instance.context\n        comp = context.data.get(\"currentComp\")\n        assert comp, \"Must have Comp object\"\n\n        backgrounds = comp.GetToolList(False, \"Background\").values()\n        if not backgrounds:\n            return []\n\n        return [i for i in backgrounds if i.GetInput(\"Depth\") != 4.0]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Found {} Backgrounds tools which\"\n                \" are not set to float32\".format(len(invalid)),\n                title=self.label,\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        comp = instance.context.data.get(\"currentComp\")\n        invalid = cls.get_invalid(instance)\n        for i in invalid:\n            i.SetInput(\"Depth\", 4.0, comp.TIME_UNDEFINED)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_comp_saved.html","title":"validate_comp_saved","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_comp_saved.html#client.ayon_fusion.plugins.publish.validate_comp_saved.ValidateFusionCompSaved","title":"<code>ValidateFusionCompSaved</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Ensure current comp is saved</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_comp_saved.py</code> <pre><code>class ValidateFusionCompSaved(pyblish.api.ContextPlugin):\n    \"\"\"Ensure current comp is saved\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Comp Saved\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n\n    def process(self, context):\n\n        comp = context.data.get(\"currentComp\")\n        assert comp, \"Must have Comp object\"\n        attrs = comp.GetAttrs()\n\n        filename = attrs[\"COMPS_FileName\"]\n        if not filename:\n            raise PublishValidationError(\"Comp is not saved.\",\n                                         title=self.label)\n\n        if not os.path.exists(filename):\n            raise PublishValidationError(\n                \"Comp file does not exist: %s\" % filename, title=self.label)\n\n        if attrs[\"COMPB_Modified\"]:\n            self.log.warning(\"Comp is modified. Save your comp to ensure your \"\n                             \"changes propagate correctly.\")\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_create_folder_checked.html","title":"validate_create_folder_checked","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_create_folder_checked.html#client.ayon_fusion.plugins.publish.validate_create_folder_checked.ValidateCreateFolderChecked","title":"<code>ValidateCreateFolderChecked</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Valid if all savers have the input attribute CreateDir checked on</p> <p>This attribute ensures that the folders to which the saver will write will be created.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_create_folder_checked.py</code> <pre><code>class ValidateCreateFolderChecked(pyblish.api.InstancePlugin):\n    \"\"\"Valid if all savers have the input attribute CreateDir checked on\n\n    This attribute ensures that the folders to which the saver will write\n    will be created.\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Create Folder Checked\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [RepairAction, SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n        tool = instance.data[\"tool\"]\n        create_dir = tool.GetInput(\"CreateDir\")\n        if create_dir == 0.0:\n            cls.log.error(\n                \"%s has Create Folder turned off\" % instance[0].Name\n            )\n            return [tool]\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\n                \"Found Saver with Create Folder During Render checked off\",\n                title=self.label,\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        invalid = cls.get_invalid(instance)\n        for tool in invalid:\n            tool.SetInput(\"CreateDir\", 1.0)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_expected_frames_existence.html","title":"validate_expected_frames_existence","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_expected_frames_existence.html#client.ayon_fusion.plugins.publish.validate_expected_frames_existence.ValidateLocalFramesExistence","title":"<code>ValidateLocalFramesExistence</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Checks if files for savers that's set to publish expected frames exists</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_expected_frames_existence.py</code> <pre><code>class ValidateLocalFramesExistence(pyblish.api.InstancePlugin):\n    \"\"\"Checks if files for savers that's set\n    to publish expected frames exists\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Expected Frames Exists\"\n    families = [\"render.frames\"]\n    hosts = [\"fusion\"]\n    actions = [RepairAction, SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, instance, non_existing_frames=None):\n        if non_existing_frames is None:\n            non_existing_frames = []\n\n        tool = instance.data[\"tool\"]\n\n        expected_files = instance.data[\"expectedFiles\"]\n\n        for file in expected_files:\n            if not os.path.exists(file):\n                cls.log.error(\n                    f\"Missing file: {file}\"\n                )\n                non_existing_frames.append(file)\n\n        if len(non_existing_frames) &gt; 0:\n            cls.log.error(f\"Some of {tool.Name}'s files does not exist\")\n            return [tool]\n\n    def process(self, instance):\n        non_existing_frames = []\n        invalid = self.get_invalid(instance, non_existing_frames)\n        if invalid:\n            raise PublishValidationError(\n                \"{} is set to publish existing frames but \"\n                \"some frames are missing. \"\n                \"The missing file(s) are:\\n\\n{}\".format(\n                    invalid[0].Name,\n                    \"\\n\\n\".join(non_existing_frames),\n                ),\n                title=self.label,\n            )\n\n    @classmethod\n    def repair(cls, instance):\n        invalid = cls.get_invalid(instance)\n        if invalid:\n            tool = instance.data[\"tool\"]\n            # Change render target to local to render locally\n            tool.SetData(\"openpype.creator_attributes.render_target\", \"local\")\n\n            cls.log.info(\n                f\"Reload the publisher and {tool.Name} \"\n                \"will be set to render locally\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_filename_has_extension.html","title":"validate_filename_has_extension","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_filename_has_extension.html#client.ayon_fusion.plugins.publish.validate_filename_has_extension.ValidateFilenameHasExtension","title":"<code>ValidateFilenameHasExtension</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Ensure the Saver has an extension in the filename path</p> <p>This disallows files written as <code>filename</code> instead of <code>filename.frame.ext</code>. Fusion does not always set an extension for your filename when changing the file format of the saver.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_filename_has_extension.py</code> <pre><code>class ValidateFilenameHasExtension(pyblish.api.InstancePlugin):\n    \"\"\"Ensure the Saver has an extension in the filename path\n\n    This disallows files written as `filename` instead of `filename.frame.ext`.\n    Fusion does not always set an extension for your filename when\n    changing the file format of the saver.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Filename Has Extension\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [SelectInvalidAction]\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            raise PublishValidationError(\"Found Saver without an extension\",\n                                         title=self.label)\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        path = instance.data[\"expectedFiles\"][0]\n        fname, ext = os.path.splitext(path)\n\n        if not ext:\n            tool = instance.data[\"tool\"]\n            cls.log.error(\"%s has no extension specified\" % tool.Name)\n            return [tool]\n\n        return []\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_image_frame.html","title":"validate_image_frame","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_image_frame.html#client.ayon_fusion.plugins.publish.validate_image_frame.ValidateImageFrame","title":"<code>ValidateImageFrame</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validates that <code>image</code> product type contains only single frame.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_image_frame.py</code> <pre><code>class ValidateImageFrame(pyblish.api.InstancePlugin):\n    \"\"\"Validates that `image` product type contains only single frame.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Image Frame\"\n    families = [\"image\"]\n    hosts = [\"fusion\"]\n\n    def process(self, instance):\n        render_start = instance.data[\"frameStartHandle\"]\n        render_end = instance.data[\"frameEndHandle\"]\n        too_many_frames = (isinstance(instance.data[\"expectedFiles\"], list)\n                           and len(instance.data[\"expectedFiles\"]) &gt; 1)\n\n        if render_end - render_start &gt; 0 or too_many_frames:\n            desc = (\"Trying to render multiple frames. 'image' product type \"\n                    \"is meant for single frame. Please use 'render' creator.\")\n            raise PublishValidationError(\n                title=\"Frame range outside of comp range\",\n                message=desc,\n                description=desc\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_frame_range.html","title":"validate_instance_frame_range","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_frame_range.html#client.ayon_fusion.plugins.publish.validate_instance_frame_range.ValidateInstanceFrameRange","title":"<code>ValidateInstanceFrameRange</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate instance frame range is within comp's global render range.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_instance_frame_range.py</code> <pre><code>class ValidateInstanceFrameRange(pyblish.api.InstancePlugin):\n    \"\"\"Validate instance frame range is within comp's global render range.\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Frame Range\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n\n    def process(self, instance):\n\n        context = instance.context\n        global_start = context.data[\"compFrameStart\"]\n        global_end = context.data[\"compFrameEnd\"]\n\n        render_start = instance.data[\"frameStartHandle\"]\n        render_end = instance.data[\"frameEndHandle\"]\n\n        if render_start &lt; global_start or render_end &gt; global_end:\n\n            message = (\n                f\"Instance {instance} render frame range \"\n                f\"({render_start}-{render_end}) is outside of the comp's \"\n                f\"global render range ({global_start}-{global_end}) and thus \"\n                f\"can't be rendered. \"\n            )\n            description = (\n                f\"{message}\\n\\n\"\n                f\"Either update the comp's global range or the instance's \"\n                f\"frame range to ensure the comp's frame range includes the \"\n                f\"to render frame range for the instance.\"\n            )\n            raise PublishValidationError(\n                title=\"Frame range outside of comp range\",\n                message=message,\n                description=description\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_in_context.html","title":"validate_instance_in_context","text":"<p>Validate if instance context is the same as publish context.</p>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_in_context.html#client.ayon_fusion.plugins.publish.validate_instance_in_context.ValidateInstanceInContextFusion","title":"<code>ValidateInstanceInContextFusion</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validator to check if instance context matches context of publish.</p> <p>When working in per-shot style you always publish data in context of current asset (shot). This validator checks if this is so. It is optional so it can be disabled when needed.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_instance_in_context.py</code> <pre><code>class ValidateInstanceInContextFusion(pyblish.api.InstancePlugin,\n                                      OptionalPyblishPluginMixin):\n    \"\"\"Validator to check if instance context matches context of publish.\n\n    When working in per-shot style you always publish data in context of\n    current asset (shot). This validator checks if this is so. It is optional\n    so it can be disabled when needed.\n    \"\"\"\n    # Similar to maya and houdini-equivalent `ValidateInstanceInContext`\n\n    order = ValidateContentsOrder\n    label = \"Instance in same Context\"\n    optional = True\n    hosts = [\"fusion\"]\n    actions = [SelectToolAction, RepairAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        instance_context = self.get_context(instance.data)\n        context = self.get_context(instance.context.data)\n        if instance_context != context:\n            context_label = \"{} &gt; {}\".format(*context)\n            instance_label = \"{} &gt; {}\".format(*instance_context)\n\n            raise PublishValidationError(\n                message=(\n                    \"Instance '{}' publishes to different asset than current \"\n                    \"context: {}. Current context: {}\".format(\n                        instance.name, instance_label, context_label\n                    )\n                ),\n                description=(\n                    \"## Publishing to a different asset\\n\"\n                    \"There are publish instances present which are publishing \"\n                    \"into a different asset than your current context.\\n\\n\"\n                    \"Usually this is not what you want but there can be cases \"\n                    \"where you might want to publish into another asset or \"\n                    \"shot. If that's the case you can disable the validation \"\n                    \"on the instance to ignore it.\"\n                )\n            )\n\n    @classmethod\n    def repair(cls, instance):\n\n        create_context = instance.context.data[\"create_context\"]\n        instance_id = instance.data.get(\"instance_id\")\n        created_instance = create_context.get_instance_by_id(\n            instance_id\n        )\n        if created_instance is None:\n            raise RuntimeError(\n                f\"No CreatedInstances found with id '{instance_id} \"\n                f\"in {create_context.instances_by_id}\"\n            )\n\n        context_asset, context_task = cls.get_context(instance.context.data)\n        created_instance[\"folderPath\"] = context_asset\n        created_instance[\"task\"] = context_task\n        create_context.save_changes()\n\n    @staticmethod\n    def get_context(data):\n        \"\"\"Return asset, task from publishing context data\"\"\"\n        return data[\"folderPath\"], data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_instance_in_context.html#client.ayon_fusion.plugins.publish.validate_instance_in_context.ValidateInstanceInContextFusion.get_context","title":"<code>get_context(data)</code>  <code>staticmethod</code>","text":"<p>Return asset, task from publishing context data</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_instance_in_context.py</code> <pre><code>@staticmethod\ndef get_context(data):\n    \"\"\"Return asset, task from publishing context data\"\"\"\n    return data[\"folderPath\"], data[\"task\"]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_has_input.html","title":"validate_saver_has_input","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_has_input.html#client.ayon_fusion.plugins.publish.validate_saver_has_input.ValidateSaverHasInput","title":"<code>ValidateSaverHasInput</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Validate saver has incoming connection</p> <p>This ensures a Saver has at least an input connection.</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_saver_has_input.py</code> <pre><code>class ValidateSaverHasInput(pyblish.api.InstancePlugin):\n    \"\"\"Validate saver has incoming connection\n\n    This ensures a Saver has at least an input connection.\n\n    \"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Saver Has Input\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, instance):\n\n        saver = instance.data[\"tool\"]\n        if not saver.Input.GetConnectedOutput():\n            return [saver]\n\n        return []\n\n    def process(self, instance):\n        invalid = self.get_invalid(instance)\n        if invalid:\n            saver_name = invalid[0].Name\n            raise PublishValidationError(\n                \"Saver has no incoming connection: {} ({})\".format(instance,\n                                                                   saver_name),\n                title=self.label)\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_passthrough.html","title":"validate_saver_passthrough","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_passthrough.html#client.ayon_fusion.plugins.publish.validate_saver_passthrough.ValidateSaverPassthrough","title":"<code>ValidateSaverPassthrough</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Validate saver passthrough is similar to Pyblish publish state</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_saver_passthrough.py</code> <pre><code>class ValidateSaverPassthrough(pyblish.api.ContextPlugin):\n    \"\"\"Validate saver passthrough is similar to Pyblish publish state\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Saver Passthrough\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [SelectInvalidAction]\n\n    def process(self, context):\n\n        # Workaround for ContextPlugin always running, even if no instance\n        # is present with the family\n        instances = pyblish.api.instances_by_plugin(instances=list(context),\n                                                    plugin=self)\n        if not instances:\n            self.log.debug(\"Ignoring plugin.. (bugfix)\")\n\n        invalid_instances = []\n        for instance in instances:\n            invalid = self.is_invalid(instance)\n            if invalid:\n                invalid_instances.append(instance)\n\n        if invalid_instances:\n            self.log.info(\"Reset pyblish to collect your current scene state, \"\n                          \"that should fix error.\")\n            raise PublishValidationError(\n                \"Invalid instances: {0}\".format(invalid_instances),\n                title=self.label)\n\n    def is_invalid(self, instance):\n\n        saver = instance.data[\"tool\"]\n        attr = saver.GetAttrs()\n        active = not attr[\"TOOLB_PassThrough\"]\n\n        if active != instance.data.get(\"publish\", True):\n            self.log.info(\"Saver has different passthrough state than \"\n                          \"Pyblish: {} ({})\".format(instance, saver.Name))\n            return [saver]\n\n        return []\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_resolution.html","title":"validate_saver_resolution","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_saver_resolution.html#client.ayon_fusion.plugins.publish.validate_saver_resolution.ValidateSaverResolution","title":"<code>ValidateSaverResolution</code>","text":"<p>               Bases: <code>InstancePlugin</code>, <code>OptionalPyblishPluginMixin</code></p> <p>Validate that the saver input resolution matches the folder resolution</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_saver_resolution.py</code> <pre><code>class ValidateSaverResolution(\n    pyblish.api.InstancePlugin, OptionalPyblishPluginMixin\n):\n    \"\"\"Validate that the saver input resolution matches the folder resolution\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Folder Resolution\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    optional = True\n    actions = [SelectInvalidAction]\n\n    def process(self, instance):\n        if not self.is_active(instance.data):\n            return\n\n        resolution = self.get_resolution(instance)\n        expected_resolution = self.get_expected_resolution(instance)\n        if resolution != expected_resolution:\n            raise PublishValidationError(\n                \"The input's resolution does not match \"\n                \"the folder's resolution {}x{}.\\n\\n\"\n                \"The input's resolution is {}x{}.\".format(\n                    expected_resolution[0], expected_resolution[1],\n                    resolution[0], resolution[1]\n                )\n            )\n\n    @classmethod\n    def get_invalid(cls, instance):\n        saver = instance.data[\"tool\"]\n        try:\n            resolution = cls.get_resolution(instance)\n        except PublishValidationError:\n            resolution = None\n        expected_resolution = cls.get_expected_resolution(instance)\n        if resolution != expected_resolution:\n            return [saver]\n\n    @classmethod\n    def get_resolution(cls, instance):\n        saver = instance.data[\"tool\"]\n        first_frame = instance.data[\"frameStartHandle\"]\n\n        try:\n            return get_tool_resolution(saver, frame=first_frame)\n        except ValueError:\n            raise PublishValidationError(\n                \"Cannot get resolution info for frame '{}'.\\n\\n \"\n                \"Please check that saver has connected input.\".format(\n                    first_frame\n                )\n            )\n\n    @classmethod\n    def get_expected_resolution(cls, instance):\n\n        entity = instance.data.get(\"taskEntity\")\n        if not entity:\n            cls.log.debug(\n                \"Using folder entity resolution for validation because \"\n                f\"task entity not found for instance: {instance}\")\n            entity = instance.data[\"folderEntity\"]\n\n        attributes = entity[\"attrib\"]\n        return attributes[\"resolutionWidth\"], attributes[\"resolutionHeight\"]\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_unique_subsets.html","title":"validate_unique_subsets","text":""},{"location":"autoapi/client/ayon_fusion/plugins/publish/validate_unique_subsets.html#client.ayon_fusion.plugins.publish.validate_unique_subsets.ValidateUniqueSubsets","title":"<code>ValidateUniqueSubsets</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Ensure all instances have a unique product name</p> Source code in <code>client/ayon_fusion/plugins/publish/validate_unique_subsets.py</code> <pre><code>class ValidateUniqueSubsets(pyblish.api.ContextPlugin):\n    \"\"\"Ensure all instances have a unique product name\"\"\"\n\n    order = pyblish.api.ValidatorOrder\n    label = \"Validate Unique Products\"\n    families = [\"render\", \"image\"]\n    hosts = [\"fusion\"]\n    actions = [SelectInvalidAction]\n\n    @classmethod\n    def get_invalid(cls, context):\n\n        # Collect instances per product per folder\n        instances_per_product_folder = defaultdict(lambda: defaultdict(list))\n        for instance in context:\n            folder_path = instance.data[\"folderPath\"]\n            product_name = instance.data[\"productName\"]\n            instances_per_product_folder[folder_path][product_name].append(\n                instance\n            )\n\n        # Find which folder + subset combination has more than one instance\n        # Those are considered invalid because they'd integrate to the same\n        # destination.\n        invalid = []\n        for folder_path, instances_per_product in (\n            instances_per_product_folder.items()\n        ):\n            for product_name, instances in instances_per_product.items():\n                if len(instances) &gt; 1:\n                    cls.log.warning(\n                        (\n                            \"{folder_path} &gt; {product_name} used by more than \"\n                            \"one instance: {instances}\"\n                        ).format(\n                            folder_path=folder_path,\n                            product_name=product_name,\n                            instances=instances\n                        )\n                    )\n                    invalid.extend(instances)\n\n        # Return tools for the invalid instances so they can be selected\n        invalid = [instance.data[\"tool\"] for instance in invalid]\n\n        return invalid\n\n    def process(self, context):\n        invalid = self.get_invalid(context)\n        if invalid:\n            raise PublishValidationError(\n                \"Multiple instances are set to the same folder &gt; product.\",\n                title=self.label\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/scripts/index.html","title":"scripts","text":""},{"location":"autoapi/client/ayon_fusion/scripts/duplicate_with_inputs.html","title":"duplicate_with_inputs","text":""},{"location":"autoapi/client/ayon_fusion/scripts/duplicate_with_inputs.html#client.ayon_fusion.scripts.duplicate_with_inputs.duplicate_with_input_connections","title":"<code>duplicate_with_input_connections()</code>","text":"<p>Duplicate selected tools with incoming connections.</p> Source code in <code>client/ayon_fusion/scripts/duplicate_with_inputs.py</code> <pre><code>def duplicate_with_input_connections():\n    \"\"\"Duplicate selected tools with incoming connections.\"\"\"\n\n    comp = get_current_comp()\n    original_tools = comp.GetToolList(True).values()\n    if not original_tools:\n        return  # nothing selected\n\n    with comp_lock_and_undo_chunk(\n            comp, \"Duplicate With Input Connections\"):\n\n        # Generate duplicates\n        comp.Copy()\n        comp.SetActiveTool()\n        comp.Paste()\n        duplicate_tools = comp.GetToolList(True).values()\n\n        # Copy connections\n        for original, new in zip(original_tools, duplicate_tools):\n\n            original_inputs = original.GetInputList().values()\n            new_inputs = new.GetInputList().values()\n            assert len(original_inputs) == len(new_inputs)\n\n            for original_input, new_input in zip(original_inputs, new_inputs):\n\n                if is_connected(original_input):\n\n                    if is_connected(new_input):\n                        # Already connected if it is between the copied tools\n                        continue\n\n                    new_input.ConnectTo(original_input.GetConnectedOutput())\n                    assert is_connected(new_input), \"Must be connected now\"\n</code></pre>"},{"location":"autoapi/client/ayon_fusion/scripts/duplicate_with_inputs.html#client.ayon_fusion.scripts.duplicate_with_inputs.is_connected","title":"<code>is_connected(input)</code>","text":"<p>Return whether an input has incoming connection</p> Source code in <code>client/ayon_fusion/scripts/duplicate_with_inputs.py</code> <pre><code>def is_connected(input):\n    \"\"\"Return whether an input has incoming connection\"\"\"\n    return input.GetAttrs()[\"INPB_Connected\"]\n</code></pre>"},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings.html","title":"settings","text":""}]}